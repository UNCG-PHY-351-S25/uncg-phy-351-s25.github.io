{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"PHY 351 Reference Course Administrivia Course syllabus Recipes This compendium of computational physics \"recipes\" is the primary reference material of the PHY 351 course. Rather than reading it straight through, as you might a traditional textbook, let the course assignments guide you. The various exercises each specify one recipe that you are to try for yourself; that is a good time to read the recipe in detail. You'll probably want to refer back to prior recipes at least occasionally, until you've internalized them. What is a \"recipe\"? Skillset A: Core Python Numerical Methods 1: Finding Roots & Extrema Skillset B: Scientific Python Numerical Methods 2: Numerical Calculus Numerical Methods 3: ODE Integration Skillset C: Visual Python Topics This section of the website contains a grab-bag of miscellaneous general reference information, tips about using python, and links to helpful outside resources. Some of the recipes link to specific topics here for further detail.","title":"PHY 351 Reference"},{"location":"#phy-351-reference","text":"","title":"PHY 351 Reference"},{"location":"#course-administrivia","text":"Course syllabus","title":"Course Administrivia"},{"location":"#recipes","text":"This compendium of computational physics \"recipes\" is the primary reference material of the PHY 351 course. Rather than reading it straight through, as you might a traditional textbook, let the course assignments guide you. The various exercises each specify one recipe that you are to try for yourself; that is a good time to read the recipe in detail. You'll probably want to refer back to prior recipes at least occasionally, until you've internalized them. What is a \"recipe\"? Skillset A: Core Python Numerical Methods 1: Finding Roots & Extrema Skillset B: Scientific Python Numerical Methods 2: Numerical Calculus Numerical Methods 3: ODE Integration Skillset C: Visual Python","title":"Recipes"},{"location":"#topics","text":"This section of the website contains a grab-bag of miscellaneous general reference information, tips about using python, and links to helpful outside resources. Some of the recipes link to specific topics here for further detail.","title":"Topics"},{"location":"admin/syllabus/","text":"Physics 351 Spring 2025 Course Syllabus Version 1.1, 2025-01-16 Welcome to PHY 351, Introduction to Computational Physics ! Computers have become essential in all aspects of physics. That shouldn't surprise you, because they've become essential in almost all aspects of almost anything; even my toothbrush has a tiny computer in it, and I didn't even get the version that talks to an iPhone app \ud83d\ude26. Let's zoom in on a key function of computers in physics: they can do math for us. In experimental physics , computers can analyze huge quantities of data in extraordinarily sophisticated ways (in addition to controlling the apparatus and collecting the data). In theoretical physics , they can perform calculations and solve equations that would be difficult or even impossible with analytic (\"paper-and-pencil\") methods alone. They've also created a third branch of physics, computational physics , in which we use direct computer simulation of physical systems (rather than physical experiments or analytic modeling) to explore their behavior and develop understanding. Much of the software to do such things is custom-written by physicists, using specialized coding tools and approaches. Skill with these tools and approaches is a scientific superpower that will pay off over and over, whether you stay in physics or take your skills to something else \u2014 like, for example, epidemiology, computational immunology, or financial modeling. The purpose of this course is to show you the foundational tools and methods of computational physics, and to start your journey along the path from beginner \u2192 fluent \u2192 expert. Administrivia Catalog information Credits: 3 (3:3:0 \u21d2 150 min/wk in class + 6-ish hrs/wk outside class for a \u201ctypical\u201d course). Course format: Face-to-face synchronous on-campus, technically (but not really, see below). Prerequisites: Grade of C or better in both PHY 292 and CSC 120, or permission of instructor. Corequisites: PHY 321, or permission of instructor. Corequisite need not be taken concurrently; prior completion is adequate. For whom planned: This course is designed for Physics majors, and is required for the Physics BS and BA degrees. Bulletin description: Introduction to computational methods used in physics and engineering, including computational simulation of physical systems, numerical solution of mathematical problems, and familiarity with scientific programming tools. Instructor information Instructor: Associate Prof. Ian D. Beatty (he, him, his) Email: idbeatty@uncg.edu Office: Petty 328 Phone: 336.256.1279 (goes to MS Teams, not my actual phone, so \ud83e\udd37\u200d\u2642\ufe0f) Physics & Astro Slack: @Beatty Twitter : Nope. So done with that. Instead, Bluesky : @ianbeatty.com Office Hours: To be announced \u2014 once I find out what days & times work best for y\u2019all. In the meantime, ask me when you can drop by, or make an appointment. Office hours are in person (Petty 328) or via MS Teams (with prior notice so I can start it up), as you prefer. Connection details are on the course Canvas site. Communication Slack is generally the fastest way to reach me. (Details are on Canvas .) Email is safer for something that must not fall through the cracks, but you may have to wait a few hours or even until the next day. I try to be responsive during off-hours, especially to things that might prevent you from working productively, but please do not assume you can reliably get my attention during evenings or weekends. I have three kids and an under-maintained house that need my attention too. I will occasionally need to reach you, personally or collectively, about important course changes, reminders, or issues. It is essential that you receive and actually read messages I send to your UNCG email address, either directly or via Canvas course announcements. Please configure your Canvas notification settings, email filters, and personal habits accordingly. Course Objectives Overall Goal Consider learning a foreign language: Knowing the meaning of a collection of words is marginally useful if you're trying to communicate with someone. Being fluent is orders of magnitude more useful, and lets you communicate things that are orders of magnitude more complex. One part of \"fluency\" is having practiced the translation of words often enough that it becomes automatic in your head, so you don't have to think about it. Another part is knowing a toolkit of idioms and other common language patterns for accomplishing specific communication goals. Knowing an idiom or pattern for a particular idea means I don't have to figure out how to piece words together to communicate it; that problem is already solved. I just reiterate the pattern, tweaking it as appropriate for the situation at hand. This course is organized around the idea that much of the challenge of becoming \"fluent\" with scientific coding is assembling a mental library of common idioms and patterns \u2014 known ways to arrange chunks of code to accomplish specific kinds of tasks. We'll call them recipes . Some are one-liners, some are patterns spread over many lines of code or even an entire program, and some are just sequences of steps to follow. All have the same purpose: Faced with a computational task, knowing a recipe for it means you don't have to stare at the screen and wonder how to start. The \"course content\" is a collection of recipes for you to learn. They are organized on a website, for convenient access. We have no textbook or other reading material, except for miscellaneous online reference materials to supplement the recipes. Learning Objectives By learning what the recipes accomplish and how to apply them, you will achieve the course learning outcomes: Be able to use the \"scientific python stack\" to perform interactive calculations, write programs, run programs, and work with data. This \"stack\" includes the core python language; scientific python libraries (specifically numpy , matplotlib , and scipy ); git and GitHub ; and the JupyterLab environment and its tools. Be able to construct and customize publication-quality data plots, with features like error bars and best-fit lines. Understand computer representations of numbers and their implications for accuracy and efficiency. Be able to create animated three-dimensional visual simulations of physical systems. Know and be able to apply some foundational \"numerical methods\" for doing math computationally, including solving nonlinear equations, finding the maxima and minima of functions, calculating derivatives and integrals, and solving ordinary differential equations. Philosophy and Instructional Approach I started programming in seventh grade when I went to junior high school, met friends who had Apple II computers, and encountered BASIC. It rocked my world, magnitude 9.5. Since then I've written functional, useful code in at least a dozen different programming languages, and dabbled with a dozen more. During that entire time I've taken precisely one programming course, in high school. Almost everything I've learned about coding and computer use has been self-taught. I firmly believe that one learns coding by doing it, not by reading about it or listening to someone explain it. Learning to program, and writing programs, and getting better at it is endless problem-solving , problem after problem after problem. You can embrace the struggle and enjoy the puzzles, or\u2026 \ud83d\ude35 Consequently, this course consists almost entirely of you working your way through a carefully-orchestrated sequence of computational physics challenges. I won't be lecturing or assigning readings. I've tried to give you enough initial orientation to each challenge and enough supporting reference material that you'll have a pretty good idea how to proceed. You will get stuck on things and encounter moments of confusion and, yes, frustration. That's not only normal, it's desirable: because that flash of insight or key bit of information that gets you unstuck and unconfused is where the most important learning happens. However, you are NOT meant to struggle through this alone and intolerably frustrated. One part of my role in the course is to create the structure and scaffolding for you to work through. Another is to be available to help you when, where, and how you need: to answer a question, to suggest a better approach, to inform you of a key language feature you are unaware of, to help you find a bug, to interpret a mysterious error message, and so on. This is way more efficient for both of us, and way more effective for you than, if I tried to pre-warn you of everything you might struggle with and everything you might need to know. You are also welcome to support each other, as-comrades-in-arms, as long as you mind the boundary between \"getting help\" and \"plagiarizing\". For specifics on that boundary, see the Academic Integrity Policy section below. And, I'll be showing you some ways that you can leverage AI tools to help you faster and better; see the Artificial Intelligence Policy section below. Textbook and Technology Course \"Textbook\" This course has no textbook. Why? I'm glad you asked\u2026 One of the most difficult aspects of learning to code \u2014 for physics, or any other purpose \u2014 is staring at a blank code editor with only a general, fuzzy idea of what you want to accomplish, and no clear idea of what code to write to accomplish it. This is the coder's version of the writer's \"blank page problem\". Ever been there? Yeah, me too. If you've solved similar coding problems before, then you can probably start by recreating what you did and modifying it. But what if you haven't? If you can find an example of someone else's solution to a similar problem, you may be able to copy and modify it\u2026 though depending on the complexity of the problem and the transparency or opaqueness of the example, understanding it well enough to know what to modify (and how), without breaking anything, may be be hair-pullingly infuriating. My solution to this is to offer you a cookbook of \"recipes\" \u2014 starting points that show you how to accomplish various common kinds of coding and computational physics tasks. They are meant to be clear, especially about which bits are essential and which are meant for you to fit to your specific needs. They also include examples, and sometimes variations upon the basic recipe for situations that are similar but differ in some important way. Some recipes are procedural, describing a sequence of steps for you to follow. Some are syntactic, showing specific python code to accomplish a task. Some are structural, recommending approaches to organizing code in pursuit of your goal. Often, recipes include key conceptual and/or informational knowledge about python, numerical methods, and the practice of computational physics. Understanding the ideas and knowing the facts is an essential part of using the recipes correctly, flexibly, and successfully. The collection of recipes is available to you on a website linked to from Canvas. Technology Our course Canvas site will serve as (a) a place to put general information such as my contact info, (b) a place for announcements, and (c) a place to keep track of the assignments you've completed. We'll use the GitHub website to distribute assignments to you and for you to submit your completed work bac, to me. (Don't worry, walking you through the setup and process for this is all in World A, Level 1.) You'll do your actual coding-and-running on Beskar , the name I've given to the 48-core, 384-GB beast of a computational physics server that sits on my desk. You'll connect to it from wherever you want via web browser, so you don't need to worry about installing anything on your own computer, or whether your decrepit old laptop can manage. Outside of class, the best way for us to communicate outside of class time is via Slack . Details are on Canvas. You are, of course, welcome to drop in on me during my open-office hours (listed on Canvas), or to make an appointment if that works better. It's really helpful for me to be able to send the occasional short, all-class announcement via Slack, so I really hope we can get everyone on board. Assignments, Grading, and Grades To understand the structure of this course, don't look to other courses you've taken\u2026 Look to video games! \ud83d\udd79\ufe0f Organization Content material of the course, and the assignments accompanying it, is divided into five Worlds : World A: Core Python World B: Numerical Solving, Finding & Randomness World C: Scientific Python World D: Numerical Calculus World E: Visual Python for Simulation Each world is divided into several (~3-9) Levels . That's too many to list here, so you can find them in the Modules section on Canvas. (Warning: That's a work in progress. Levels for the first worlds will appear soon/already; later ones will appear\u2026 later. We're building this airplane as we fly! \ud83d\ude2c) Just like a videogame level has a sequence of challenges followed by a level boss, a course \"level\" has a sequence of exercises followed by what I'm calling a miniboss . Each exercise targets one particular computational physics recipe . (See below; for now, think of that as one skill or idea.) The miniboss is a somewhat more complex challenge that requires you to combine several of the level's recipes. In addition to its levels, each world ends with a superboss challenge: A considerably more complex, authentic computational physics investigation. In addition to identifying and applying the various recipes, you'll need to manage greater complexity and make important judgment calls about how to approach it. You'll also need to write up a bit of an \"investigation report\" documenting what your investigation revealed. The whole course is kicked off by a brief Intro with a couple of super-easy warm-up levels, and ended by an Outro that's really just a final reflection assignment. This set of levels (exercises and miniboss), superbosses, and the intro/outro bits are the only required work in the course. It has no quizzes, exams, attendance requirements, papers, or other such things. \ud83e\udd73 Learn by doing, and prove it by having done. Assignment Grading Let's call a level, superboss, or intro/outro level-type thing an \"assignment\". Every assignment is graded on an entirely all-or-nothing basis: Either it meets all the assignment specifications and is accepted, or it does not and is rejected. (Video game analogy: Either you make it through the level, or you die.) Fortunately, rejected just means \"not accepted yet\". You can fix and resubmit an assignment as often as necessary to meet all the specs and be accepted. (Analogy: If you die, you start the level over.) You will progress much faster, and experience much less frustration, if you can figure out whether your solution meets ALL the specs BEFORE submitting it. (You'll also keep me sane.) To help with that, most assignments come packaged with a battery of automated tests that will check your solution. You can MUST run and pass this before submitting it to me for verification. The test code won't catch absolutely everything, but should catch most errors and oversights. If we both do our jobs well, all I have to do is rubber-stamp your submission; you can already be confident that it will pass. (Analogy: When you screw up in a video game, you discover it immediately and usually dramatically.) Course Grades You begin the course as a Rank 0 computational physicist. Every time you successfully complete an assignment (level or superboss), you level up one rank. Simple, no? Ranks correspond to course grades . The higher your rank at the end of the course, the higher your final grade. The final rank-to-grade table is not yet finalized, since I haven't yet nailed down exactly what all the levels will be, and (more seriously) I am unsure how realistic my plan is. Here's a tentative version: grade: A A\u2013 B+ B B\u2013 C+ C C\u2013 D+ D D\u2013 F rank: 27 25 24 22 21 20 18 17 15 14 13 0 Note that your rank can never decrease (barring some kind of academic integrity or course administration disaster). The implication is that once you've levelled up to a certain grade, that's the lowest grade you can possibly earn no matter what happens for the remainder of the semester . So relax! The only way to shoot yourself in the foot is to proceed too slowly. Due Dates Let me reiterate that: The only way to shoot yourself in the foot is to proceed too slowly. The course is entirely self-paced. The only deadline is the end-of-term one I'm imposing so that I have time to process the last batch of submissions and enter course grades before the University-imposed deadline for grade submission. Only work that meets all assignment specifications and is submitted by the end of the day (midnight) on Wednesday March 07 will count for course credit. Take note: I am giving you a whole lot of rope to hang yourself with. If you fail to set a good pace right from the start of the course, you will be in a whole world of hurt when the end of the semester hurtles towards you. \\[ \\frac{d}{dt}\\left(\\text{successful level completion}\\right) \\approx \\frac{\\text{desired grade}}{\\text{remaining time}} \\] Note that as the remaining time decreases, the rate at which you must pass levels limits to infinity. And remember: Later assignments are harder. Superbosses take longer than minibosses, which take longer than exercises. Your other courses will likely get busier towards the end of the semester, leaving you less time for this one. When you start feeling the panic of the end-of-term approaching, you'll shift from a mindset of \"take the time to figure this stuff out\" to \"frantically try different things hoping to make the damn tests pass\". The latter is generally LESS efficient, and definitely produces less actual learning. It's also just a sucky place to be, psychologically. I will undoubtedly get quite busy with late-semester submissions, leaving me less time to kick back no-pass assignments quickly or help you when you're stuck. You may not have time for multiple submit-correct-resubmit cycles near the end, and if you're rushing, kickbacks become more likely. You have been warned. \ud83e\uddd0 Policies Attendance Policy Given what you've read so far, you might be wondering what the purpose of class meetings is, and whether you need bother attending. Good question! Attending the first class or two will be critical for getting you up and running with our workflow: the various accounts, login identities, and tools you'll need to \"do work\" in this course. After that, class time is really nothing other than a place and time for you to work while I and other students are close at hand to answer questions and help you get unstuck. Don't underestimate the value of instantaneous on-call support. Plus, having at least that 150 minutes per week of distraction-free time committed to the course can be a big help in keeping you on track. I reserve the right to declare any particular class meeting \"mandatory\", with advance warning to you. I would do this if, for example, I've got something important to show or discuss with you that does not lend itself well to written channels, and that should be of value to all the students. Spoiler alert: I intend to do this one day early on to demonstrate some ways of using AI tools to help you learn course skillz faster and better. Missing such a \"mandatory\" class would incur no grade penalty aside from the natural consequences of missing out. The room we've been assigned is inconvenient. We may collectively agree to move class to a more convenient venue in Petty. For any particular class meeting, if nobody shows up for the start of class, I will probably go back to my office after a few minutes. You can still find me there. Either way, I will be \"on call\" for you between 2:00 and 3:15 every Monday and Wednesday afternoon. 1 Late Work Policy You saw the part above about \"no deadlines except for the final end-of-term submission deadlines\", right? Late work is a non-issue in this course. That being said: Do not ask me for an \"incomplete\" simply because you haven't quite finished everything you wanted to by the deadlines. According to the UNCG Catalog, a grade of incomplete \"indicates that the completion of some part of the work for the course has been deferred because of prolonged illness of the student or because of some serious circumstances beyond the student\u2019s control.\" Accommodations UNCG seeks to comply fully with the Americans with Disabilities Act (ADA). Students requesting accommodations based on a disability must be registered with the Office of Accessibility Resources and Services (OARS, 215 Elliott University Center, 336.334.5440, http://oars.uncg.edu ). Academic Integrity Policy You are, of course, expected to know and heed the University\u2019s Academic Integrity Policy . Violations will be reported to the Dean of Students. A second violation at any time during your years as a student here leads to automatic suspension or expulsion, so this is serious stuff. https://osrr.uncg.edu/academic-integrity-policy-pledge/ As stated above, I encourage you to help each other and to work together to figure things out, but any work you submit must be your own and represent your own understanding. Here's the bright red line: Every line of code you submit must be crafted by you.* Not just typed, but crafted . Someone else can suggest a technique, or tell you that you need a third argument to something-or-other function, or point out the location of a syntax error in your code, but they can\u2019t type it for you. They can\u2019t dictate what you should type. They can\u2019t give you a copy of their code to copy-paste or mimic. You can discuss solutions with other students, but you should then write up your code by yourself, starting from an empty screen. If you can\u2019t do that, you don\u2019t really understand it, and it\u2019s dishonest to pretend that you do. If at any time you are in doubt about where to draw the line between collaboration and plagiarism, ask me to clarify. My experience is that the Physics majors who take this course are ethical and conscientious students who genuinely want to learn the topic and not just cheat their way to an undeserved grade. However, even usually-trustworthy students can make bad choices when they get overwhelmed and desperate. Recognize the temptation and ask me for help! Even better, don\u2019t let yourself fall behind to the point that you might be so tempted. And don\u2019t lend your solutions to another student, even to \u201cjust learn from, not copy.\u201d That rarely ends well for anyone. Code is inevitably idiosyncratic. Everyone's looks a little different in myriad ways that are really hard to fake, and I notice uncanny similarities even without looking for them. Don't take the chance. Seriously, don\u2019t jeopardize your reputation. Trust is easy to lose and very, very hard to regain. Artificial Intelligence Policy By the way, you may have noticed the asterisk * on the above \"bright red line\". That's because of AI. Tools like ChatGPT are changing the way coding is done, very dramatically and rapidly, and I'd rather help you learn how to ride that wave than hold you back. So, I'll show you some ways to use AI tools to accelerate rather than bypass your computational physics learning. I'll share the \"what to do\" details as we go. The explosive arrival and improvement of AI tools like ChatGPT over the past couple of years have caused quite a furor within universities. Is it cheating for students to consult an AI tool for help on an assignment, or an improvement in learning efficiency? Does it bypass learning, or does it develop new skills that will be critical in the near-future economy? Well, duh. All of the above, obviously. It depends very much on how the AI is used. In that way it's no different from consulting a classmate or other human for help: They could help you learn, or save you the trouble of learning. One big difference here is that unlike a human, an AI can't make the judgment call about whether what you're asking is ethical, or about the best way to support your learning. So, that's all on you. I'll say a bit more about specific do's and don'ts soon, when I show you some really cool ways to leverage AI. For now, here's the general rule: Ask an AI tool to answer general questions, suggest general approaches, explain specific functions or language features, give you an example of code that uses a particular function or language feature, identify a bug in your code that you can't find, or offer suggestions on a block of your code. Do not have an AI tool produce code to solve your specific course assignment problems, and do not present code written by an AI as part of your own. Here's one other requirement: Any time you use an AI to help you with an assignment, you must say how in your submission. You can do that by including some comment lines in your code, or including a note in a separate markdown/text file you add to the submission file, or whatever makes sense in the context. The most important reason for this is that I want to learn how y'all are using AI, so that I can get better at helping you learn to get better at using it! This is new terrain for all of us. When in doubt, let's talk it out. I haven't figured it all out either. \ud83d\ude35\u200d\ud83d\udcab Congratulations for making it all the way to the end! \ud83c\udfc6 As of the time I'm writing this, I am recovering from a serious health issue that may affect some of the details of my availability during the Spring 2025 semester in ways I don't yet know. I'll keep you posted. \u21a9","title":"Syllabus"},{"location":"admin/syllabus/#physics-351-spring-2025-course-syllabus","text":"Version 1.1, 2025-01-16 Welcome to PHY 351, Introduction to Computational Physics ! Computers have become essential in all aspects of physics. That shouldn't surprise you, because they've become essential in almost all aspects of almost anything; even my toothbrush has a tiny computer in it, and I didn't even get the version that talks to an iPhone app \ud83d\ude26. Let's zoom in on a key function of computers in physics: they can do math for us. In experimental physics , computers can analyze huge quantities of data in extraordinarily sophisticated ways (in addition to controlling the apparatus and collecting the data). In theoretical physics , they can perform calculations and solve equations that would be difficult or even impossible with analytic (\"paper-and-pencil\") methods alone. They've also created a third branch of physics, computational physics , in which we use direct computer simulation of physical systems (rather than physical experiments or analytic modeling) to explore their behavior and develop understanding. Much of the software to do such things is custom-written by physicists, using specialized coding tools and approaches. Skill with these tools and approaches is a scientific superpower that will pay off over and over, whether you stay in physics or take your skills to something else \u2014 like, for example, epidemiology, computational immunology, or financial modeling. The purpose of this course is to show you the foundational tools and methods of computational physics, and to start your journey along the path from beginner \u2192 fluent \u2192 expert.","title":"Physics 351 Spring 2025 Course Syllabus"},{"location":"admin/syllabus/#administrivia","text":"","title":"Administrivia"},{"location":"admin/syllabus/#catalog-information","text":"Credits: 3 (3:3:0 \u21d2 150 min/wk in class + 6-ish hrs/wk outside class for a \u201ctypical\u201d course). Course format: Face-to-face synchronous on-campus, technically (but not really, see below). Prerequisites: Grade of C or better in both PHY 292 and CSC 120, or permission of instructor. Corequisites: PHY 321, or permission of instructor. Corequisite need not be taken concurrently; prior completion is adequate. For whom planned: This course is designed for Physics majors, and is required for the Physics BS and BA degrees. Bulletin description: Introduction to computational methods used in physics and engineering, including computational simulation of physical systems, numerical solution of mathematical problems, and familiarity with scientific programming tools.","title":"Catalog information"},{"location":"admin/syllabus/#instructor-information","text":"Instructor: Associate Prof. Ian D. Beatty (he, him, his) Email: idbeatty@uncg.edu Office: Petty 328 Phone: 336.256.1279 (goes to MS Teams, not my actual phone, so \ud83e\udd37\u200d\u2642\ufe0f) Physics & Astro Slack: @Beatty Twitter : Nope. So done with that. Instead, Bluesky : @ianbeatty.com Office Hours: To be announced \u2014 once I find out what days & times work best for y\u2019all. In the meantime, ask me when you can drop by, or make an appointment. Office hours are in person (Petty 328) or via MS Teams (with prior notice so I can start it up), as you prefer. Connection details are on the course Canvas site.","title":"Instructor information"},{"location":"admin/syllabus/#communication","text":"Slack is generally the fastest way to reach me. (Details are on Canvas .) Email is safer for something that must not fall through the cracks, but you may have to wait a few hours or even until the next day. I try to be responsive during off-hours, especially to things that might prevent you from working productively, but please do not assume you can reliably get my attention during evenings or weekends. I have three kids and an under-maintained house that need my attention too. I will occasionally need to reach you, personally or collectively, about important course changes, reminders, or issues. It is essential that you receive and actually read messages I send to your UNCG email address, either directly or via Canvas course announcements. Please configure your Canvas notification settings, email filters, and personal habits accordingly.","title":"Communication"},{"location":"admin/syllabus/#course-objectives","text":"","title":"Course Objectives"},{"location":"admin/syllabus/#overall-goal","text":"Consider learning a foreign language: Knowing the meaning of a collection of words is marginally useful if you're trying to communicate with someone. Being fluent is orders of magnitude more useful, and lets you communicate things that are orders of magnitude more complex. One part of \"fluency\" is having practiced the translation of words often enough that it becomes automatic in your head, so you don't have to think about it. Another part is knowing a toolkit of idioms and other common language patterns for accomplishing specific communication goals. Knowing an idiom or pattern for a particular idea means I don't have to figure out how to piece words together to communicate it; that problem is already solved. I just reiterate the pattern, tweaking it as appropriate for the situation at hand. This course is organized around the idea that much of the challenge of becoming \"fluent\" with scientific coding is assembling a mental library of common idioms and patterns \u2014 known ways to arrange chunks of code to accomplish specific kinds of tasks. We'll call them recipes . Some are one-liners, some are patterns spread over many lines of code or even an entire program, and some are just sequences of steps to follow. All have the same purpose: Faced with a computational task, knowing a recipe for it means you don't have to stare at the screen and wonder how to start. The \"course content\" is a collection of recipes for you to learn. They are organized on a website, for convenient access. We have no textbook or other reading material, except for miscellaneous online reference materials to supplement the recipes.","title":"Overall Goal"},{"location":"admin/syllabus/#learning-objectives","text":"By learning what the recipes accomplish and how to apply them, you will achieve the course learning outcomes: Be able to use the \"scientific python stack\" to perform interactive calculations, write programs, run programs, and work with data. This \"stack\" includes the core python language; scientific python libraries (specifically numpy , matplotlib , and scipy ); git and GitHub ; and the JupyterLab environment and its tools. Be able to construct and customize publication-quality data plots, with features like error bars and best-fit lines. Understand computer representations of numbers and their implications for accuracy and efficiency. Be able to create animated three-dimensional visual simulations of physical systems. Know and be able to apply some foundational \"numerical methods\" for doing math computationally, including solving nonlinear equations, finding the maxima and minima of functions, calculating derivatives and integrals, and solving ordinary differential equations.","title":"Learning Objectives"},{"location":"admin/syllabus/#philosophy-and-instructional-approach","text":"I started programming in seventh grade when I went to junior high school, met friends who had Apple II computers, and encountered BASIC. It rocked my world, magnitude 9.5. Since then I've written functional, useful code in at least a dozen different programming languages, and dabbled with a dozen more. During that entire time I've taken precisely one programming course, in high school. Almost everything I've learned about coding and computer use has been self-taught. I firmly believe that one learns coding by doing it, not by reading about it or listening to someone explain it. Learning to program, and writing programs, and getting better at it is endless problem-solving , problem after problem after problem. You can embrace the struggle and enjoy the puzzles, or\u2026 \ud83d\ude35 Consequently, this course consists almost entirely of you working your way through a carefully-orchestrated sequence of computational physics challenges. I won't be lecturing or assigning readings. I've tried to give you enough initial orientation to each challenge and enough supporting reference material that you'll have a pretty good idea how to proceed. You will get stuck on things and encounter moments of confusion and, yes, frustration. That's not only normal, it's desirable: because that flash of insight or key bit of information that gets you unstuck and unconfused is where the most important learning happens. However, you are NOT meant to struggle through this alone and intolerably frustrated. One part of my role in the course is to create the structure and scaffolding for you to work through. Another is to be available to help you when, where, and how you need: to answer a question, to suggest a better approach, to inform you of a key language feature you are unaware of, to help you find a bug, to interpret a mysterious error message, and so on. This is way more efficient for both of us, and way more effective for you than, if I tried to pre-warn you of everything you might struggle with and everything you might need to know. You are also welcome to support each other, as-comrades-in-arms, as long as you mind the boundary between \"getting help\" and \"plagiarizing\". For specifics on that boundary, see the Academic Integrity Policy section below. And, I'll be showing you some ways that you can leverage AI tools to help you faster and better; see the Artificial Intelligence Policy section below.","title":"Philosophy and Instructional Approach"},{"location":"admin/syllabus/#textbook-and-technology","text":"","title":"Textbook and Technology"},{"location":"admin/syllabus/#course-textbook","text":"This course has no textbook. Why? I'm glad you asked\u2026 One of the most difficult aspects of learning to code \u2014 for physics, or any other purpose \u2014 is staring at a blank code editor with only a general, fuzzy idea of what you want to accomplish, and no clear idea of what code to write to accomplish it. This is the coder's version of the writer's \"blank page problem\". Ever been there? Yeah, me too. If you've solved similar coding problems before, then you can probably start by recreating what you did and modifying it. But what if you haven't? If you can find an example of someone else's solution to a similar problem, you may be able to copy and modify it\u2026 though depending on the complexity of the problem and the transparency or opaqueness of the example, understanding it well enough to know what to modify (and how), without breaking anything, may be be hair-pullingly infuriating. My solution to this is to offer you a cookbook of \"recipes\" \u2014 starting points that show you how to accomplish various common kinds of coding and computational physics tasks. They are meant to be clear, especially about which bits are essential and which are meant for you to fit to your specific needs. They also include examples, and sometimes variations upon the basic recipe for situations that are similar but differ in some important way. Some recipes are procedural, describing a sequence of steps for you to follow. Some are syntactic, showing specific python code to accomplish a task. Some are structural, recommending approaches to organizing code in pursuit of your goal. Often, recipes include key conceptual and/or informational knowledge about python, numerical methods, and the practice of computational physics. Understanding the ideas and knowing the facts is an essential part of using the recipes correctly, flexibly, and successfully. The collection of recipes is available to you on a website linked to from Canvas.","title":"Course \"Textbook\""},{"location":"admin/syllabus/#technology","text":"Our course Canvas site will serve as (a) a place to put general information such as my contact info, (b) a place for announcements, and (c) a place to keep track of the assignments you've completed. We'll use the GitHub website to distribute assignments to you and for you to submit your completed work bac, to me. (Don't worry, walking you through the setup and process for this is all in World A, Level 1.) You'll do your actual coding-and-running on Beskar , the name I've given to the 48-core, 384-GB beast of a computational physics server that sits on my desk. You'll connect to it from wherever you want via web browser, so you don't need to worry about installing anything on your own computer, or whether your decrepit old laptop can manage. Outside of class, the best way for us to communicate outside of class time is via Slack . Details are on Canvas. You are, of course, welcome to drop in on me during my open-office hours (listed on Canvas), or to make an appointment if that works better. It's really helpful for me to be able to send the occasional short, all-class announcement via Slack, so I really hope we can get everyone on board.","title":"Technology"},{"location":"admin/syllabus/#assignments-grading-and-grades","text":"To understand the structure of this course, don't look to other courses you've taken\u2026 Look to video games! \ud83d\udd79\ufe0f","title":"Assignments, Grading, and Grades"},{"location":"admin/syllabus/#organization","text":"Content material of the course, and the assignments accompanying it, is divided into five Worlds : World A: Core Python World B: Numerical Solving, Finding & Randomness World C: Scientific Python World D: Numerical Calculus World E: Visual Python for Simulation Each world is divided into several (~3-9) Levels . That's too many to list here, so you can find them in the Modules section on Canvas. (Warning: That's a work in progress. Levels for the first worlds will appear soon/already; later ones will appear\u2026 later. We're building this airplane as we fly! \ud83d\ude2c) Just like a videogame level has a sequence of challenges followed by a level boss, a course \"level\" has a sequence of exercises followed by what I'm calling a miniboss . Each exercise targets one particular computational physics recipe . (See below; for now, think of that as one skill or idea.) The miniboss is a somewhat more complex challenge that requires you to combine several of the level's recipes. In addition to its levels, each world ends with a superboss challenge: A considerably more complex, authentic computational physics investigation. In addition to identifying and applying the various recipes, you'll need to manage greater complexity and make important judgment calls about how to approach it. You'll also need to write up a bit of an \"investigation report\" documenting what your investigation revealed. The whole course is kicked off by a brief Intro with a couple of super-easy warm-up levels, and ended by an Outro that's really just a final reflection assignment. This set of levels (exercises and miniboss), superbosses, and the intro/outro bits are the only required work in the course. It has no quizzes, exams, attendance requirements, papers, or other such things. \ud83e\udd73 Learn by doing, and prove it by having done.","title":"Organization"},{"location":"admin/syllabus/#assignment-grading","text":"Let's call a level, superboss, or intro/outro level-type thing an \"assignment\". Every assignment is graded on an entirely all-or-nothing basis: Either it meets all the assignment specifications and is accepted, or it does not and is rejected. (Video game analogy: Either you make it through the level, or you die.) Fortunately, rejected just means \"not accepted yet\". You can fix and resubmit an assignment as often as necessary to meet all the specs and be accepted. (Analogy: If you die, you start the level over.) You will progress much faster, and experience much less frustration, if you can figure out whether your solution meets ALL the specs BEFORE submitting it. (You'll also keep me sane.) To help with that, most assignments come packaged with a battery of automated tests that will check your solution. You can MUST run and pass this before submitting it to me for verification. The test code won't catch absolutely everything, but should catch most errors and oversights. If we both do our jobs well, all I have to do is rubber-stamp your submission; you can already be confident that it will pass. (Analogy: When you screw up in a video game, you discover it immediately and usually dramatically.)","title":"Assignment Grading"},{"location":"admin/syllabus/#course-grades","text":"You begin the course as a Rank 0 computational physicist. Every time you successfully complete an assignment (level or superboss), you level up one rank. Simple, no? Ranks correspond to course grades . The higher your rank at the end of the course, the higher your final grade. The final rank-to-grade table is not yet finalized, since I haven't yet nailed down exactly what all the levels will be, and (more seriously) I am unsure how realistic my plan is. Here's a tentative version: grade: A A\u2013 B+ B B\u2013 C+ C C\u2013 D+ D D\u2013 F rank: 27 25 24 22 21 20 18 17 15 14 13 0 Note that your rank can never decrease (barring some kind of academic integrity or course administration disaster). The implication is that once you've levelled up to a certain grade, that's the lowest grade you can possibly earn no matter what happens for the remainder of the semester . So relax! The only way to shoot yourself in the foot is to proceed too slowly.","title":"Course Grades"},{"location":"admin/syllabus/#due-dates","text":"Let me reiterate that: The only way to shoot yourself in the foot is to proceed too slowly. The course is entirely self-paced. The only deadline is the end-of-term one I'm imposing so that I have time to process the last batch of submissions and enter course grades before the University-imposed deadline for grade submission. Only work that meets all assignment specifications and is submitted by the end of the day (midnight) on Wednesday March 07 will count for course credit. Take note: I am giving you a whole lot of rope to hang yourself with. If you fail to set a good pace right from the start of the course, you will be in a whole world of hurt when the end of the semester hurtles towards you. \\[ \\frac{d}{dt}\\left(\\text{successful level completion}\\right) \\approx \\frac{\\text{desired grade}}{\\text{remaining time}} \\] Note that as the remaining time decreases, the rate at which you must pass levels limits to infinity. And remember: Later assignments are harder. Superbosses take longer than minibosses, which take longer than exercises. Your other courses will likely get busier towards the end of the semester, leaving you less time for this one. When you start feeling the panic of the end-of-term approaching, you'll shift from a mindset of \"take the time to figure this stuff out\" to \"frantically try different things hoping to make the damn tests pass\". The latter is generally LESS efficient, and definitely produces less actual learning. It's also just a sucky place to be, psychologically. I will undoubtedly get quite busy with late-semester submissions, leaving me less time to kick back no-pass assignments quickly or help you when you're stuck. You may not have time for multiple submit-correct-resubmit cycles near the end, and if you're rushing, kickbacks become more likely. You have been warned. \ud83e\uddd0","title":"Due Dates"},{"location":"admin/syllabus/#policies","text":"","title":"Policies"},{"location":"admin/syllabus/#attendance-policy","text":"Given what you've read so far, you might be wondering what the purpose of class meetings is, and whether you need bother attending. Good question! Attending the first class or two will be critical for getting you up and running with our workflow: the various accounts, login identities, and tools you'll need to \"do work\" in this course. After that, class time is really nothing other than a place and time for you to work while I and other students are close at hand to answer questions and help you get unstuck. Don't underestimate the value of instantaneous on-call support. Plus, having at least that 150 minutes per week of distraction-free time committed to the course can be a big help in keeping you on track. I reserve the right to declare any particular class meeting \"mandatory\", with advance warning to you. I would do this if, for example, I've got something important to show or discuss with you that does not lend itself well to written channels, and that should be of value to all the students. Spoiler alert: I intend to do this one day early on to demonstrate some ways of using AI tools to help you learn course skillz faster and better. Missing such a \"mandatory\" class would incur no grade penalty aside from the natural consequences of missing out. The room we've been assigned is inconvenient. We may collectively agree to move class to a more convenient venue in Petty. For any particular class meeting, if nobody shows up for the start of class, I will probably go back to my office after a few minutes. You can still find me there. Either way, I will be \"on call\" for you between 2:00 and 3:15 every Monday and Wednesday afternoon. 1","title":"Attendance Policy"},{"location":"admin/syllabus/#late-work-policy","text":"You saw the part above about \"no deadlines except for the final end-of-term submission deadlines\", right? Late work is a non-issue in this course. That being said: Do not ask me for an \"incomplete\" simply because you haven't quite finished everything you wanted to by the deadlines. According to the UNCG Catalog, a grade of incomplete \"indicates that the completion of some part of the work for the course has been deferred because of prolonged illness of the student or because of some serious circumstances beyond the student\u2019s control.\"","title":"Late Work Policy"},{"location":"admin/syllabus/#accommodations","text":"UNCG seeks to comply fully with the Americans with Disabilities Act (ADA). Students requesting accommodations based on a disability must be registered with the Office of Accessibility Resources and Services (OARS, 215 Elliott University Center, 336.334.5440, http://oars.uncg.edu ).","title":"Accommodations"},{"location":"admin/syllabus/#academic-integrity-policy","text":"You are, of course, expected to know and heed the University\u2019s Academic Integrity Policy . Violations will be reported to the Dean of Students. A second violation at any time during your years as a student here leads to automatic suspension or expulsion, so this is serious stuff. https://osrr.uncg.edu/academic-integrity-policy-pledge/ As stated above, I encourage you to help each other and to work together to figure things out, but any work you submit must be your own and represent your own understanding. Here's the bright red line: Every line of code you submit must be crafted by you.* Not just typed, but crafted . Someone else can suggest a technique, or tell you that you need a third argument to something-or-other function, or point out the location of a syntax error in your code, but they can\u2019t type it for you. They can\u2019t dictate what you should type. They can\u2019t give you a copy of their code to copy-paste or mimic. You can discuss solutions with other students, but you should then write up your code by yourself, starting from an empty screen. If you can\u2019t do that, you don\u2019t really understand it, and it\u2019s dishonest to pretend that you do. If at any time you are in doubt about where to draw the line between collaboration and plagiarism, ask me to clarify. My experience is that the Physics majors who take this course are ethical and conscientious students who genuinely want to learn the topic and not just cheat their way to an undeserved grade. However, even usually-trustworthy students can make bad choices when they get overwhelmed and desperate. Recognize the temptation and ask me for help! Even better, don\u2019t let yourself fall behind to the point that you might be so tempted. And don\u2019t lend your solutions to another student, even to \u201cjust learn from, not copy.\u201d That rarely ends well for anyone. Code is inevitably idiosyncratic. Everyone's looks a little different in myriad ways that are really hard to fake, and I notice uncanny similarities even without looking for them. Don't take the chance. Seriously, don\u2019t jeopardize your reputation. Trust is easy to lose and very, very hard to regain.","title":"Academic Integrity Policy"},{"location":"admin/syllabus/#artificial-intelligence-policy","text":"By the way, you may have noticed the asterisk * on the above \"bright red line\". That's because of AI. Tools like ChatGPT are changing the way coding is done, very dramatically and rapidly, and I'd rather help you learn how to ride that wave than hold you back. So, I'll show you some ways to use AI tools to accelerate rather than bypass your computational physics learning. I'll share the \"what to do\" details as we go. The explosive arrival and improvement of AI tools like ChatGPT over the past couple of years have caused quite a furor within universities. Is it cheating for students to consult an AI tool for help on an assignment, or an improvement in learning efficiency? Does it bypass learning, or does it develop new skills that will be critical in the near-future economy? Well, duh. All of the above, obviously. It depends very much on how the AI is used. In that way it's no different from consulting a classmate or other human for help: They could help you learn, or save you the trouble of learning. One big difference here is that unlike a human, an AI can't make the judgment call about whether what you're asking is ethical, or about the best way to support your learning. So, that's all on you. I'll say a bit more about specific do's and don'ts soon, when I show you some really cool ways to leverage AI. For now, here's the general rule: Ask an AI tool to answer general questions, suggest general approaches, explain specific functions or language features, give you an example of code that uses a particular function or language feature, identify a bug in your code that you can't find, or offer suggestions on a block of your code. Do not have an AI tool produce code to solve your specific course assignment problems, and do not present code written by an AI as part of your own. Here's one other requirement: Any time you use an AI to help you with an assignment, you must say how in your submission. You can do that by including some comment lines in your code, or including a note in a separate markdown/text file you add to the submission file, or whatever makes sense in the context. The most important reason for this is that I want to learn how y'all are using AI, so that I can get better at helping you learn to get better at using it! This is new terrain for all of us. When in doubt, let's talk it out. I haven't figured it all out either. \ud83d\ude35\u200d\ud83d\udcab Congratulations for making it all the way to the end! \ud83c\udfc6 As of the time I'm writing this, I am recovering from a serious health issue that may affect some of the details of my availability during the Spring 2025 semester in ways I don't yet know. I'll keep you posted. \u21a9","title":"Artificial Intelligence Policy"},{"location":"recipes/","text":"Computational Physics Recipes What is a computational physics \"recipe\"? One of the most difficult aspects of learning to code \u2014 for physics, or any other end \u2014 is staring at a blank code editor with only a general, high-level of what you want to accomplish, and no clear idea of what code to write to accomplish it. This is the \"blank page problem.\" Ever been there? Yeah, me too. If you've solved similar problems before, then you can probably start by recreating what you did and modifying it. But what if you haven't? If you can find an example of someone else's solution to a similar problem, you may be able to copy and modify it\u2026 Although depending on the complexity of the problem and the transparency or opaqueness of the example, understanding it well enough to know what to modify (and how), without breaking anything, may be be hair-pullingly infuriating. My solution to this is to offer you a cookbook of \"recipes\" \u2014 starting points that show you how to accomplish various common kinds of coding and computational physics tasks. They are meant to be clear, especially about which bits are essential and which are meant for you to fit to your specific needs. They also include examples, and sometimes variations upon the basic recipe for situations that are similar but differ in some important way. Some recipes are procedural, describing a sequence of steps for you to follow. Some are syntactic, showing specific python code to accomplish a task. Some are structural, recommending approaches to organizing code in pursuit of your goal. Often, recipes include key conceptual and/or informational knowledge about python, numerical methods, and the practice of computational physics. Understanding the ideas and knowing the facts is an essential part of using the recipes correctly, flexibly, and successfully. The recipes in this compendium are organized in the order of the course assignments that accompany them, grouped into \"units\" or \"chapters\" or whatever you want to call them: Recipes by PHY 351 course unit Skillset A: Core Python I use the term core python to mean the standard parts of the python ecosystem: the base python language and the \"standard library\" of modules that is typically installed along with it. For purposes of this course I'm also including the tool stack we'll use to work with python: GitHub and git , JupyterLab and its pieces, and a little of the Unix command-line. Numerical Methods 1: Finding Roots & Extrema Now that we've covered the essentials of python, let's take a break from \"learning to code\" in order to \"learn why to code\" \u2014 that is, how to use those skillz to do some physics-y stuff. Skillset B: Scientific Python Here we introduce recipes focused on aspects of python central to numerically-intensive work. These include a deep understanding of how computers handle numbers, working with arrays and matrices of values, creating plots and other data visualizations, and reading to or writing from data files. Along the way, we'll introduce numpy and matplotlib , add-ons to the python language that support numerically-focused work. Numerical Methods 2: Numerical Calculus Doing math involves more than solving equations; it often requires taking derivatives and integrating. Computers can do that too! The key involves forgetting most of what you learned in calculus courses, and going back to the initial definitions of \"derivative\" and \"integral\"\u2026 and then applying a whole lot of numerical cleverness. Numerical Methods 3: ODE Integration Most of the central principles of physics are expressed as differential equations, and \u2014 consequently \u2014 a great deal of \"doing physics\" comes down to solving differential equations. In the space of all differential equations that we might reasonably encounter in physical problems, only a tiny sliver can be solved analytically. For the rest, we turn to computational methods. In this chunk, we introduce recipes for solving ordinary differential equations (ODEs) numerically. (Partial differential equations \u2014 PDEs \u2014 are such a vast topic that we won't be able to address them in this course. Sorry! ) Skillset C: Visual Python Yeah, \"solving\" a physics problem and getting a bunch of numbers out \u2013 or even a pretty plot \u2014 is nice, but there's no substitute for seeing the behavior of your modeled system evolve in realtime. VPython (\"visual python\") is an add-on toolkit for doing exactly that, and it makes constructing and animating 3D simulations embarrassingly easy.","title":"Intro to Recipes"},{"location":"recipes/#computational-physics-recipes","text":"","title":"Computational Physics Recipes"},{"location":"recipes/#what-is-a-computational-physics-recipe","text":"One of the most difficult aspects of learning to code \u2014 for physics, or any other end \u2014 is staring at a blank code editor with only a general, high-level of what you want to accomplish, and no clear idea of what code to write to accomplish it. This is the \"blank page problem.\" Ever been there? Yeah, me too. If you've solved similar problems before, then you can probably start by recreating what you did and modifying it. But what if you haven't? If you can find an example of someone else's solution to a similar problem, you may be able to copy and modify it\u2026 Although depending on the complexity of the problem and the transparency or opaqueness of the example, understanding it well enough to know what to modify (and how), without breaking anything, may be be hair-pullingly infuriating. My solution to this is to offer you a cookbook of \"recipes\" \u2014 starting points that show you how to accomplish various common kinds of coding and computational physics tasks. They are meant to be clear, especially about which bits are essential and which are meant for you to fit to your specific needs. They also include examples, and sometimes variations upon the basic recipe for situations that are similar but differ in some important way. Some recipes are procedural, describing a sequence of steps for you to follow. Some are syntactic, showing specific python code to accomplish a task. Some are structural, recommending approaches to organizing code in pursuit of your goal. Often, recipes include key conceptual and/or informational knowledge about python, numerical methods, and the practice of computational physics. Understanding the ideas and knowing the facts is an essential part of using the recipes correctly, flexibly, and successfully. The recipes in this compendium are organized in the order of the course assignments that accompany them, grouped into \"units\" or \"chapters\" or whatever you want to call them:","title":"What is a computational physics \"recipe\"?"},{"location":"recipes/#recipes-by-phy-351-course-unit","text":"Skillset A: Core Python I use the term core python to mean the standard parts of the python ecosystem: the base python language and the \"standard library\" of modules that is typically installed along with it. For purposes of this course I'm also including the tool stack we'll use to work with python: GitHub and git , JupyterLab and its pieces, and a little of the Unix command-line. Numerical Methods 1: Finding Roots & Extrema Now that we've covered the essentials of python, let's take a break from \"learning to code\" in order to \"learn why to code\" \u2014 that is, how to use those skillz to do some physics-y stuff. Skillset B: Scientific Python Here we introduce recipes focused on aspects of python central to numerically-intensive work. These include a deep understanding of how computers handle numbers, working with arrays and matrices of values, creating plots and other data visualizations, and reading to or writing from data files. Along the way, we'll introduce numpy and matplotlib , add-ons to the python language that support numerically-focused work. Numerical Methods 2: Numerical Calculus Doing math involves more than solving equations; it often requires taking derivatives and integrating. Computers can do that too! The key involves forgetting most of what you learned in calculus courses, and going back to the initial definitions of \"derivative\" and \"integral\"\u2026 and then applying a whole lot of numerical cleverness. Numerical Methods 3: ODE Integration Most of the central principles of physics are expressed as differential equations, and \u2014 consequently \u2014 a great deal of \"doing physics\" comes down to solving differential equations. In the space of all differential equations that we might reasonably encounter in physical problems, only a tiny sliver can be solved analytically. For the rest, we turn to computational methods. In this chunk, we introduce recipes for solving ordinary differential equations (ODEs) numerically. (Partial differential equations \u2014 PDEs \u2014 are such a vast topic that we won't be able to address them in this course. Sorry! ) Skillset C: Visual Python Yeah, \"solving\" a physics problem and getting a bunch of numbers out \u2013 or even a pretty plot \u2014 is nice, but there's no substitute for seeing the behavior of your modeled system evolve in realtime. VPython (\"visual python\") is an add-on toolkit for doing exactly that, and it makes constructing and animating 3D simulations embarrassingly easy.","title":"Recipes by PHY 351 course unit"},{"location":"recipes/core/","text":"Core Python Recipes I use the term core python to mean the standard parts of the python ecosystem: the base python language and the \"standard library\" of modules that is typically installed along with it. For purposes of this course I'm also including the tool stack we'll use to work with python: GitHub and git , JupyterLab and its pieces, and a little of the Unix command-line. I've divided that up in to the following chunks: Workflow Recipes : Basic procedures for getting stuff done in this course (and hopefully beyond it). Calculation Recipes : Procedures, tools, and tricks to help you do numeric calculations such as you might encounter in physics homework from other courses (or, perhaps some day, in a physics-ish job). Function Recipes : Defining functions takes python from \"oversized calculator\" to \"full-fledged programming language.\" These recipes address various aspects of writing your own functions in the service of doing physics. Iteration Recipes : Humans hate doing the same thing over and over with only tiny variations. Computers excel at it. These recipes illustrate various ways of taking advantage of that. Tuple & List Recipes : The first of two recipe categories on using python's various \"collection\" data types, applying the simpler collections ( tuples and lists ) to problems involving \"ordered sequences of things\". Set & Dictionary Recipes : Sets are an infrequently-used collection type, but are super-convenient for the problems they fit. Dictionaries (\"dicts\") are freaking everywhere in python, and for good reason. This collection of collection recipes will show you why and how.","title":"Overview"},{"location":"recipes/core/#core-python-recipes","text":"I use the term core python to mean the standard parts of the python ecosystem: the base python language and the \"standard library\" of modules that is typically installed along with it. For purposes of this course I'm also including the tool stack we'll use to work with python: GitHub and git , JupyterLab and its pieces, and a little of the Unix command-line. I've divided that up in to the following chunks: Workflow Recipes : Basic procedures for getting stuff done in this course (and hopefully beyond it). Calculation Recipes : Procedures, tools, and tricks to help you do numeric calculations such as you might encounter in physics homework from other courses (or, perhaps some day, in a physics-ish job). Function Recipes : Defining functions takes python from \"oversized calculator\" to \"full-fledged programming language.\" These recipes address various aspects of writing your own functions in the service of doing physics. Iteration Recipes : Humans hate doing the same thing over and over with only tiny variations. Computers excel at it. These recipes illustrate various ways of taking advantage of that. Tuple & List Recipes : The first of two recipe categories on using python's various \"collection\" data types, applying the simpler collections ( tuples and lists ) to problems involving \"ordered sequences of things\". Set & Dictionary Recipes : Sets are an infrequently-used collection type, but are super-convenient for the problems they fit. Dictionaries (\"dicts\") are freaking everywhere in python, and for good reason. This collection of collection recipes will show you why and how.","title":"Core Python Recipes"},{"location":"recipes/core/calculation/","text":"Calculation Recipes Recipes for using python as a (powerful) calculator: Calculate Interactively : I want to do a physics calculation that would be easy to do incorrectly in a calculator, and/or I might need to repeat it with different givens. Use Python Functions : I want to use predefined mathematical (or other) functions, like sine or absolute-value, in my calculation. Use Complex Numbers : I want to do a calculation that involves complex numbers. Print Formatted Output : I want to control the output of my code so that I can include text, specify precision, and so on. Script a Calculation : I want to make a multi-step calculation easier to construct and debug, run multiple times, run again later, and/or have a permanent record of. Ask for User Input : I want to be able to run my script (or let someone else run it) with various given values, without having to edit the script each time.","title":"(Recipe List)"},{"location":"recipes/core/calculation/#calculation-recipes","text":"Recipes for using python as a (powerful) calculator: Calculate Interactively : I want to do a physics calculation that would be easy to do incorrectly in a calculator, and/or I might need to repeat it with different givens. Use Python Functions : I want to use predefined mathematical (or other) functions, like sine or absolute-value, in my calculation. Use Complex Numbers : I want to do a calculation that involves complex numbers. Print Formatted Output : I want to control the output of my code so that I can include text, specify precision, and so on. Script a Calculation : I want to make a multi-step calculation easier to construct and debug, run multiple times, run again later, and/or have a permanent record of. Ask for User Input : I want to be able to run my script (or let someone else run it) with various given values, without having to edit the script each time.","title":"Calculation Recipes"},{"location":"recipes/core/calculation/calc-interactively/","text":"Calculate Interactively Problem to Solve I want to do a physics calculation that would be easy to do incorrectly in a calculator, and/or I might need to repeat it with different givens. Recipe to Solve It This, too, is a \"procedural\" recipe. (I promise that actual code recipes are coming soon!) Let's assume that either you've solved the problem in question via paper-and-pencil, symbolically, and are now ready to plug in given constants, parameters, initial conditions, etc. to calculate one or more numerical results. Pro tip: Solve all but the most trivial physics problems symbolically , deriving a symbolic answer algebraically and simplifying as much as possible before inserting numerical values. If you're given numerical values and not variable names in the problem, define your own symbols! Even the local gravitational constant should be written as \\(g\\) instead of \\(9.81 \\, \\text{m/s}^2\\) or (gasp!) \\(9.8\\) until the very end. Overall, follow the launch, calculate, save recipe . This recipe provides advice on what to execute during the interactive IPython session. Define variables for the constants you'll need, such as g = 9.81 or c = 3.00e8 . Make sure your units are consistent! Putting everything into SI units (MKS) is often safest. Define variables for the other \"given values\" in the problem. Use legitimate python variable names that are as close as possible to the mathematical variable names you'd normally use: m1 for \\(m_1\\) , Vx0 for \\(V_{x}(t = 0)\\) , etc. Again, make sure units are consistent. If you're given something in units that need to be converted, it's often easiest to write the conversion calculation directly into the variable definition. For example, if a problem says the mass of body 1 is 34.5 grams, enter m1 = 34.5 / 1000 to get a numeric value in kilograms. Multiple related values can be defined on one line with the \"comma trick\": m1, m2 = 1.5, 4.0 or Vx0, Vy0, Vz0 = 25, 0, 0 . Construct arithmetic expressions with python's arithmetic operators to calculate intermediate or final values. Know and be careful of operator precedence , or you may get incorrect results. Import needed functions from libraries like math and complex as you discover that you need them. (We'll have more about this in the next recipe, use python functions .) Build up complicated expressions from simpler chunks , saving the values of the chunks in variables. Multiple simple expressions are way simpler to check and debug than one big, hairy one. Maximize readability of arithmetic expressions by including appropriate whitespace around operators and (with a few exceptions) avoiding parentheses that are not required by operator precedence. Execute bare expressions to display the final numerical values you seek. You can also do this for intermediate results, as a way of checking your work as you go. An Example Let's say you've got a typical conservation of angular momentum problem from PHY 291: A thin rod of length \\(L = 50\\text{ cm}\\) and mass \\(M = 600\\text{ g}\\) sits on a horizontal surface, anchored to the surface by a pivot through its center. A puck of mass \\(m = 200\\text{ g}\\) slides across the tabletop with speed \\(v_\\text{i} = 0.8\\text{ m/s}\\) strikes the rod at a distance \\(d = 20\\text{ cm}\\) from the pivot, perpendicular to the rod, and sticks to it. What is the rotational speed of the rod after the collision? Assume all forms of friction are negligible. Applying the principle of conservation of angular momentum and some algebraic manipulations, you derive the following expression for the rod's post-collision rotational speed: \\(\\omega = \\frac{m\\,d\\,v_\\text{i}}{m\\,d + I} = v_\\text{i}\\left(1 + \\frac{I}{m\\,d}\\right)^{-1}\\) where \\(I = \\tfrac{1}{12}\\,M\\,L^2\\) is the rotational inertia of the rod about its center. Now it's time to calculate the numerical value, which means it's time to reach for python. After firing up IPython , your interactive session might look something like the following. (IPython provides the bits that look like In [1]: ; you provide what follows those.) Defining constants and givens: In [1]: m, M = 0.200, 0.600 In [2]: L = 0.50 In [3]: d = 0.20 In [4]: v_i = 0.8 Calculate the rod's rotational inertia. (I could instead substitute the expression in for \\(I\\) in the formula for the angular speed, but the result would be complicated enough to raise the risk of a mistake in the corresponding python expression. So, I'm obeying the recipe's advice to \"Build up complicated expressions from simpler chunks\".) In [5]: I = M * L**2 / 12 Calculate the final rotational speed: In [6]: v_i / (1 + I / (m * d)) Out[6]: 0.6095238095238096 (It's up to you to know that based on the units of your variables, the answer is in radians per second.) Let's say that the problem included a part (b) that asks for the final rotational speed if the puck had instead hit and stuck to the very end of the rod. That's easy to calculate without very much repeated work. First, change the value of the relevant variable: In [7]: d = 0.25 Rather than retype the final formula, we can just press the keyboards up-arrow key three times to \"walk back\" through the session's command history, until the formula we want is displayed, and then press Enter to execute it again (with the current values of all variables): In [8]: v_i / (1 + I / (m * d)) Out[8]: 0.64 Out of curiosity, what was the numerical value of the rotational inertia? In [9]: I Out[9]: 0.012499999999999999 (Again, it's up to you to know that based on the units of your variables, the answer is in kilogram-meters-squared. And you should definitely report your answer as \\(0.0125\\text{ kg m}^2\\) , since those repeating-nines are certainly the result of machine round-off error, which we'll talk about in a later section of the course.) Okay, we're done. Most of the time you'd just quit it with exit , but let's illustrate how to save the session history in case you want to refer back to it later. (For example, if you submit your answer and the numerical value gets marked wrong, you might want to compare what you did to the solutions to figure out whether you mis-entered something.) In [10]: %save p291-hw07-p3 The following commands were written to file `p291-hw07-p3.py`: m, M = 0.200, 0.600 L = 0.50 d = 0.20 v_i = 0.8 I = M * L**2 / 12 v_i / (1 + I / (m * d)) d = 0.25 v_i / (1 + I / (m * d)) I In [11]: exit The lines of that output file could be copy-pasted into a new IPython session to recreate the calculations (possibly with some edits as you go, if you wish). Or, you could run the entire file as a python script .","title":"Calculate Interactively"},{"location":"recipes/core/calculation/calc-interactively/#calculate-interactively","text":"","title":"Calculate Interactively"},{"location":"recipes/core/calculation/calc-interactively/#problem-to-solve","text":"I want to do a physics calculation that would be easy to do incorrectly in a calculator, and/or I might need to repeat it with different givens.","title":"Problem to Solve"},{"location":"recipes/core/calculation/calc-interactively/#recipe-to-solve-it","text":"This, too, is a \"procedural\" recipe. (I promise that actual code recipes are coming soon!) Let's assume that either you've solved the problem in question via paper-and-pencil, symbolically, and are now ready to plug in given constants, parameters, initial conditions, etc. to calculate one or more numerical results. Pro tip: Solve all but the most trivial physics problems symbolically , deriving a symbolic answer algebraically and simplifying as much as possible before inserting numerical values. If you're given numerical values and not variable names in the problem, define your own symbols! Even the local gravitational constant should be written as \\(g\\) instead of \\(9.81 \\, \\text{m/s}^2\\) or (gasp!) \\(9.8\\) until the very end. Overall, follow the launch, calculate, save recipe . This recipe provides advice on what to execute during the interactive IPython session. Define variables for the constants you'll need, such as g = 9.81 or c = 3.00e8 . Make sure your units are consistent! Putting everything into SI units (MKS) is often safest. Define variables for the other \"given values\" in the problem. Use legitimate python variable names that are as close as possible to the mathematical variable names you'd normally use: m1 for \\(m_1\\) , Vx0 for \\(V_{x}(t = 0)\\) , etc. Again, make sure units are consistent. If you're given something in units that need to be converted, it's often easiest to write the conversion calculation directly into the variable definition. For example, if a problem says the mass of body 1 is 34.5 grams, enter m1 = 34.5 / 1000 to get a numeric value in kilograms. Multiple related values can be defined on one line with the \"comma trick\": m1, m2 = 1.5, 4.0 or Vx0, Vy0, Vz0 = 25, 0, 0 . Construct arithmetic expressions with python's arithmetic operators to calculate intermediate or final values. Know and be careful of operator precedence , or you may get incorrect results. Import needed functions from libraries like math and complex as you discover that you need them. (We'll have more about this in the next recipe, use python functions .) Build up complicated expressions from simpler chunks , saving the values of the chunks in variables. Multiple simple expressions are way simpler to check and debug than one big, hairy one. Maximize readability of arithmetic expressions by including appropriate whitespace around operators and (with a few exceptions) avoiding parentheses that are not required by operator precedence. Execute bare expressions to display the final numerical values you seek. You can also do this for intermediate results, as a way of checking your work as you go.","title":"Recipe to Solve It"},{"location":"recipes/core/calculation/calc-interactively/#an-example","text":"Let's say you've got a typical conservation of angular momentum problem from PHY 291: A thin rod of length \\(L = 50\\text{ cm}\\) and mass \\(M = 600\\text{ g}\\) sits on a horizontal surface, anchored to the surface by a pivot through its center. A puck of mass \\(m = 200\\text{ g}\\) slides across the tabletop with speed \\(v_\\text{i} = 0.8\\text{ m/s}\\) strikes the rod at a distance \\(d = 20\\text{ cm}\\) from the pivot, perpendicular to the rod, and sticks to it. What is the rotational speed of the rod after the collision? Assume all forms of friction are negligible. Applying the principle of conservation of angular momentum and some algebraic manipulations, you derive the following expression for the rod's post-collision rotational speed: \\(\\omega = \\frac{m\\,d\\,v_\\text{i}}{m\\,d + I} = v_\\text{i}\\left(1 + \\frac{I}{m\\,d}\\right)^{-1}\\) where \\(I = \\tfrac{1}{12}\\,M\\,L^2\\) is the rotational inertia of the rod about its center. Now it's time to calculate the numerical value, which means it's time to reach for python. After firing up IPython , your interactive session might look something like the following. (IPython provides the bits that look like In [1]: ; you provide what follows those.) Defining constants and givens: In [1]: m, M = 0.200, 0.600 In [2]: L = 0.50 In [3]: d = 0.20 In [4]: v_i = 0.8 Calculate the rod's rotational inertia. (I could instead substitute the expression in for \\(I\\) in the formula for the angular speed, but the result would be complicated enough to raise the risk of a mistake in the corresponding python expression. So, I'm obeying the recipe's advice to \"Build up complicated expressions from simpler chunks\".) In [5]: I = M * L**2 / 12 Calculate the final rotational speed: In [6]: v_i / (1 + I / (m * d)) Out[6]: 0.6095238095238096 (It's up to you to know that based on the units of your variables, the answer is in radians per second.) Let's say that the problem included a part (b) that asks for the final rotational speed if the puck had instead hit and stuck to the very end of the rod. That's easy to calculate without very much repeated work. First, change the value of the relevant variable: In [7]: d = 0.25 Rather than retype the final formula, we can just press the keyboards up-arrow key three times to \"walk back\" through the session's command history, until the formula we want is displayed, and then press Enter to execute it again (with the current values of all variables): In [8]: v_i / (1 + I / (m * d)) Out[8]: 0.64 Out of curiosity, what was the numerical value of the rotational inertia? In [9]: I Out[9]: 0.012499999999999999 (Again, it's up to you to know that based on the units of your variables, the answer is in kilogram-meters-squared. And you should definitely report your answer as \\(0.0125\\text{ kg m}^2\\) , since those repeating-nines are certainly the result of machine round-off error, which we'll talk about in a later section of the course.) Okay, we're done. Most of the time you'd just quit it with exit , but let's illustrate how to save the session history in case you want to refer back to it later. (For example, if you submit your answer and the numerical value gets marked wrong, you might want to compare what you did to the solutions to figure out whether you mis-entered something.) In [10]: %save p291-hw07-p3 The following commands were written to file `p291-hw07-p3.py`: m, M = 0.200, 0.600 L = 0.50 d = 0.20 v_i = 0.8 I = M * L**2 / 12 v_i / (1 + I / (m * d)) d = 0.25 v_i / (1 + I / (m * d)) I In [11]: exit The lines of that output file could be copy-pasted into a new IPython session to recreate the calculations (possibly with some edits as you go, if you wish). Or, you could run the entire file as a python script .","title":"An Example"},{"location":"recipes/core/calculation/complex-numbers/","text":"Use Complex Numbers Problem to Solve I want to do a calculation that involves complex numbers. Introduction Rejoice \u2014 python has built-in support for complex numbers, right alongside integers and real (floating-point) numbers! The only real catch is that the functions in the math module don't work with complex numbers. That's not an issue, since the cmath module has all the same functions, but written to handle both real and complex numbers equally well. Recipe A: Assembling and Disassembling Complex Numbers If you have actual numbers (not variables) for the real and imaginary parts, you can specify a complex number with what's called a literal : >>> c1 = 3 + 2j # positive real and imaginary parts >>> c2 = -3 - 2j # negative real and imaginary parts >>> c3 = 2j # imaginary part only, real part is zero >>> c4 = 3 + 0j # a complex number with zero imaginary part Note that a \"complex number with zero imaginary part\" is still recognized as a complex number by python, even though it's mathematically equivalent to a real number. Also note that you can get \\(\\sqrt{-1}\\) (which we commonly call \"i\" in physics) by using 1j . Python follows the engineering convention of using j to represent the imaginary unit, rather than the mathematician's i . This is because i is often used as a loop index in python code, and j is less likely to be confused with a variable name. If you have real and imaginary parts stored in separate variables, you can construct a complex number from them with the complex() constructor function . Let's assume that the variables a and b already hold numeric values from prior calculations. We can make them the parts of a complex number via: >>> c = complex(a, b) >>> c (3-4j) If you're doing a calculation and you need something like \\(i\\phi\\) where \\(\\phi\\) is a variable represented by phi in your code, you can put that into a python formula as either complex(0, phi) or 1j * phi . I personally prefer the latter, as it's closest to the original math notation. You can extract the real and imaginary part of a complex number thusly: >>> z = 3.5 - 4.2j >>> z.real 3.5 >>> z.imag -4.2 This works for complex expressions, not just variables: >>> (3.5 - 4.2j).real 3.5 >>> (z**2 - 2*z + 1).imag -21.0 It should be obvious to you that: >>> complex(z.real, z.imag) == z True Recipe B: Doing Math with Complex Numbers Python's standard arithmetic operators ( + , - , * , / , ** ) work properly with complex numbers. Nothing special is needed. (Note that the // and % operators for integer division and remainder don't, because those operations are not mathematically defined for complex numbers. Don't blame python.) Python's built-in numeric functions abs() , pow() , and sum() work properly with complex numbers. Others don't, because they're not mathematically well-defined. The functions in the math module do NOT work with complex numbers! However, if you simply use cmath instead of math , you'll get all the same functions, but written to handle both real and complex numbers equally well. Recipe C: Working with Complex Numbers in Polar Form In addition to the rectangular or Cartesian representation of a complex number \\(z = a + b\\,i\\) , in physics we often use the polar representation \\(z = r\\,e^{i\\theta}\\) , where \\(r\\) is called the magnitude of \\(z\\) and \\(\\theta\\) the phase . If we know \\(a\\) and \\(b\\) , we can calculate \\(r\\) and \\(\\theta\\) , or vice-versa. Of course, python can do that for us. In addition to complex-aware copies of the functions in the math module, cmath has a few special-purpose functions for working with complex numbers: abs(z) returns the magnitude \\(r\\) . (Yes, this is the usual built-in abs() function. It's smart enough to know that the \"absolute value\" of a complex number is its magnitude.) cmath.phase(z) returns the phase \\(\\theta\\) , in radians. cmath.polar(z) returns both the magnitude and phase as a two-element tuple (r, theta) . cmath.rect(r, theta) creates a complex number habving magnitude \\(r\\) and phase \\(\\theta\\) . So, if you want to know the imaginary part of a complex number that has magnitude 1 and phase \\(\\pi/4\\) , you can do this: >>> import cmath as cm >>> z = cm.rect(1, cm.pi/4) >>> z.imag Or, more compactly, just cmath.rect(1, cmath.pi/4).imag . (The cmath module defines the same constants as math , such as pi and e , so you don't have to import two different packages. They're still real numbers.) Recipe D: Complex Conjugation One additional operation you might need to do with a complex number (say, \\(z\\) ) is to take its complex conjugate (denoted \\(z^*\\) ). Mathematically, this is defined as flipping the sign ( \\(+ \\leftrightarrow -\\) ) of the imaginary part, or replacing \\(i\\) with \\(-i\\) in the polar form, (or in any form composed of real numbers and explicit \\(i\\) s). Here's a possible, but bad , way to do that in python: >>> z_star = complex(z.real, -z.imag) # Don't do this! Instead, use the conjugate() function from the cmath module: >>> import cmath as cm # If not done already imported, of course. >>> z_star = cm.conjugate(z) That's cleaner and easier for a human to interpret. It's also less error-prone, and slightly faster. However, a warning: Let python do the work for you! You may be so used to doing complex arithmetic \"by hand\" that you try to do that in your code, too. For example, here are three different, mathematically equivalent ways to find the magnitude of a complex number z : >>> z_mag_1 = cm.sqrt(z.real**2 + z.imag**2) # Don't do this. >>> z_mag_2 = cm.sqrt(z.conjugate() * z) # Don't do this either. >>> z_mag_3 = abs(z) # Yes, do this! If you think of the core python abs() function as meaning \"give me the magnitude of this thing\", it becomes a natural extension of absolute value, and results in cleaner, less error-prone, and (slightly) faster code. An Example Let's say that we have a simple series circuit (one loop) with an AC voltage source, a resistor, an inductor, and a capacitor all in series, and we want to know the current flowing through the circuit as a function of time. In a course like PHY 412, you'd learn that it's trivial to analyze such a circuit using the method of complex impedances , and you could derive the following expression for the current in the circuit as a function of time: \\[ I(t) = \\text{Re}\\left(\\frac{V_0\\,e^{i\\omega t}}{R + i \\left( \\omega L - \\frac{1}{\\omega C} \\right)}\\,\\right) \\] where \\(\\text{Re}(\u2026)\\) means \"take the real part of\". For specific numerical values, let's say: The driving voltage is \\(V(t) = V_0\\ \\cos(\\omega t)\\) with \\(V_0 = 10\\text{ V}\\) and \\(f = 100\\text{ Hz}\\) (Remember that the angular frequency \\(\\omega = 2\\pi f\\) ). The resistance, inductance, and capacitance of the resistor, inductor, and capacitor are \\(R = 100\\ \\Omega\\) , \\(L = 200\\text{ mH}\\) , and \\(C = 10\\ \\mu\\text{F}\\) respectively. We want to know the current at times of \\(t = 0, 1, 2, 3, 4, 5, \\text{and } 10\\text{ ms}\\) . Calculating these is easy with python! In [1]: Vo, f = 10, 100 In [2]: R, L, C = 100, 100e-3, 10e-6 In [3]: from cmath import pi, exp In [4]: w = 2 * pi * f In [5]: Z = R + 1j * (w * L - 1 / (w * C)) In [6]: Z Out[6]: (100-96.32309002009944j) In [7]: t = 0 In [8]: (Vo * exp(1j * w * t) / Z).real Out[8]: 0.05187223045425429 In [9]: t = 1e-3 In [10]: (Vo * exp(1j * w * t) / Z).real Out[10]: 0.012596863910223792 In [11]: t = 2e-3 In [12]: (Vo * exp(1j * w * t) / Z).real Out[12]: -0.031490076495855286 In [13]: t = 3e-3 In [14]: (Vo * exp(1j * w * t) / Z).real Out[14]: -0.06354887798885185 In [15]: t = 4e-3 In [16]: (Vo * exp(1j * w * t) / Z).real Out[16]: -0.07133416803702705 In [17]: t = 5e-3 In [18]: (Vo * exp(1j * w * t) / Z).real Out[18]: -0.051872230454254306 In [19]: t = 10e-3 In [20]: (Vo * exp(1j * w * t) / Z).real Out[20]: 0.051872230454254306 A few comments: In entry 5, I'm calculating the denominator of the expression and stashing it in a temporary variable Z . This keeps the overall expression for the current from getting too ugly and error-prone. Since the denominator does not depend upon the time t , I don't have to recalculate it every time I change the value of t . Starting with entry 9, I'm just repeating a cycle of: up-arrowing twice to bring up the prior definition of t ; left-arrowing to put the cursor left of the = e , hitting delete, and typing the new time value; hitting Enter (or shift-Enter) to set the new time value; up-arrowing twice to bring up the prior expression for the current; and hitting Enter or (shift-Enter) to reevaluate it. This is a very efficient way to repeat a calculation for different values of some variable. (Yes, its even easier to use a loop, which we'll get to in an upcoming recipe. And this is a natural situation in which to define a custom function for the current, which we'll also get to soon enough.) Instead of Vo * exp(1j * w * t) it would have been entirely equivalent to use rect(Vo, w * t) after importing rect from cmath . That's probably simpler and easier to read, if you're fluent with the polar form of complex numbers.","title":"Use Complex Numbers"},{"location":"recipes/core/calculation/complex-numbers/#use-complex-numbers","text":"","title":"Use Complex Numbers"},{"location":"recipes/core/calculation/complex-numbers/#problem-to-solve","text":"I want to do a calculation that involves complex numbers.","title":"Problem to Solve"},{"location":"recipes/core/calculation/complex-numbers/#introduction","text":"Rejoice \u2014 python has built-in support for complex numbers, right alongside integers and real (floating-point) numbers! The only real catch is that the functions in the math module don't work with complex numbers. That's not an issue, since the cmath module has all the same functions, but written to handle both real and complex numbers equally well.","title":"Introduction"},{"location":"recipes/core/calculation/complex-numbers/#recipe-a-assembling-and-disassembling-complex-numbers","text":"If you have actual numbers (not variables) for the real and imaginary parts, you can specify a complex number with what's called a literal : >>> c1 = 3 + 2j # positive real and imaginary parts >>> c2 = -3 - 2j # negative real and imaginary parts >>> c3 = 2j # imaginary part only, real part is zero >>> c4 = 3 + 0j # a complex number with zero imaginary part Note that a \"complex number with zero imaginary part\" is still recognized as a complex number by python, even though it's mathematically equivalent to a real number. Also note that you can get \\(\\sqrt{-1}\\) (which we commonly call \"i\" in physics) by using 1j . Python follows the engineering convention of using j to represent the imaginary unit, rather than the mathematician's i . This is because i is often used as a loop index in python code, and j is less likely to be confused with a variable name. If you have real and imaginary parts stored in separate variables, you can construct a complex number from them with the complex() constructor function . Let's assume that the variables a and b already hold numeric values from prior calculations. We can make them the parts of a complex number via: >>> c = complex(a, b) >>> c (3-4j) If you're doing a calculation and you need something like \\(i\\phi\\) where \\(\\phi\\) is a variable represented by phi in your code, you can put that into a python formula as either complex(0, phi) or 1j * phi . I personally prefer the latter, as it's closest to the original math notation. You can extract the real and imaginary part of a complex number thusly: >>> z = 3.5 - 4.2j >>> z.real 3.5 >>> z.imag -4.2 This works for complex expressions, not just variables: >>> (3.5 - 4.2j).real 3.5 >>> (z**2 - 2*z + 1).imag -21.0 It should be obvious to you that: >>> complex(z.real, z.imag) == z True","title":"Recipe A: Assembling and Disassembling Complex Numbers"},{"location":"recipes/core/calculation/complex-numbers/#recipe-b-doing-math-with-complex-numbers","text":"Python's standard arithmetic operators ( + , - , * , / , ** ) work properly with complex numbers. Nothing special is needed. (Note that the // and % operators for integer division and remainder don't, because those operations are not mathematically defined for complex numbers. Don't blame python.) Python's built-in numeric functions abs() , pow() , and sum() work properly with complex numbers. Others don't, because they're not mathematically well-defined. The functions in the math module do NOT work with complex numbers! However, if you simply use cmath instead of math , you'll get all the same functions, but written to handle both real and complex numbers equally well.","title":"Recipe B: Doing Math with Complex Numbers"},{"location":"recipes/core/calculation/complex-numbers/#recipe-c-working-with-complex-numbers-in-polar-form","text":"In addition to the rectangular or Cartesian representation of a complex number \\(z = a + b\\,i\\) , in physics we often use the polar representation \\(z = r\\,e^{i\\theta}\\) , where \\(r\\) is called the magnitude of \\(z\\) and \\(\\theta\\) the phase . If we know \\(a\\) and \\(b\\) , we can calculate \\(r\\) and \\(\\theta\\) , or vice-versa. Of course, python can do that for us. In addition to complex-aware copies of the functions in the math module, cmath has a few special-purpose functions for working with complex numbers: abs(z) returns the magnitude \\(r\\) . (Yes, this is the usual built-in abs() function. It's smart enough to know that the \"absolute value\" of a complex number is its magnitude.) cmath.phase(z) returns the phase \\(\\theta\\) , in radians. cmath.polar(z) returns both the magnitude and phase as a two-element tuple (r, theta) . cmath.rect(r, theta) creates a complex number habving magnitude \\(r\\) and phase \\(\\theta\\) . So, if you want to know the imaginary part of a complex number that has magnitude 1 and phase \\(\\pi/4\\) , you can do this: >>> import cmath as cm >>> z = cm.rect(1, cm.pi/4) >>> z.imag Or, more compactly, just cmath.rect(1, cmath.pi/4).imag . (The cmath module defines the same constants as math , such as pi and e , so you don't have to import two different packages. They're still real numbers.)","title":"Recipe C: Working with Complex Numbers in Polar Form"},{"location":"recipes/core/calculation/complex-numbers/#recipe-d-complex-conjugation","text":"One additional operation you might need to do with a complex number (say, \\(z\\) ) is to take its complex conjugate (denoted \\(z^*\\) ). Mathematically, this is defined as flipping the sign ( \\(+ \\leftrightarrow -\\) ) of the imaginary part, or replacing \\(i\\) with \\(-i\\) in the polar form, (or in any form composed of real numbers and explicit \\(i\\) s). Here's a possible, but bad , way to do that in python: >>> z_star = complex(z.real, -z.imag) # Don't do this! Instead, use the conjugate() function from the cmath module: >>> import cmath as cm # If not done already imported, of course. >>> z_star = cm.conjugate(z) That's cleaner and easier for a human to interpret. It's also less error-prone, and slightly faster. However, a warning: Let python do the work for you! You may be so used to doing complex arithmetic \"by hand\" that you try to do that in your code, too. For example, here are three different, mathematically equivalent ways to find the magnitude of a complex number z : >>> z_mag_1 = cm.sqrt(z.real**2 + z.imag**2) # Don't do this. >>> z_mag_2 = cm.sqrt(z.conjugate() * z) # Don't do this either. >>> z_mag_3 = abs(z) # Yes, do this! If you think of the core python abs() function as meaning \"give me the magnitude of this thing\", it becomes a natural extension of absolute value, and results in cleaner, less error-prone, and (slightly) faster code.","title":"Recipe D: Complex Conjugation"},{"location":"recipes/core/calculation/complex-numbers/#an-example","text":"Let's say that we have a simple series circuit (one loop) with an AC voltage source, a resistor, an inductor, and a capacitor all in series, and we want to know the current flowing through the circuit as a function of time. In a course like PHY 412, you'd learn that it's trivial to analyze such a circuit using the method of complex impedances , and you could derive the following expression for the current in the circuit as a function of time: \\[ I(t) = \\text{Re}\\left(\\frac{V_0\\,e^{i\\omega t}}{R + i \\left( \\omega L - \\frac{1}{\\omega C} \\right)}\\,\\right) \\] where \\(\\text{Re}(\u2026)\\) means \"take the real part of\". For specific numerical values, let's say: The driving voltage is \\(V(t) = V_0\\ \\cos(\\omega t)\\) with \\(V_0 = 10\\text{ V}\\) and \\(f = 100\\text{ Hz}\\) (Remember that the angular frequency \\(\\omega = 2\\pi f\\) ). The resistance, inductance, and capacitance of the resistor, inductor, and capacitor are \\(R = 100\\ \\Omega\\) , \\(L = 200\\text{ mH}\\) , and \\(C = 10\\ \\mu\\text{F}\\) respectively. We want to know the current at times of \\(t = 0, 1, 2, 3, 4, 5, \\text{and } 10\\text{ ms}\\) . Calculating these is easy with python! In [1]: Vo, f = 10, 100 In [2]: R, L, C = 100, 100e-3, 10e-6 In [3]: from cmath import pi, exp In [4]: w = 2 * pi * f In [5]: Z = R + 1j * (w * L - 1 / (w * C)) In [6]: Z Out[6]: (100-96.32309002009944j) In [7]: t = 0 In [8]: (Vo * exp(1j * w * t) / Z).real Out[8]: 0.05187223045425429 In [9]: t = 1e-3 In [10]: (Vo * exp(1j * w * t) / Z).real Out[10]: 0.012596863910223792 In [11]: t = 2e-3 In [12]: (Vo * exp(1j * w * t) / Z).real Out[12]: -0.031490076495855286 In [13]: t = 3e-3 In [14]: (Vo * exp(1j * w * t) / Z).real Out[14]: -0.06354887798885185 In [15]: t = 4e-3 In [16]: (Vo * exp(1j * w * t) / Z).real Out[16]: -0.07133416803702705 In [17]: t = 5e-3 In [18]: (Vo * exp(1j * w * t) / Z).real Out[18]: -0.051872230454254306 In [19]: t = 10e-3 In [20]: (Vo * exp(1j * w * t) / Z).real Out[20]: 0.051872230454254306 A few comments: In entry 5, I'm calculating the denominator of the expression and stashing it in a temporary variable Z . This keeps the overall expression for the current from getting too ugly and error-prone. Since the denominator does not depend upon the time t , I don't have to recalculate it every time I change the value of t . Starting with entry 9, I'm just repeating a cycle of: up-arrowing twice to bring up the prior definition of t ; left-arrowing to put the cursor left of the = e , hitting delete, and typing the new time value; hitting Enter (or shift-Enter) to set the new time value; up-arrowing twice to bring up the prior expression for the current; and hitting Enter or (shift-Enter) to reevaluate it. This is a very efficient way to repeat a calculation for different values of some variable. (Yes, its even easier to use a loop, which we'll get to in an upcoming recipe. And this is a natural situation in which to define a custom function for the current, which we'll also get to soon enough.) Instead of Vo * exp(1j * w * t) it would have been entirely equivalent to use rect(Vo, w * t) after importing rect from cmath . That's probably simpler and easier to read, if you're fluent with the polar form of complex numbers.","title":"An Example"},{"location":"recipes/core/calculation/print/","text":"Print Formatted Output Problem to Solve I want to control the output of my code so that I can include text, specify precision, and so on. Introduction A bare python expression produces a result when evaluated. That result is of some particular type: an integer, a floating-point or complex number, a text string, or perhaps something else. The IPython console or other interactive python session will display that result according to some default rule it has for that type. The result will probably provide sufficient information, but may be ugly or otherwise not quite as human-friendly as you'd like. (This is especially important when writing scripts , which we'll get to in the next recipe, Write a Calculation Script .) To control the details of python code output, use the built-in print() function. Using it can be drop-dead simple, or mysteriously arcane and complex, depending on what your goals are. We'll build the complexity up gradually in this recipe. A bit of terminology and conceptual background\u2026 Statements are chunks of python code that make changes to the python environment when they are executed, like importing a module or functions from it, or defining a variable and setting its value. Programmers call these \"side effects\". You can think of them as declarative sentences: \"Do this.\" Statements generally stand alone on a line (or a multi-line block), and don't \"return\" a value. Expressions are chunks of python code that are evaluated and coverted into some kind of value or object when they are executed. They don't do anything other than produce this value. Often, they are part of a statement, such as the right-hand side of x = 5.0 * sin(radians(15)) . Expressions can be made up of other expressions: 15 is an expresion, as are radians(15) and sin(radians(15)) . In IPython, when a \"bare expression\" \u2014 a line of python code that is an expression and not a statement \u2014 is sent to the python interpreter, the interpreter returns its value, and IPython displays that value as an \"output\" line. When working in IPython, the difference between values displayed as the result of expression evaluation and values displayed by print() is easy to overlook. The difference is important, however, and will be much more obvious when we move beyond IPython and start writing script files. For now, the key fact to stick into your memory is that print(...) is a statement that returns no result, but has the \"side effect\" of displaying text to the user. An expression simply returns a value, which might get used as part of a larger expression or statement, might be displayed to the user, or might be totally ignored depending on the context. One benefit of using print() statements to see your calculation results is that you get a whole lot of control over how values are displayed. You can embed numbers in text, control decimal digits or significant figures, force or prevent the use of scientific notation, control widths, etc. Recipe A: Just Print one Value If all you want to do is get a value to display, and you're fine with python's default choices, just pass it to print() as an argument: from math import sin theta = 0.01 sin_theta = sin(theta) print(sin_theta) produces 0.009999833334166664 Recipe B: Print Multiple Values If you pass multiple comma-separated arguments to print() , it will print them all, separated by spaces. (Note that any python expression can be an argument to print() , not just a variable name.) print(theta, sin_theta, theta - sin_theta) produces 0.01 0.009999833334166664 1.6666583333574403e-07 (Note how python automatically switches to scientific notation when the number is very small.) You can change the separation character from a space to something else (say, a comma) by specifying the sep keyword argument: print(theta, sin_theta, theta - sin_theta, sep=', ') produces 0.01, 0.009999833334166664, 1.6666583333574403e-07 You can even squish the values together with no separation at all by specifying an empty string as the separator: print(\"Twelve\", 12.0, 12, sep='') produces Twelve12.012 (This use case makes no sense, but situations do arise where it's helpful.) Recipe C: Inserting Values Into Text Python has a special kind of string called an \"f-string\" (for \"formatted string\") that allows you to insert values into specific locations in a string. To use this, prepend a f before the opening quote, and put curly braces {\u2026} around the value(s) to be inserted: print(f\"Theta is {theta}, its sine is {sin_theta}, and their difference is {theta - sin_theta}.\") produces Theta is 0.01, its sine is 0.009999833334166664, and their difference is 1.6666583333574403e-07. Recipe D: Controlling Number Format Look at that last output line. Notice that python displayed the first two numbers in traditional decimal notation, but chose to display the third number in scientific notation. By default, it displays very large and very small floating-point numbers in scientific notation, and uses decimal notation in between. You can force python to use a particular format by including a format specifier like this: print(f\"Theta is {theta:e}, its sine is {sin_theta:e}, and their difference is {theta - sin_theta:f}.\") This produces Theta is 1.000000e-02, its sine is 9.999833e-03, and their difference is 0.000000. If you include :f (for \"floating-point\") inside the curly-braces and after the variable or expression, python will display the number in decimal notation regardless of its size. If you include :e (for \"exponential\") instead, python will display the number in scientific notation. ( e means \"exponential\".) Or, if you use :g (for \"general\"), python will choose between the two formats based on the number's size. Although :g is very similar to using no specifier at all, the results can be slightly different: diff = theta - sin_theta print(f\"The difference can be shown as {diff}, {diff:f}, {diff:e},or {diff:g}.\") produces The difference can be shown as 1.6666583333574403e-07, 0.000000, 1.666658e-07,or 1.66666e-07. Examine carefully, especially the number of digits shownf Recipe E: Controlling Precision Format specifiers also let you control the number of digits displayed in the number. When using the f or e specifiers, you can specify the number of digits past the decimal point to show. (With the f specifier, the number of digits before the decimal point is whatever it is. With the e specifier, the exponent is chosen so that there's always one digit before the decimal point.) When using g , on the other hand, you can specify the number of significant figures (not decimal digits) to show for whichever format python chooses (floating-point or exponential). Warning : the way that python counts significant figures for floating-point numbers is not always the way physicists count them, so beware! (I've) x = 0.123456789 y = x * 1e-6 z = 0.01 print(f\"x is {x:.4f}, {x:.4e}, and {x:.4g}.\") print(f\"y is {y:.4f}, {y:.4e}, and {y:.4g}.\") print(f\"z is {z:.4f}, {z:.4e}, and {z:.4g}.\") # See what `.4g` does here! produces x is 0.1235, 1.2346e-01, and 0.1235. y is 0.0000, 1.2346e-07, and 1.235e-07. z is 0.0100, 1.0000e-02, and 0.01. Recipe F: Controlling Precision Programmatically This is a cute trick that you probably won't need often, but when you do, is super-handy to know: You can use a variable to specify the number of digits displayed by the f , e , and g formats. Just wrap the variable in its own set of curly braces {...} , inside the normal curly-braces around the value to be displayed. some_value, sigfigs = 22.0 / 7.15e5, 3 print(f\"The value obtained is {some_value:.{sigfigs}g}.\") produces The value obtained is 3.08e-05. Recipe G: Percentages A common way to display numbers between 0 and 1, when they represent the relative amount of something, is as a percentage. If you were doing this by hand, you'd multiply the number by 100 and then stick a \"%\" sign at the end. Python can do that for you! All you have to do is to use % as the format specifier instead of f . A number before the % indicates how many decimal digits to display, just as with f . For example: print(f\"One-sixth is about {1/6:.3%}.\") will produce One-sixth is about 16.667%. Recipe H: Commas for Big Numbers For human readability, grouping the digits of big numbers with commas is common. Here's how to make python do this: big_number = 1234567.89 print(f\"A big number: {big_number:,}!\") produces A big number: 1,234,567.89! (By the way, you can separate long numeric literals in python code for readability too, but you have to use underscores instead of commas. The numbers 1234567 and 1_234_567 mean exactly the same thing, but it's easier to see from the second thats the value is a bit over one million.) Recipe I: Other Formatting Capabilities f-strings have WAY more functionality available, including things like left-padding the output with spaces to fill up a particular total width (in characters), which can be useful for making vertical columns of values line up. For a deeper dive, see: For a wordy introduction, the Real Python tutorial How to Format Floats Within F-Strings in Python . For a \"cheat sheet\" summary of how to do different things, Python Morsels' Python f-string tips & cheat sheets . Here's a neat little trick I personally use a lot when debugging more complicated code: Self-documenting expressions . (This recipe has no \"An Example\" section because the recipe bits are basically all examples.)","title":"Print Formatted Output"},{"location":"recipes/core/calculation/print/#print-formatted-output","text":"","title":"Print Formatted Output"},{"location":"recipes/core/calculation/print/#problem-to-solve","text":"I want to control the output of my code so that I can include text, specify precision, and so on.","title":"Problem to Solve"},{"location":"recipes/core/calculation/print/#introduction","text":"A bare python expression produces a result when evaluated. That result is of some particular type: an integer, a floating-point or complex number, a text string, or perhaps something else. The IPython console or other interactive python session will display that result according to some default rule it has for that type. The result will probably provide sufficient information, but may be ugly or otherwise not quite as human-friendly as you'd like. (This is especially important when writing scripts , which we'll get to in the next recipe, Write a Calculation Script .) To control the details of python code output, use the built-in print() function. Using it can be drop-dead simple, or mysteriously arcane and complex, depending on what your goals are. We'll build the complexity up gradually in this recipe.","title":"Introduction"},{"location":"recipes/core/calculation/print/#a-bit-of-terminology-and-conceptual-background","text":"Statements are chunks of python code that make changes to the python environment when they are executed, like importing a module or functions from it, or defining a variable and setting its value. Programmers call these \"side effects\". You can think of them as declarative sentences: \"Do this.\" Statements generally stand alone on a line (or a multi-line block), and don't \"return\" a value. Expressions are chunks of python code that are evaluated and coverted into some kind of value or object when they are executed. They don't do anything other than produce this value. Often, they are part of a statement, such as the right-hand side of x = 5.0 * sin(radians(15)) . Expressions can be made up of other expressions: 15 is an expresion, as are radians(15) and sin(radians(15)) . In IPython, when a \"bare expression\" \u2014 a line of python code that is an expression and not a statement \u2014 is sent to the python interpreter, the interpreter returns its value, and IPython displays that value as an \"output\" line. When working in IPython, the difference between values displayed as the result of expression evaluation and values displayed by print() is easy to overlook. The difference is important, however, and will be much more obvious when we move beyond IPython and start writing script files. For now, the key fact to stick into your memory is that print(...) is a statement that returns no result, but has the \"side effect\" of displaying text to the user. An expression simply returns a value, which might get used as part of a larger expression or statement, might be displayed to the user, or might be totally ignored depending on the context. One benefit of using print() statements to see your calculation results is that you get a whole lot of control over how values are displayed. You can embed numbers in text, control decimal digits or significant figures, force or prevent the use of scientific notation, control widths, etc.","title":"A bit of terminology and conceptual background\u2026"},{"location":"recipes/core/calculation/print/#recipe-a-just-print-one-value","text":"If all you want to do is get a value to display, and you're fine with python's default choices, just pass it to print() as an argument: from math import sin theta = 0.01 sin_theta = sin(theta) print(sin_theta) produces 0.009999833334166664","title":"Recipe A: Just Print one Value"},{"location":"recipes/core/calculation/print/#recipe-b-print-multiple-values","text":"If you pass multiple comma-separated arguments to print() , it will print them all, separated by spaces. (Note that any python expression can be an argument to print() , not just a variable name.) print(theta, sin_theta, theta - sin_theta) produces 0.01 0.009999833334166664 1.6666583333574403e-07 (Note how python automatically switches to scientific notation when the number is very small.) You can change the separation character from a space to something else (say, a comma) by specifying the sep keyword argument: print(theta, sin_theta, theta - sin_theta, sep=', ') produces 0.01, 0.009999833334166664, 1.6666583333574403e-07 You can even squish the values together with no separation at all by specifying an empty string as the separator: print(\"Twelve\", 12.0, 12, sep='') produces Twelve12.012 (This use case makes no sense, but situations do arise where it's helpful.)","title":"Recipe B: Print Multiple Values"},{"location":"recipes/core/calculation/print/#recipe-c-inserting-values-into-text","text":"Python has a special kind of string called an \"f-string\" (for \"formatted string\") that allows you to insert values into specific locations in a string. To use this, prepend a f before the opening quote, and put curly braces {\u2026} around the value(s) to be inserted: print(f\"Theta is {theta}, its sine is {sin_theta}, and their difference is {theta - sin_theta}.\") produces Theta is 0.01, its sine is 0.009999833334166664, and their difference is 1.6666583333574403e-07.","title":"Recipe C: Inserting Values Into Text"},{"location":"recipes/core/calculation/print/#recipe-d-controlling-number-format","text":"Look at that last output line. Notice that python displayed the first two numbers in traditional decimal notation, but chose to display the third number in scientific notation. By default, it displays very large and very small floating-point numbers in scientific notation, and uses decimal notation in between. You can force python to use a particular format by including a format specifier like this: print(f\"Theta is {theta:e}, its sine is {sin_theta:e}, and their difference is {theta - sin_theta:f}.\") This produces Theta is 1.000000e-02, its sine is 9.999833e-03, and their difference is 0.000000. If you include :f (for \"floating-point\") inside the curly-braces and after the variable or expression, python will display the number in decimal notation regardless of its size. If you include :e (for \"exponential\") instead, python will display the number in scientific notation. ( e means \"exponential\".) Or, if you use :g (for \"general\"), python will choose between the two formats based on the number's size. Although :g is very similar to using no specifier at all, the results can be slightly different: diff = theta - sin_theta print(f\"The difference can be shown as {diff}, {diff:f}, {diff:e},or {diff:g}.\") produces The difference can be shown as 1.6666583333574403e-07, 0.000000, 1.666658e-07,or 1.66666e-07. Examine carefully, especially the number of digits shownf","title":"Recipe D: Controlling Number Format"},{"location":"recipes/core/calculation/print/#recipe-e-controlling-precision","text":"Format specifiers also let you control the number of digits displayed in the number. When using the f or e specifiers, you can specify the number of digits past the decimal point to show. (With the f specifier, the number of digits before the decimal point is whatever it is. With the e specifier, the exponent is chosen so that there's always one digit before the decimal point.) When using g , on the other hand, you can specify the number of significant figures (not decimal digits) to show for whichever format python chooses (floating-point or exponential). Warning : the way that python counts significant figures for floating-point numbers is not always the way physicists count them, so beware! (I've) x = 0.123456789 y = x * 1e-6 z = 0.01 print(f\"x is {x:.4f}, {x:.4e}, and {x:.4g}.\") print(f\"y is {y:.4f}, {y:.4e}, and {y:.4g}.\") print(f\"z is {z:.4f}, {z:.4e}, and {z:.4g}.\") # See what `.4g` does here! produces x is 0.1235, 1.2346e-01, and 0.1235. y is 0.0000, 1.2346e-07, and 1.235e-07. z is 0.0100, 1.0000e-02, and 0.01.","title":"Recipe E: Controlling Precision"},{"location":"recipes/core/calculation/print/#recipe-f-controlling-precision-programmatically","text":"This is a cute trick that you probably won't need often, but when you do, is super-handy to know: You can use a variable to specify the number of digits displayed by the f , e , and g formats. Just wrap the variable in its own set of curly braces {...} , inside the normal curly-braces around the value to be displayed. some_value, sigfigs = 22.0 / 7.15e5, 3 print(f\"The value obtained is {some_value:.{sigfigs}g}.\") produces The value obtained is 3.08e-05.","title":"Recipe F: Controlling Precision Programmatically"},{"location":"recipes/core/calculation/print/#recipe-g-percentages","text":"A common way to display numbers between 0 and 1, when they represent the relative amount of something, is as a percentage. If you were doing this by hand, you'd multiply the number by 100 and then stick a \"%\" sign at the end. Python can do that for you! All you have to do is to use % as the format specifier instead of f . A number before the % indicates how many decimal digits to display, just as with f . For example: print(f\"One-sixth is about {1/6:.3%}.\") will produce One-sixth is about 16.667%.","title":"Recipe G: Percentages"},{"location":"recipes/core/calculation/print/#recipe-h-commas-for-big-numbers","text":"For human readability, grouping the digits of big numbers with commas is common. Here's how to make python do this: big_number = 1234567.89 print(f\"A big number: {big_number:,}!\") produces A big number: 1,234,567.89! (By the way, you can separate long numeric literals in python code for readability too, but you have to use underscores instead of commas. The numbers 1234567 and 1_234_567 mean exactly the same thing, but it's easier to see from the second thats the value is a bit over one million.)","title":"Recipe H: Commas for Big Numbers"},{"location":"recipes/core/calculation/print/#recipe-i-other-formatting-capabilities","text":"f-strings have WAY more functionality available, including things like left-padding the output with spaces to fill up a particular total width (in characters), which can be useful for making vertical columns of values line up. For a deeper dive, see: For a wordy introduction, the Real Python tutorial How to Format Floats Within F-Strings in Python . For a \"cheat sheet\" summary of how to do different things, Python Morsels' Python f-string tips & cheat sheets . Here's a neat little trick I personally use a lot when debugging more complicated code: Self-documenting expressions . (This recipe has no \"An Example\" section because the recipe bits are basically all examples.)","title":"Recipe I: Other Formatting Capabilities"},{"location":"recipes/core/calculation/scripts/","text":"Script a Calculation Problem to Solve I want to make a multi-step calculation easier to construct and debug, run multiple times, run again later, and/or have a permanent record of. Up until now, we've been using the IPython console as a kind of scientific calculator on steroids. This makes sense for quick one-off calculations. However, it has two major drawbacks: Repeating the same calculation with different given values is tedious and error-prone, and Constructing more complicated, multi-step calculations is awkward and error-prone, especially when repeated trying-fixing-trying again or debugging cycles are required. The solution: Write your lines of python code in a script file , using a text editor of some kind. Then, send the whole file to the python interpreter (from IPython or a terminal console) to execute. The interpreter will still work through your code one line at a time, just as if you'd entered them into an IPython session console. The biggest difference is that you won't see the results of bare python expressions. If you want your script to give you some results, you'll need to use the print() statement. Recipe, Part 1: Create the Script File Python scripts are just sequences of python commands, saved in a file with a .py extension. You can write and edit them in any text editor, but it's easiest to work in one that's meant for coding and provides useful functionality like auto-indentation and syntax coding. JupyterLab is a great choice for this. In JupyterLab , open the left-side File Browser (if not already open). In the File Browser, navigate to the folder where you want to save your script file. You can create folders and subfolders for this, if you wish, using the new-folder button at the top of the File Browser. If the Launcher is not open, open it by clicking the + button at the top of the File Browser or in the tab bar above the main panel. In the Launcher, click the \"Python File\" button down in the \"Other\" section. The Launcher should be replaced by a blank window with a tab that says \"untitled.py\". You can immediately give the file a more sensible name by saving it (cmd/ctrl-S or \"Save Python File\" from the JupyterLab File menu) and specifying a name. Give it a meaningful name, but don't use spaces or special characters other than the underscore, and make sure to keep the .py ending. You should see it show up in the File Browser. It's a good habit to immediately put a comment line (or several) at the top of the file, briefly stating what the script's purpose is. That could be as simple as something like # Calculations for PHY 325 HW 3 Problem 2 . In python code, any line beginning with a # (possibly preceded by empty space) is considered a \"comment\" for humans only, and is ignored by the python interpreter. You now have a python script! Admittedly, it doesn't do anything yet, so\u2026 Recipe, Part 2: Write the Script The short version: Just write python code in the file, as you would type it into an interactive python/ipython session. When you run the script, the lines in the file will be sent to the python interpreter one at a time, in the order they appear. If the very last non-empty line is an expression that would return a result (rather than, say, a variable assignment), that result will be shown as the \"result\" of the script. The longer version, showing good script organization habits: Begin the script with an informative comment , as described above. Think about explaining \"WTH is this script for?\" to anyone (including far-future you) that might look at it, as well as any assumptions that might not be obvious from the code. And, if this might be shared or distributed, include your name and a date and such. Next, import any needed modules , or functions from modules. Putting all the import statements at the top makes it easy for someone to see what your code's \"dependencies\" are. As you start writing bigger, more sophisticated programs with nonstandard third-party modules, this becomes increasingly important. Define variables for any physical or other \"standard\" constants , like the local or universal gravitational constants, the speed of light, etc. End the line with a comment that includes the units, like these: G = 6.67430e-11 # m**3 / (kg s**2) c = 2.99792458e8 # m/s Define variables for any situation-specific given values , also with explicit units in a comment. If the physical meaning of the variable is not obvious from its name, say what it is in the comment. m1 = 2.5 # kg, mass of upper block m2 = 2.5 # kg, mass of lower block mu_k = 0.3 # coefficient of kinetic friction between lower block and tabletop Note that you can use some extra space characters to make the comments align nicely. Calculate intermediate values and chunks of complicated expressions , storing them in variables and building up the calculation step by step. Again, include comments for anything not self-explanatory. I = (2/5) * M * R**2 # kg m**2, moment of inertia of the sphere A = 1 / r1 + 1 / r2 # denominator of net potential expression Use print() to display result(s) , using f-string format codes as you see fit. See the recipe Print Formatted Output for details. x_f, v_f, m.degrees(angle_f) (assuming your script already assigned values to the variables x_f , v_f , and angle_f ) Save your edits. It's probably wise to do this every so often as you work, just in case. Recipe, Part 3: Run the Script You can run the script directly from within an active IPython session, or from the system command line in a terminal. Method A: From IPython If you're in JupyterLab , you can easily open an IPython session with the correct working directory by right-clicking (or double-tapping or whatever) on the script file's title tab at the top of the editor, and selecting \"Create Console for Editor\". You should get a \"Select Kernel\" dialog. Choose \"Python 3 (ipykernel)\". Click \"Select\". A new pane should pop open, probably in the bottom half of the window. If you wish, you can grab the console by its tab and drag it to the right of the screen (to split vertically instead of horizontally), or right next to the script file's tab (to let you switch back and forth between the tabs, giving each a full window of space). This is a normal ipython session, so you can do the usual interactive python things there. And, you can run your python script (or any python script, really) by entering the magic command %run your_filename.py , replacing the your_filename bit with whatever you named your file. You should see the result of your script appear in the IPython console, exactly as if you'd typed the lines in, one at a time. (Except that you won't see the results of any expressions except the last in the script.) Any variables you've defined in the script are now defined in the IPython session, with whatever values the script assigned to them, so you can continue the calculation, or explore their values, or whatever you might want to do with them. Recipe, Part 4: Modify the Script If you discover an error, or you want to run it with different givens, or you're dissatisfied with what the script outputs, or you want to extend it \u2014 immediately, or days or months later \u2014 doing that is far easier than if you'd been working interactively in the console. Edit the script in the editor window in whatever way you wish. Save changes via the usual method (cmd/ctrl-S or \"Save Python File\" from the JupyterLab File menu). Run the script as in Recipe Part 3. Recipe, Part 5: Quitting When you're done (at least for a while): Close the IPython console by clicking the x in the tab. The pane should disappear. Open the \"Running Terminals and Kernels\" panel (in place of the File Browser panel) by clicking the \"square in circle\" button in the far left border of the JupyterLab window (which says \"Running Terminals and Kernels\" when you hover over it). **Kill the ipython kernel by clicking on the \"Shut Down All\" words to the right of the \"KERNELS\" section header in that panel. If you have other running kernels that you don't want to kill, you can instead open the KERNELS section by clicking on the word KERNELS, finding the line with your script's filename and an alphanumeric code like (1c7e3b30) following it, mousing over it. and clicking the \"X\" that appears to its right. It's easy to forget to kill the kernel, since there's no visual reminder that its running once you've closed the pane. Nothing terrible will happen if you forget, but it will hang around and take up memory on the server and generally cruft things up, so please try to remember. Recipe, Part 6: Resuming If, some time later, you wish to re-run and perhaps modify or extend your script, no problems! Locate the script in the File Browser and reopen it by double-clicking on it. Edit as you wish. Launch an IPython console for it, as described above in Recipe Part 3 (method A or B). Run, modify, and rerun it as you did in Recipe Parts 3 and 4. When done, quit as in Recipe Part 5. An Example Whew! That took a lot longer to describe than it actually takes to do. Let's look at an example. We'll revisit the physics calculation from our earlier recipe Use Python Functions , showing how the same calculation might be laid out in a script. I'll focus on the contents of the script, letting you walk through the procedural steps around it. For convenience, here's the problem again: Problem: An unpowered projectile is launched from the ground with an initial speed of 20 m/s at an angle of 50\u00b0 above the horizontal. What are its speed and direction when it's height above the ground is 10 m? Solution: Elementary kinematics allows one to derive expressions for the horizontal and vertical component of the projectile's velocity at any height \\(h\\) (not greater than its maximum height, of course): \\[v_x(h) = v_{0,x} \\qquad v_y(h) = \\sqrt{v_{0,y}^2 - 2gh}\\] where \\(v_{0,x}\\) and \\(v_{0,y}\\) are the components of the projectile's initial velocity, \\(g\\) is the acceleration due to gravity, and \\(h\\) is the height above the ground. If \\(\\theta_0\\) represents the velocity's initial angle above horizontal, we can decompose the initial velocity vector into: \\[v_{0,x} = v_0 \\cos(\\theta_0) \\qquad v_{0,y} = v_0 \\sin(\\theta_0)\\] We can use the expressions above to determine the components of the initial velocity vector, and then the velocity components at the given height. Once we know those, we can calculate the requested values by applying trig to find the magnitude and direction of the velocity vector at that height: \\[v(h) = \\sqrt{v_x(h)^2 + v_y(h)^2} \\qquad \\theta(h) = \\arctan\\left(\\frac{v_y(h)}{v_x(h)}\\right)\\] The script: A python script to do the numeric calculations for this might \u2014 if well-organized and commented \u2014 look something like this: # ------------------------------------------------------------------- # PHY 291 HW-2 Problem 3 -- Calculations # ------------------------------------------------------------------- # Imports from math import radians, degrees, sin, cos, sqrt, atan2 # Define constants g = 9.806 # N/kg -- local gravitational constant # Define givens h = 10 # m -- height for which we want velocity v0 = 20 # m/s -- initial speed q0 = radians(50) # degrees (converted) -- initial direction # Calculate initial velocity components v0x = v0 * cos(q0) v0y = v0 * sin(q0) # Calculate velocity components at height `h` vx = v0x vy = sqrt(v0y**2 - 2 * g * h) # Calculate magnitude and direction v = sqrt(vx**2 + vy**2) q = atan2(vy, vx) # Report out the result print(f\"At a height of {h} m, the final velocity is {v:.2f} m/s\") print(f\"at an angle of {degrees(q):.2f} degrees above horizontal.\") # ------------------------------------------------------------------- Let's assume we named the file hw02-p3.py . Executing %run hw02-p3.py in an IPython console would produce the following output: At a height of 10 m, the final velocity is 14.28 m/s at an angle of 25.80 degrees above horizontal. Should we want to know the velocity at a different height, we could edit the script to change h = 10 to a different number, and then re-run the script. Easy peasy. A few comments: You might think including all those section comments like \"# Calculate magnitude and direction\" is overkill and a waste of time, but it's actually helpful if you do it right: Write out the sequence of section comments first , like a kind of \"outline\" or \"recipe\" to follow. Then, fill in the code for each section. You can skip the import section at first, adding bits to it as you're writing other sections and realize the functions you'll need to import. I chose to import specific math module functions by name here, but there are enough that using the import math as m route would be reasonable too. I didn't use the comma trick to define related variables (like vx and vy ) on one line, but you could. Note that I did NOT \"hard-code\" any of the given values into the calculations or the final print statements. For example, I used f-string variable insertion to include the height value, rather than just typing At a height of 10 m . This way, I only have to edit one number to change the whole calculation and output to use a different height. Had I hard-coded a result, I introduce the risk of forgetting to change it in all places \u2014 a very VERY common coding error.","title":"Script a Calculation"},{"location":"recipes/core/calculation/scripts/#script-a-calculation","text":"","title":"Script a Calculation"},{"location":"recipes/core/calculation/scripts/#problem-to-solve","text":"I want to make a multi-step calculation easier to construct and debug, run multiple times, run again later, and/or have a permanent record of. Up until now, we've been using the IPython console as a kind of scientific calculator on steroids. This makes sense for quick one-off calculations. However, it has two major drawbacks: Repeating the same calculation with different given values is tedious and error-prone, and Constructing more complicated, multi-step calculations is awkward and error-prone, especially when repeated trying-fixing-trying again or debugging cycles are required. The solution: Write your lines of python code in a script file , using a text editor of some kind. Then, send the whole file to the python interpreter (from IPython or a terminal console) to execute. The interpreter will still work through your code one line at a time, just as if you'd entered them into an IPython session console. The biggest difference is that you won't see the results of bare python expressions. If you want your script to give you some results, you'll need to use the print() statement.","title":"Problem to Solve"},{"location":"recipes/core/calculation/scripts/#recipe-part-1-create-the-script-file","text":"Python scripts are just sequences of python commands, saved in a file with a .py extension. You can write and edit them in any text editor, but it's easiest to work in one that's meant for coding and provides useful functionality like auto-indentation and syntax coding. JupyterLab is a great choice for this. In JupyterLab , open the left-side File Browser (if not already open). In the File Browser, navigate to the folder where you want to save your script file. You can create folders and subfolders for this, if you wish, using the new-folder button at the top of the File Browser. If the Launcher is not open, open it by clicking the + button at the top of the File Browser or in the tab bar above the main panel. In the Launcher, click the \"Python File\" button down in the \"Other\" section. The Launcher should be replaced by a blank window with a tab that says \"untitled.py\". You can immediately give the file a more sensible name by saving it (cmd/ctrl-S or \"Save Python File\" from the JupyterLab File menu) and specifying a name. Give it a meaningful name, but don't use spaces or special characters other than the underscore, and make sure to keep the .py ending. You should see it show up in the File Browser. It's a good habit to immediately put a comment line (or several) at the top of the file, briefly stating what the script's purpose is. That could be as simple as something like # Calculations for PHY 325 HW 3 Problem 2 . In python code, any line beginning with a # (possibly preceded by empty space) is considered a \"comment\" for humans only, and is ignored by the python interpreter. You now have a python script! Admittedly, it doesn't do anything yet, so\u2026","title":"Recipe, Part 1: Create the Script File"},{"location":"recipes/core/calculation/scripts/#recipe-part-2-write-the-script","text":"The short version: Just write python code in the file, as you would type it into an interactive python/ipython session. When you run the script, the lines in the file will be sent to the python interpreter one at a time, in the order they appear. If the very last non-empty line is an expression that would return a result (rather than, say, a variable assignment), that result will be shown as the \"result\" of the script. The longer version, showing good script organization habits: Begin the script with an informative comment , as described above. Think about explaining \"WTH is this script for?\" to anyone (including far-future you) that might look at it, as well as any assumptions that might not be obvious from the code. And, if this might be shared or distributed, include your name and a date and such. Next, import any needed modules , or functions from modules. Putting all the import statements at the top makes it easy for someone to see what your code's \"dependencies\" are. As you start writing bigger, more sophisticated programs with nonstandard third-party modules, this becomes increasingly important. Define variables for any physical or other \"standard\" constants , like the local or universal gravitational constants, the speed of light, etc. End the line with a comment that includes the units, like these: G = 6.67430e-11 # m**3 / (kg s**2) c = 2.99792458e8 # m/s Define variables for any situation-specific given values , also with explicit units in a comment. If the physical meaning of the variable is not obvious from its name, say what it is in the comment. m1 = 2.5 # kg, mass of upper block m2 = 2.5 # kg, mass of lower block mu_k = 0.3 # coefficient of kinetic friction between lower block and tabletop Note that you can use some extra space characters to make the comments align nicely. Calculate intermediate values and chunks of complicated expressions , storing them in variables and building up the calculation step by step. Again, include comments for anything not self-explanatory. I = (2/5) * M * R**2 # kg m**2, moment of inertia of the sphere A = 1 / r1 + 1 / r2 # denominator of net potential expression Use print() to display result(s) , using f-string format codes as you see fit. See the recipe Print Formatted Output for details. x_f, v_f, m.degrees(angle_f) (assuming your script already assigned values to the variables x_f , v_f , and angle_f ) Save your edits. It's probably wise to do this every so often as you work, just in case.","title":"Recipe, Part 2: Write the Script"},{"location":"recipes/core/calculation/scripts/#recipe-part-3-run-the-script","text":"You can run the script directly from within an active IPython session, or from the system command line in a terminal.","title":"Recipe, Part 3: Run the Script"},{"location":"recipes/core/calculation/scripts/#method-a-from-ipython","text":"If you're in JupyterLab , you can easily open an IPython session with the correct working directory by right-clicking (or double-tapping or whatever) on the script file's title tab at the top of the editor, and selecting \"Create Console for Editor\". You should get a \"Select Kernel\" dialog. Choose \"Python 3 (ipykernel)\". Click \"Select\". A new pane should pop open, probably in the bottom half of the window. If you wish, you can grab the console by its tab and drag it to the right of the screen (to split vertically instead of horizontally), or right next to the script file's tab (to let you switch back and forth between the tabs, giving each a full window of space). This is a normal ipython session, so you can do the usual interactive python things there. And, you can run your python script (or any python script, really) by entering the magic command %run your_filename.py , replacing the your_filename bit with whatever you named your file. You should see the result of your script appear in the IPython console, exactly as if you'd typed the lines in, one at a time. (Except that you won't see the results of any expressions except the last in the script.) Any variables you've defined in the script are now defined in the IPython session, with whatever values the script assigned to them, so you can continue the calculation, or explore their values, or whatever you might want to do with them.","title":"Method A: From IPython"},{"location":"recipes/core/calculation/scripts/#recipe-part-4-modify-the-script","text":"If you discover an error, or you want to run it with different givens, or you're dissatisfied with what the script outputs, or you want to extend it \u2014 immediately, or days or months later \u2014 doing that is far easier than if you'd been working interactively in the console. Edit the script in the editor window in whatever way you wish. Save changes via the usual method (cmd/ctrl-S or \"Save Python File\" from the JupyterLab File menu). Run the script as in Recipe Part 3.","title":"Recipe, Part 4: Modify the Script"},{"location":"recipes/core/calculation/scripts/#recipe-part-5-quitting","text":"When you're done (at least for a while): Close the IPython console by clicking the x in the tab. The pane should disappear. Open the \"Running Terminals and Kernels\" panel (in place of the File Browser panel) by clicking the \"square in circle\" button in the far left border of the JupyterLab window (which says \"Running Terminals and Kernels\" when you hover over it). **Kill the ipython kernel by clicking on the \"Shut Down All\" words to the right of the \"KERNELS\" section header in that panel. If you have other running kernels that you don't want to kill, you can instead open the KERNELS section by clicking on the word KERNELS, finding the line with your script's filename and an alphanumeric code like (1c7e3b30) following it, mousing over it. and clicking the \"X\" that appears to its right. It's easy to forget to kill the kernel, since there's no visual reminder that its running once you've closed the pane. Nothing terrible will happen if you forget, but it will hang around and take up memory on the server and generally cruft things up, so please try to remember.","title":"Recipe, Part 5: Quitting"},{"location":"recipes/core/calculation/scripts/#recipe-part-6-resuming","text":"If, some time later, you wish to re-run and perhaps modify or extend your script, no problems! Locate the script in the File Browser and reopen it by double-clicking on it. Edit as you wish. Launch an IPython console for it, as described above in Recipe Part 3 (method A or B). Run, modify, and rerun it as you did in Recipe Parts 3 and 4. When done, quit as in Recipe Part 5.","title":"Recipe, Part 6: Resuming"},{"location":"recipes/core/calculation/scripts/#an-example","text":"Whew! That took a lot longer to describe than it actually takes to do. Let's look at an example. We'll revisit the physics calculation from our earlier recipe Use Python Functions , showing how the same calculation might be laid out in a script. I'll focus on the contents of the script, letting you walk through the procedural steps around it. For convenience, here's the problem again: Problem: An unpowered projectile is launched from the ground with an initial speed of 20 m/s at an angle of 50\u00b0 above the horizontal. What are its speed and direction when it's height above the ground is 10 m? Solution: Elementary kinematics allows one to derive expressions for the horizontal and vertical component of the projectile's velocity at any height \\(h\\) (not greater than its maximum height, of course): \\[v_x(h) = v_{0,x} \\qquad v_y(h) = \\sqrt{v_{0,y}^2 - 2gh}\\] where \\(v_{0,x}\\) and \\(v_{0,y}\\) are the components of the projectile's initial velocity, \\(g\\) is the acceleration due to gravity, and \\(h\\) is the height above the ground. If \\(\\theta_0\\) represents the velocity's initial angle above horizontal, we can decompose the initial velocity vector into: \\[v_{0,x} = v_0 \\cos(\\theta_0) \\qquad v_{0,y} = v_0 \\sin(\\theta_0)\\] We can use the expressions above to determine the components of the initial velocity vector, and then the velocity components at the given height. Once we know those, we can calculate the requested values by applying trig to find the magnitude and direction of the velocity vector at that height: \\[v(h) = \\sqrt{v_x(h)^2 + v_y(h)^2} \\qquad \\theta(h) = \\arctan\\left(\\frac{v_y(h)}{v_x(h)}\\right)\\] The script: A python script to do the numeric calculations for this might \u2014 if well-organized and commented \u2014 look something like this: # ------------------------------------------------------------------- # PHY 291 HW-2 Problem 3 -- Calculations # ------------------------------------------------------------------- # Imports from math import radians, degrees, sin, cos, sqrt, atan2 # Define constants g = 9.806 # N/kg -- local gravitational constant # Define givens h = 10 # m -- height for which we want velocity v0 = 20 # m/s -- initial speed q0 = radians(50) # degrees (converted) -- initial direction # Calculate initial velocity components v0x = v0 * cos(q0) v0y = v0 * sin(q0) # Calculate velocity components at height `h` vx = v0x vy = sqrt(v0y**2 - 2 * g * h) # Calculate magnitude and direction v = sqrt(vx**2 + vy**2) q = atan2(vy, vx) # Report out the result print(f\"At a height of {h} m, the final velocity is {v:.2f} m/s\") print(f\"at an angle of {degrees(q):.2f} degrees above horizontal.\") # ------------------------------------------------------------------- Let's assume we named the file hw02-p3.py . Executing %run hw02-p3.py in an IPython console would produce the following output: At a height of 10 m, the final velocity is 14.28 m/s at an angle of 25.80 degrees above horizontal. Should we want to know the velocity at a different height, we could edit the script to change h = 10 to a different number, and then re-run the script. Easy peasy. A few comments: You might think including all those section comments like \"# Calculate magnitude and direction\" is overkill and a waste of time, but it's actually helpful if you do it right: Write out the sequence of section comments first , like a kind of \"outline\" or \"recipe\" to follow. Then, fill in the code for each section. You can skip the import section at first, adding bits to it as you're writing other sections and realize the functions you'll need to import. I chose to import specific math module functions by name here, but there are enough that using the import math as m route would be reasonable too. I didn't use the comma trick to define related variables (like vx and vy ) on one line, but you could. Note that I did NOT \"hard-code\" any of the given values into the calculations or the final print statements. For example, I used f-string variable insertion to include the height value, rather than just typing At a height of 10 m . This way, I only have to edit one number to change the whole calculation and output to use a different height. Had I hard-coded a result, I introduce the risk of forgetting to change it in all places \u2014 a very VERY common coding error.","title":"An Example"},{"location":"recipes/core/calculation/use-functions/","text":"Use Python Functions Problem to Solve I want to use predefined mathematical (or other) functions, like sine or absolute-value, in my calculation. Introduction Python has a truly incredible arsenal of ready-to-use functions available to you. A few are built into core python, many many more are available through python's \"standard library modules\", and a truly humongous number are available through a vast ecosystem of third-party add-on modules that you can download and install as needed. I think it's fair to say that before you spend time and effort figuring out how to do a coding task, it's worth stopping and asking yourself: \"Does this seem like the kind of thing that people might commonly want to do, or is it really idiosyncratic to my situation?\" If the former, there's probably a function already in existence for it. Depending on how hard the task is, and how critical your code's need for efficiency is, finding that function may or may not be the worth the time. The question is worth entertaining, though, and getting familiar with the range of functionality available to you is definitely worthwhile. In this recipe, we'll focus predominantly on mathematically-oriented functions, but the same process applies to string (text) manipulation, rearranging collections of things, serving up web pages, and so on. Recipe for Built-In Functions (This barely deserves the name \"recipe\".) If you need functionality provided by core python functions, just use them, like this: function_name() for a function that takes no arguments, or function_name(argument_value_1, argument_value_2, ...) for a function that takes one or more arguments. To get the absolute value of the number stored in variable x , use abs(x) . To calculate the seventh power of x , pow(x, 7) and x**7 are equivalent. To round a floating-point number a to its nearest integer, use round(a) . To round a floating-point number a to n decimal places, use round(a, n) . That's about it for mathematically-oriented functions, unless you want to check whether a particular variable is storing an integer, floating-point, or complex number: >>> a, b, c = 3, 3.0, 3+0j >>> type(a), type(b), type(c) (<class 'int'>, <class 'float'>, <class 'complex'>) Or, you can (sometimes) forcibly change a variable to a different numeric type: >>> int(b) 3 >>> type(int(b)) <class 'int'> >>> s = \"3.14\" >>> round(s) Traceback (most recent call last): File \"<python-input-15>\", line 1, in <module> round(s) ~~~~~^^^ TypeError: type str doesn't define __round__ method >>> round(float(s)) 3 >>> float(c) Traceback (most recent call last): File \"<python-input-17>\", line 1, in <module> float(c) ~~~~~^^^ TypeError: float() argument must be a string or a real number, not 'complex' See here if you want a thorough explanation of the core python functions available. (That's far beyond what this course requires.) Recipe for Standard Library Functions, Version A: Selective Import To get a sense of the \"modules\" available in the python \"standard library\" \u2014 which come as part of a standard python installation, and therefore are always available to you \u2014 take a quick browse through the python module index , and drill down into any specific modules that catch your interest. At the very least, browse through the math module ; you'll be using that A LOT. It's necessary to \"import\" a module, or specific pieces of a module, before using them. In general, if you'll only be using a few of the functions in a module, it's best to import just those functions. Here's the generic recipe: from [module_name] import [comma-separated list of function names] You can then use the functions you've imported exactly as if they were built-in functions. Here's a (very contrived) example: >>> from math import radians, degrees, sin, acos, sqrt >>> angle = radians(76.543) >>> degrees( acos( sqrt( 1 - sin(angle)**2 ) ) ) 76.54299999999999 Recipe for Standard Library Functions, Version B: Import the Module If you'll be using many functions from one module \u2014 or if you'll be doing a fair amount of exploratory calculation and you don't really know which you'll be using and don't want to bother importing each function separately as you realize you need it \u2014 you can just import the whole module. Here's an example: >>> import math >>> math.sin(math.radians(30)) 0.49999999999999994 The general recipe is just import module_name , after which you must refer to the bits of the module with a prefix of module_name.function_name(...) . Yes, that can get a bit tedious. You can make it a bit more compact by giving the module a shorthand name as you import it, using the import module_name as nickname syntax: >>> import math as m >>> m.sin(m.radians(30)) 0.49999999999999994 Just be careful that you don't accidentally define a variable m as well, or one will \"shadow\" the other: >>> import math as m >>> m = 33 >>> m.sin(0) Traceback (most recent call last): File \"<python-input-33>\", line 1, in <module> m.sin(0) ^^^^^ AttributeError: 'int' object has no attribute 'sin' Recipe for Standard Library Functions, Version C: Import Everything From the Module If you really don't want to be bothered typing a prefix on every imported function, and just want everything in a module available as if it were all built-in or as if you'd listed EVERYTHING on an from module_name import ... line, you can, via the wildcard symbol * that means \"everything\": >>> from math import * >>> angle = radians(76.543) >>> sqrt( sin(angle)**2 + cos(angle)**2 ) 1.0 WARNING: Everything in the module \u2014 which could include functions, constants, sub-modules, objects, and who-knows-what else \u2014 will get dumped into your namespace. That creates A LOT of potential for name collisions with your own variables, especially since you may not know all the names that were imported. For example, in physics, the Greek letters \"alpha\" and \"tau\" are frequently used to represent angular acceleration and torque, respectively. Imagine that you're doing a rotational motion calculation, and the expression you've derived for an angular acceleration is \\(\\alpha = \\tau / I\\) where \\(I = m \\left[d \\ \\sin(30^\\circ)\\right]^2\\) with given values are \\(\\tau = 3.2 \\times 10^5\\) , \\(m = 1500\\) , and \\(d = 18\\) (all in SI units). If you do this: >>> m, d, tau = 1.5e3, 18, 3.2e5 >>> from math import * >>> I = m * (d * sin(radians(30)))**2 >>> tau / I 5.171345931835052e-05 \u2026you'll be dead wrong. Compare the final result with this: >>> m, d, tau = 1.5e3, 18, 3.2e5 >>> import math >>> I = m * (d * math.sin(math.radians(30)))**2 >>> tau / I 2.633744855967079 Challenge: Can you figure out why? An Example Problem: An unpowered projectile is launched from the ground with an initial speed of 20 m/s at an angle of 50\u00b0 above the horizontal. What are its speed and direction when it's height above the ground is 10 m? Solution: Elementary kinematics allows one to derive expressions for the horizontal and vertical component of the projectile's velocity at any height \\(h\\) (not greater than its maximum height, of course): \\[v_x(h) = v_{0,x} \\qquad v_y(h) = \\sqrt{v_{0,y}^2 - 2gh}\\] where \\(v_{0,x}\\) and \\(v_{0,y}\\) are the components of the projectile's initial velocity, \\(g\\) is the acceleration due to gravity, and \\(h\\) is the height above the ground. If \\(\\theta_0\\) represents the velocity's initial angle above horizontal, we can decompose the initial velocity vector into: \\[v_{0,x} = v_0 \\cos(\\theta_0) \\qquad v_{0,y} = v_0 \\sin(\\theta_0)\\] We can use the expressions above to determine the components of the initial velocity vector, and then the velocity components at the given height. Once we know those, we can calculate the requested values by applying trig to find the magnitude and direction of the velocity vector at that height: \\[v(h) = \\sqrt{v_x(h)^2 + v_y(h)^2} \\qquad \\theta(h) = \\arctan\\left(\\frac{v_y(h)}{v_x(h)}\\right)\\] In [1]: import math as m In [2]: v0, q0 = 20, m.radians(50) In [3]: v0x, v0y = v0 * m.cos(q0), v0 * m.sin(q0) In [4]: v0x, v0y Out[4]: (12.855752193730787, 15.32088886237956) In [5]: g = 9.806 In [6]: h = 10 In [7]: vx, vy = v0x, m.sqrt(v0y**2 - 2 * g * h) In [8]: vx, vy Out[8]: (12.855752193730787, 6.213665225403286) In [9]: v = m.sqrt(vx**2 + vy**2) In [10]: q = m.atan2(vy, vx) In [11]: v, m.degrees(q) Out[11]: (14.278655398881227, 25.79621315114633) Notes: I make liberal use of the \"comma trick\" to define two related variables on one line. You don't have to. Since you can't really use Greek letters in code, I've developed a habit of using q or Q in place of \\(\\theta\\) , w in place of \\(\\omega\\) , and ph in place of \\(\\phi\\) . Because I do this regularly, my code is still readable, at least to me. Writing out the names like theta isn't a bad idea either. Nor is using descriptive names like initial_angle or angular_freq . Python's trig functions all work in radians , but we often use degrees for human interpretability, so converting back and forth is a way of life. Get used to this! A good practice is to make sure all angle variables in your code ALWAYS contain values in radians. If given degrees, don't even store that value; immediately use math.radians() to convert to radians and store that in a variable, as I did in line 2. If asked to report a result in degrees, calculate it in radians and use math.degrees() as you display it. If you really want to store a value in degrees in a variable, give it a name like theta_deg to remind yourself that it's in degrees. In line 4, I peeked at the values of the initial velocity components to make sure they seemed plausible. If I'd screwed up something, perhaps by forgetting to convert degrees to radians, I might have noticed it here. In line 10, I used the math module's atan2() function instead of the atan() function. It shouldn't really matter in this situation, but you should know about how they differ. Go read about them in the math module documentation. TLDR: atan2 is smarter about figuring out the right quadrant. atan can't tell between the first and third quadrants, or between the second and fourth.","title":"Use Python Functions"},{"location":"recipes/core/calculation/use-functions/#use-python-functions","text":"","title":"Use Python Functions"},{"location":"recipes/core/calculation/use-functions/#problem-to-solve","text":"I want to use predefined mathematical (or other) functions, like sine or absolute-value, in my calculation.","title":"Problem to Solve"},{"location":"recipes/core/calculation/use-functions/#introduction","text":"Python has a truly incredible arsenal of ready-to-use functions available to you. A few are built into core python, many many more are available through python's \"standard library modules\", and a truly humongous number are available through a vast ecosystem of third-party add-on modules that you can download and install as needed. I think it's fair to say that before you spend time and effort figuring out how to do a coding task, it's worth stopping and asking yourself: \"Does this seem like the kind of thing that people might commonly want to do, or is it really idiosyncratic to my situation?\" If the former, there's probably a function already in existence for it. Depending on how hard the task is, and how critical your code's need for efficiency is, finding that function may or may not be the worth the time. The question is worth entertaining, though, and getting familiar with the range of functionality available to you is definitely worthwhile. In this recipe, we'll focus predominantly on mathematically-oriented functions, but the same process applies to string (text) manipulation, rearranging collections of things, serving up web pages, and so on.","title":"Introduction"},{"location":"recipes/core/calculation/use-functions/#recipe-for-built-in-functions","text":"(This barely deserves the name \"recipe\".) If you need functionality provided by core python functions, just use them, like this: function_name() for a function that takes no arguments, or function_name(argument_value_1, argument_value_2, ...) for a function that takes one or more arguments. To get the absolute value of the number stored in variable x , use abs(x) . To calculate the seventh power of x , pow(x, 7) and x**7 are equivalent. To round a floating-point number a to its nearest integer, use round(a) . To round a floating-point number a to n decimal places, use round(a, n) . That's about it for mathematically-oriented functions, unless you want to check whether a particular variable is storing an integer, floating-point, or complex number: >>> a, b, c = 3, 3.0, 3+0j >>> type(a), type(b), type(c) (<class 'int'>, <class 'float'>, <class 'complex'>) Or, you can (sometimes) forcibly change a variable to a different numeric type: >>> int(b) 3 >>> type(int(b)) <class 'int'> >>> s = \"3.14\" >>> round(s) Traceback (most recent call last): File \"<python-input-15>\", line 1, in <module> round(s) ~~~~~^^^ TypeError: type str doesn't define __round__ method >>> round(float(s)) 3 >>> float(c) Traceback (most recent call last): File \"<python-input-17>\", line 1, in <module> float(c) ~~~~~^^^ TypeError: float() argument must be a string or a real number, not 'complex' See here if you want a thorough explanation of the core python functions available. (That's far beyond what this course requires.)","title":"Recipe for Built-In Functions"},{"location":"recipes/core/calculation/use-functions/#recipe-for-standard-library-functions-version-a-selective-import","text":"To get a sense of the \"modules\" available in the python \"standard library\" \u2014 which come as part of a standard python installation, and therefore are always available to you \u2014 take a quick browse through the python module index , and drill down into any specific modules that catch your interest. At the very least, browse through the math module ; you'll be using that A LOT. It's necessary to \"import\" a module, or specific pieces of a module, before using them. In general, if you'll only be using a few of the functions in a module, it's best to import just those functions. Here's the generic recipe: from [module_name] import [comma-separated list of function names] You can then use the functions you've imported exactly as if they were built-in functions. Here's a (very contrived) example: >>> from math import radians, degrees, sin, acos, sqrt >>> angle = radians(76.543) >>> degrees( acos( sqrt( 1 - sin(angle)**2 ) ) ) 76.54299999999999","title":"Recipe for Standard Library Functions, Version A: Selective Import"},{"location":"recipes/core/calculation/use-functions/#recipe-for-standard-library-functions-version-b-import-the-module","text":"If you'll be using many functions from one module \u2014 or if you'll be doing a fair amount of exploratory calculation and you don't really know which you'll be using and don't want to bother importing each function separately as you realize you need it \u2014 you can just import the whole module. Here's an example: >>> import math >>> math.sin(math.radians(30)) 0.49999999999999994 The general recipe is just import module_name , after which you must refer to the bits of the module with a prefix of module_name.function_name(...) . Yes, that can get a bit tedious. You can make it a bit more compact by giving the module a shorthand name as you import it, using the import module_name as nickname syntax: >>> import math as m >>> m.sin(m.radians(30)) 0.49999999999999994 Just be careful that you don't accidentally define a variable m as well, or one will \"shadow\" the other: >>> import math as m >>> m = 33 >>> m.sin(0) Traceback (most recent call last): File \"<python-input-33>\", line 1, in <module> m.sin(0) ^^^^^ AttributeError: 'int' object has no attribute 'sin'","title":"Recipe for Standard Library Functions, Version B: Import the Module"},{"location":"recipes/core/calculation/use-functions/#recipe-for-standard-library-functions-version-c-import-everything-from-the-module","text":"If you really don't want to be bothered typing a prefix on every imported function, and just want everything in a module available as if it were all built-in or as if you'd listed EVERYTHING on an from module_name import ... line, you can, via the wildcard symbol * that means \"everything\": >>> from math import * >>> angle = radians(76.543) >>> sqrt( sin(angle)**2 + cos(angle)**2 ) 1.0 WARNING: Everything in the module \u2014 which could include functions, constants, sub-modules, objects, and who-knows-what else \u2014 will get dumped into your namespace. That creates A LOT of potential for name collisions with your own variables, especially since you may not know all the names that were imported. For example, in physics, the Greek letters \"alpha\" and \"tau\" are frequently used to represent angular acceleration and torque, respectively. Imagine that you're doing a rotational motion calculation, and the expression you've derived for an angular acceleration is \\(\\alpha = \\tau / I\\) where \\(I = m \\left[d \\ \\sin(30^\\circ)\\right]^2\\) with given values are \\(\\tau = 3.2 \\times 10^5\\) , \\(m = 1500\\) , and \\(d = 18\\) (all in SI units). If you do this: >>> m, d, tau = 1.5e3, 18, 3.2e5 >>> from math import * >>> I = m * (d * sin(radians(30)))**2 >>> tau / I 5.171345931835052e-05 \u2026you'll be dead wrong. Compare the final result with this: >>> m, d, tau = 1.5e3, 18, 3.2e5 >>> import math >>> I = m * (d * math.sin(math.radians(30)))**2 >>> tau / I 2.633744855967079 Challenge: Can you figure out why?","title":"Recipe for Standard Library Functions, Version C: Import Everything From the Module"},{"location":"recipes/core/calculation/use-functions/#an-example","text":"Problem: An unpowered projectile is launched from the ground with an initial speed of 20 m/s at an angle of 50\u00b0 above the horizontal. What are its speed and direction when it's height above the ground is 10 m? Solution: Elementary kinematics allows one to derive expressions for the horizontal and vertical component of the projectile's velocity at any height \\(h\\) (not greater than its maximum height, of course): \\[v_x(h) = v_{0,x} \\qquad v_y(h) = \\sqrt{v_{0,y}^2 - 2gh}\\] where \\(v_{0,x}\\) and \\(v_{0,y}\\) are the components of the projectile's initial velocity, \\(g\\) is the acceleration due to gravity, and \\(h\\) is the height above the ground. If \\(\\theta_0\\) represents the velocity's initial angle above horizontal, we can decompose the initial velocity vector into: \\[v_{0,x} = v_0 \\cos(\\theta_0) \\qquad v_{0,y} = v_0 \\sin(\\theta_0)\\] We can use the expressions above to determine the components of the initial velocity vector, and then the velocity components at the given height. Once we know those, we can calculate the requested values by applying trig to find the magnitude and direction of the velocity vector at that height: \\[v(h) = \\sqrt{v_x(h)^2 + v_y(h)^2} \\qquad \\theta(h) = \\arctan\\left(\\frac{v_y(h)}{v_x(h)}\\right)\\] In [1]: import math as m In [2]: v0, q0 = 20, m.radians(50) In [3]: v0x, v0y = v0 * m.cos(q0), v0 * m.sin(q0) In [4]: v0x, v0y Out[4]: (12.855752193730787, 15.32088886237956) In [5]: g = 9.806 In [6]: h = 10 In [7]: vx, vy = v0x, m.sqrt(v0y**2 - 2 * g * h) In [8]: vx, vy Out[8]: (12.855752193730787, 6.213665225403286) In [9]: v = m.sqrt(vx**2 + vy**2) In [10]: q = m.atan2(vy, vx) In [11]: v, m.degrees(q) Out[11]: (14.278655398881227, 25.79621315114633)","title":"An Example"},{"location":"recipes/core/calculation/use-functions/#notes","text":"I make liberal use of the \"comma trick\" to define two related variables on one line. You don't have to. Since you can't really use Greek letters in code, I've developed a habit of using q or Q in place of \\(\\theta\\) , w in place of \\(\\omega\\) , and ph in place of \\(\\phi\\) . Because I do this regularly, my code is still readable, at least to me. Writing out the names like theta isn't a bad idea either. Nor is using descriptive names like initial_angle or angular_freq . Python's trig functions all work in radians , but we often use degrees for human interpretability, so converting back and forth is a way of life. Get used to this! A good practice is to make sure all angle variables in your code ALWAYS contain values in radians. If given degrees, don't even store that value; immediately use math.radians() to convert to radians and store that in a variable, as I did in line 2. If asked to report a result in degrees, calculate it in radians and use math.degrees() as you display it. If you really want to store a value in degrees in a variable, give it a name like theta_deg to remind yourself that it's in degrees. In line 4, I peeked at the values of the initial velocity components to make sure they seemed plausible. If I'd screwed up something, perhaps by forgetting to convert degrees to radians, I might have noticed it here. In line 10, I used the math module's atan2() function instead of the atan() function. It shouldn't really matter in this situation, but you should know about how they differ. Go read about them in the math module documentation. TLDR: atan2 is smarter about figuring out the right quadrant. atan can't tell between the first and third quadrants, or between the second and fourth.","title":"Notes:"},{"location":"recipes/core/calculation/user-input/","text":"Ask for User Input Problem to Solve I want to be able to run my script (or let someone else run it) with various given values, without having to edit the script each time. Editing and re-running a script isn't hard if you already have the script open in your editor. However, it's possible to run a script without opening it in an editor; one way is to simply execute python my_script.py in a terminal, assuming the script file is in the current working directory. (On some systems, you may have to execute python3 my_script.py instead.) In such a case, it's convenient to let the script ask the user for values when it runs. Recipe Python has a built-in input() function that asks the user for input. You can use this to get given values at run-time, but you'll need to do a bit of extra work to get numerical values and protect against incorrect entries. Here's the generic recipe: # Ask user for a value: variable_name = input(\"Prompt string: \") # Convert from a string to a float: # (Use `int` for an integer or `complex` for a complex number.) variable_name = float(variable_name) # Do any necessary safety-checking, such as: assert variable_name >= 0, \"Value must be non-negative.\" You can compactify this, if you want: variable_name = float(input(\"Prompt string: \")) assert variable_name >= 0, \"Value must be non-negative.\" Notes: Change variable_name to the name you want to use for the value you're getting from the user: m , v0 , or whatever. Change Prompt string to an appropriate cue to the user. Be explicit about units, if appropriate, so you don't get a mass in grams when the code is expecting kilograms, or an angle in radians when it expects degrees. Example: m1 = float(input(\"Mass 1 (in kg): )) The float(\u2026) or int(\u2026) or complex(\u2026) is necessary because the input(\u2026) function returns the user's input as a string. Your code must coerce it into the desired type. If the user enters something that's not directly interpretable as the desired type, python will raise a scary error. We'll learn how to handle this gracefully later. If the input is 2.5 kg , float(\u2026) will fail. If the input is 3.2 or even 3.0 , int(\u2026) will fail. complex(\u2026) is picky: 3-2j is fine, but 3 - 2j will fail because of the spaces around the minus sign. \ud83e\udd37\u200d\u2642\ufe0f assert is a useful python keyword. Here's what it does: If the logical statement following it is true, the line does nothing and the script continues to the next line. If the logical statement is false, python raises an error and aborts the script, displaying a scary and cryptic error message to the user. The comma and string after it are optional. If you provide them, the string will be displayed to the user as part of the error message. You can (and should) use this to tell the user specifically what they did wrong. It's not hard to write a better version of this recipe that handles invalid input more gracefully \u2014 for example, letting the user try repeatedly until they get it right, and showing a friendly message instead of a scary python error dump when they get it wrong. However, that requires python features we haven't reached yet. So for now, this recipe will suffice. If you want to ask for more than one value, just repeat this recipe more than once in your script, asking the user for each value in turn. An Example Let's write a simple little utility script that calculates a vector's \\(x\\) and \\(y\\) components from its magnitude and direction. # Imports: from math import sin, cos, radians # Ask for the magnitude: mag = input(\"Vector's magnitude (without units): \") mag = float(mag) assert mag >= 0, \"The magnitude must be non-negative!\" # Ask for the direction: angle = input(\"Vector's direction (in degrees CCW from +x axis): \") angle = float(angle) # Calculate components: x = mag * cos(radians(angle)) y = mag * sin(radians(angle)) # Report out: print(f\"=> The vector's components are ({x:.3g}, {y:.3g}).\") Self-explanatory, no?","title":"Ask for User Input"},{"location":"recipes/core/calculation/user-input/#ask-for-user-input","text":"","title":"Ask for User Input"},{"location":"recipes/core/calculation/user-input/#problem-to-solve","text":"I want to be able to run my script (or let someone else run it) with various given values, without having to edit the script each time. Editing and re-running a script isn't hard if you already have the script open in your editor. However, it's possible to run a script without opening it in an editor; one way is to simply execute python my_script.py in a terminal, assuming the script file is in the current working directory. (On some systems, you may have to execute python3 my_script.py instead.) In such a case, it's convenient to let the script ask the user for values when it runs.","title":"Problem to Solve"},{"location":"recipes/core/calculation/user-input/#recipe","text":"Python has a built-in input() function that asks the user for input. You can use this to get given values at run-time, but you'll need to do a bit of extra work to get numerical values and protect against incorrect entries. Here's the generic recipe: # Ask user for a value: variable_name = input(\"Prompt string: \") # Convert from a string to a float: # (Use `int` for an integer or `complex` for a complex number.) variable_name = float(variable_name) # Do any necessary safety-checking, such as: assert variable_name >= 0, \"Value must be non-negative.\" You can compactify this, if you want: variable_name = float(input(\"Prompt string: \")) assert variable_name >= 0, \"Value must be non-negative.\" Notes: Change variable_name to the name you want to use for the value you're getting from the user: m , v0 , or whatever. Change Prompt string to an appropriate cue to the user. Be explicit about units, if appropriate, so you don't get a mass in grams when the code is expecting kilograms, or an angle in radians when it expects degrees. Example: m1 = float(input(\"Mass 1 (in kg): )) The float(\u2026) or int(\u2026) or complex(\u2026) is necessary because the input(\u2026) function returns the user's input as a string. Your code must coerce it into the desired type. If the user enters something that's not directly interpretable as the desired type, python will raise a scary error. We'll learn how to handle this gracefully later. If the input is 2.5 kg , float(\u2026) will fail. If the input is 3.2 or even 3.0 , int(\u2026) will fail. complex(\u2026) is picky: 3-2j is fine, but 3 - 2j will fail because of the spaces around the minus sign. \ud83e\udd37\u200d\u2642\ufe0f assert is a useful python keyword. Here's what it does: If the logical statement following it is true, the line does nothing and the script continues to the next line. If the logical statement is false, python raises an error and aborts the script, displaying a scary and cryptic error message to the user. The comma and string after it are optional. If you provide them, the string will be displayed to the user as part of the error message. You can (and should) use this to tell the user specifically what they did wrong. It's not hard to write a better version of this recipe that handles invalid input more gracefully \u2014 for example, letting the user try repeatedly until they get it right, and showing a friendly message instead of a scary python error dump when they get it wrong. However, that requires python features we haven't reached yet. So for now, this recipe will suffice. If you want to ask for more than one value, just repeat this recipe more than once in your script, asking the user for each value in turn.","title":"Recipe"},{"location":"recipes/core/calculation/user-input/#an-example","text":"Let's write a simple little utility script that calculates a vector's \\(x\\) and \\(y\\) components from its magnitude and direction. # Imports: from math import sin, cos, radians # Ask for the magnitude: mag = input(\"Vector's magnitude (without units): \") mag = float(mag) assert mag >= 0, \"The magnitude must be non-negative!\" # Ask for the direction: angle = input(\"Vector's direction (in degrees CCW from +x axis): \") angle = float(angle) # Calculate components: x = mag * cos(radians(angle)) y = mag * sin(radians(angle)) # Report out: print(f\"=> The vector's components are ({x:.3g}, {y:.3g}).\") Self-explanatory, no?","title":"An Example"},{"location":"recipes/core/functions/","text":"Function Recipes Recipes for writing and using your own functions: TBW\u2026","title":"(Recipe List)"},{"location":"recipes/core/functions/#function-recipes","text":"Recipes for writing and using your own functions: TBW\u2026","title":"Function Recipes"},{"location":"recipes/core/functions/conditionals/","text":"Execute Code Conditionally Problem to Solve I want my code to decide what to do based on the circumstances. Recipe This recipe isn't specifically about writing functions \u2014 the topic of this level \u2014 but I'm including it here because it's very common for functions to include conditional logic. Execute or Not, Depending Let's say you've got a chunk of code (maybe one line, maybe several) that your program should execute under certain circumstances, but skip over under others. The solution is to wrap that chunk in an if block: if boolean_expression: # Code to execute if condition is True. # Can be multiple lines # Code to execute regardless... Replace boolean_expression with any expression that evaluates to either True or False . That could be: - a boolean variable whose value was set to True or False earlier in the program; - a comparison using one of python's comparison operators , like x < y , r >= 1 , or s == \"hello\" ; - a call to a function that returns a boolean value, such as isinstance(x, int) or email_address.endswith(\".com\") ; or - a combination of the above, using the logical operators and , or , and not . (By the way, a convenient shorthand for if x > a and x < b: is if a < x < b: .) Indentation is what distinguishes the body of the if block \u2014 the lines that will execute or not depending on the value of boolean_expression \u2014 from subsequent code that will execute either way. (The blank line I inserted just to improve human readability; the python interpreter doesn't care.) A warning about a common error: If you define a variable for the first time inside an if block, later code can't safely assume that variable will have been defined. You could get an error like NameError: name 'xxx' is not defined that doesn't show up until the first time your code is run with conditions that make boolean_expression evaluate to False . One common solution is to define the variable before the if statement, giving it some appropriate default value (which depends on the circumstances): zero, or an empty string, or whatever. Then, the code inside the if block can change the value of the variable if necessary, and later code can safely assume the variable has been defined. Execute One Chunk Or Another An alternate case is that you might want your code to execute one chunk of code if some condition holds, and a different chunk if it doesn't. That's what the optional else clause of the if statement is for: if boolean_expression: # Code to execute if condition is True. # Can be multiple lines else: # Code to execute if condition is False. # Can be multiple lines, too. # Code to execute regardless... Because one block or the other will necessarily execute, you can safely define a variable inside this if construct as long as you define it in both branches. Execute One Of Several Chunks You can also choose between more than two possible chunks of code to execute, but you'll need more than one boolean expression to do so. Here's a three-chunk version: if boolean_expression_1: # Code to execute if condition 1 is True. elif boolean_expression_2: # Code to execute if condition 1 is False and condition 2 is True. else: # Code to execute if both condition 1 and condition 2 are False. Note that if boolean_expression_1 evaluates to True , the value of boolean_expression_2 is totally irrelevant. You can have arbitrarily many elif clauses, but only one else clause, and the else clause must come last. If you have more than one elif clause, the interpreter will evaluate them in order, from top to bottom, and execute the first block of code whose condition is True . if boolean_expression_1: # Code to execute if condition 1 is True. elif boolean_expression_2: # Code to execute if condition 1 is False and condition 2 is True. elif boolean_expression_3: # Code to execute if conditions 1 and 2 are False and condition 3 is True. else: # Code to execute if all conditions are False. Consider Two Criteria Simultaneously If your code needs to take different actions depending upon both of two conditions, you've got a couple of possible approaches. The most complex case is one where you have four different possible outcomes, depending on whether each of the two conditions is True or False . Here's one approach: if boolean_expression_1 and boolean_expression_2: # Code to execute if both conditions are True. elif boolean_expression_1: # Code to execute if condition 1 is True and condition 2 is False. elif boolean_expression_2: # Code to execute if condition 1 is False and condition 2 is True. else: # Code to execute if both conditions are False. Here's a different approach, using nested if statements: if boolean_expression_1: if boolean_expression_2: # Code to execute if both conditions are True. else: # Code to execute if condition 1 is True and condition 2 is False. else: if boolean_expression_2: # Code to execute if condition 1 is False and condition 2 is True. else: # Code to execute if both conditions are False. I think the first is easier to read, but YMMV. On the other hand, the second approach lets you use a different second criterion depending on the value of the first: if boolean_expression_1: if boolean_expression_2a: # Code to execute if conditions 1 and 2a are True. else: # Code to execute if condition 1 is True and condition 2a is False. else: if boolean_expression_2b: # Code to execute if condition 1 is False and condition 2b is True. else: # Code to execute if both conditions are False. Be very careful about any kind of complex, nested conditional logic. It's very easy to write code that you think will act the way you want, but that behaves differently under some rare circumstances that fall through a hole in your logic. Even screwing up the indentation of an else can change your code's behavior. Try hard to find the simplest, \"flattest\", most linear solution you can. Examples Here's a simple example of an if block in action. (I've hard-coded the parameters V_0 and L to keep the example uncluttered.) def V(x): \"\"\" Represents the potential energy function V(x) of a quantum particle in a finite square well of depth `V_0` and width `L` centered on the origin. \"\"\" V_0 = 13.2 # eV: the L = 1.0e-9 # meters if abs(x) < L/2: V = -V_0 else: V = 0 return V (Imagine what a plot of V(x) vs. x would look like.) Of course, one can simplify this code by taking advantage of the fact that encountering a return statement immediately exits the function: def V(x): \"\"\" Represents the potential energy function V(x) of a quantum particle in a finite square well of depth `V0` and width `L` centered on the origin.= \"\"\" V_0 = 13.2 # eV: the L = 1.0e-9 # meters if abs(x) < L/2: return -V_0 return 0 Here's a function that describes velocity vs. time for a vehicle that sits at rest until \\(t = 0\\) , then accelerates at \\(2.5\\text{ m/s}^2\\) for ten seconds, and then coasts at constant speed for 15 seconds, and then slows down at \\(-1.0\\text{ m/s}^2\\) until it comes to a stop: def vehicle_velocity(t): \"\"\" Describes velocity vs. time, v(t), for a vehicle that sits at rest until $t = 0$, then accelerates at $2.5\\text{ m/s}^2$ for ten seconds, and then coasts at constant speed for 15 seconds, and then slows down at $-1.0\\text{ m/s}^2$ until it comes to a stop. Parameters: - t (float): a time in seconds. Returns: the velocity in m/s. \"\"\" if 0 <= t <= 10: # During acceleration phase: v = 0 + (2.5 m/s^2) * t return 2.5 * t elif 10 < t <= 25: # During coasting phase: constant velocity from the end of # the acceleration phase, vd = 2.5 m/s^2 * 10 s = 25 m/s return 25.0 elif 25 < t <= 40: # During deceleration phase: v = 25 m/s - (1.0 m/s^2) * (t - 25) return 25.0 - 1.0 * (t - 25) else: # t < 0 or t > 40 return 0.0 Bonus Tidbit: The Ternary Operator You can totally ignore this if you want, but for the curious: python has a \"ternary operator\" that can implement a simple if/else construct in one line. It only works when each clause is a single expression, and where the construct's objective is to return one of two values (rather than, say, doing something else like printing). Here's the template: variable_to_set = value_if_true if boolean_expression else value_if_false Here's the first example above, the potential energy function, rewritten with a single line of body code using construct: def V(x, V_0=13.2, L=1.0e09): \"\"\" Represents the potential energy function V(x) of a quantum particle in a finite square well of depth `V0` and width `L` centered on the origin. \"\"\" return -V_0 if abs(x) < L/2 else 0 Don't overuse it! Code readability can suffer. It's best when the first value is usually the value chosen, but sometimes the second is needed under rare circumstances.","title":"Execute Code Conditionally"},{"location":"recipes/core/functions/conditionals/#execute-code-conditionally","text":"","title":"Execute Code Conditionally"},{"location":"recipes/core/functions/conditionals/#problem-to-solve","text":"I want my code to decide what to do based on the circumstances.","title":"Problem to Solve"},{"location":"recipes/core/functions/conditionals/#recipe","text":"This recipe isn't specifically about writing functions \u2014 the topic of this level \u2014 but I'm including it here because it's very common for functions to include conditional logic.","title":"Recipe"},{"location":"recipes/core/functions/conditionals/#execute-or-not-depending","text":"Let's say you've got a chunk of code (maybe one line, maybe several) that your program should execute under certain circumstances, but skip over under others. The solution is to wrap that chunk in an if block: if boolean_expression: # Code to execute if condition is True. # Can be multiple lines # Code to execute regardless... Replace boolean_expression with any expression that evaluates to either True or False . That could be: - a boolean variable whose value was set to True or False earlier in the program; - a comparison using one of python's comparison operators , like x < y , r >= 1 , or s == \"hello\" ; - a call to a function that returns a boolean value, such as isinstance(x, int) or email_address.endswith(\".com\") ; or - a combination of the above, using the logical operators and , or , and not . (By the way, a convenient shorthand for if x > a and x < b: is if a < x < b: .) Indentation is what distinguishes the body of the if block \u2014 the lines that will execute or not depending on the value of boolean_expression \u2014 from subsequent code that will execute either way. (The blank line I inserted just to improve human readability; the python interpreter doesn't care.) A warning about a common error: If you define a variable for the first time inside an if block, later code can't safely assume that variable will have been defined. You could get an error like NameError: name 'xxx' is not defined that doesn't show up until the first time your code is run with conditions that make boolean_expression evaluate to False . One common solution is to define the variable before the if statement, giving it some appropriate default value (which depends on the circumstances): zero, or an empty string, or whatever. Then, the code inside the if block can change the value of the variable if necessary, and later code can safely assume the variable has been defined.","title":"Execute or Not, Depending"},{"location":"recipes/core/functions/conditionals/#execute-one-chunk-or-another","text":"An alternate case is that you might want your code to execute one chunk of code if some condition holds, and a different chunk if it doesn't. That's what the optional else clause of the if statement is for: if boolean_expression: # Code to execute if condition is True. # Can be multiple lines else: # Code to execute if condition is False. # Can be multiple lines, too. # Code to execute regardless... Because one block or the other will necessarily execute, you can safely define a variable inside this if construct as long as you define it in both branches.","title":"Execute One Chunk Or Another"},{"location":"recipes/core/functions/conditionals/#execute-one-of-several-chunks","text":"You can also choose between more than two possible chunks of code to execute, but you'll need more than one boolean expression to do so. Here's a three-chunk version: if boolean_expression_1: # Code to execute if condition 1 is True. elif boolean_expression_2: # Code to execute if condition 1 is False and condition 2 is True. else: # Code to execute if both condition 1 and condition 2 are False. Note that if boolean_expression_1 evaluates to True , the value of boolean_expression_2 is totally irrelevant. You can have arbitrarily many elif clauses, but only one else clause, and the else clause must come last. If you have more than one elif clause, the interpreter will evaluate them in order, from top to bottom, and execute the first block of code whose condition is True . if boolean_expression_1: # Code to execute if condition 1 is True. elif boolean_expression_2: # Code to execute if condition 1 is False and condition 2 is True. elif boolean_expression_3: # Code to execute if conditions 1 and 2 are False and condition 3 is True. else: # Code to execute if all conditions are False.","title":"Execute One Of Several Chunks"},{"location":"recipes/core/functions/conditionals/#consider-two-criteria-simultaneously","text":"If your code needs to take different actions depending upon both of two conditions, you've got a couple of possible approaches. The most complex case is one where you have four different possible outcomes, depending on whether each of the two conditions is True or False . Here's one approach: if boolean_expression_1 and boolean_expression_2: # Code to execute if both conditions are True. elif boolean_expression_1: # Code to execute if condition 1 is True and condition 2 is False. elif boolean_expression_2: # Code to execute if condition 1 is False and condition 2 is True. else: # Code to execute if both conditions are False. Here's a different approach, using nested if statements: if boolean_expression_1: if boolean_expression_2: # Code to execute if both conditions are True. else: # Code to execute if condition 1 is True and condition 2 is False. else: if boolean_expression_2: # Code to execute if condition 1 is False and condition 2 is True. else: # Code to execute if both conditions are False. I think the first is easier to read, but YMMV. On the other hand, the second approach lets you use a different second criterion depending on the value of the first: if boolean_expression_1: if boolean_expression_2a: # Code to execute if conditions 1 and 2a are True. else: # Code to execute if condition 1 is True and condition 2a is False. else: if boolean_expression_2b: # Code to execute if condition 1 is False and condition 2b is True. else: # Code to execute if both conditions are False. Be very careful about any kind of complex, nested conditional logic. It's very easy to write code that you think will act the way you want, but that behaves differently under some rare circumstances that fall through a hole in your logic. Even screwing up the indentation of an else can change your code's behavior. Try hard to find the simplest, \"flattest\", most linear solution you can.","title":"Consider Two Criteria Simultaneously"},{"location":"recipes/core/functions/conditionals/#examples","text":"Here's a simple example of an if block in action. (I've hard-coded the parameters V_0 and L to keep the example uncluttered.) def V(x): \"\"\" Represents the potential energy function V(x) of a quantum particle in a finite square well of depth `V_0` and width `L` centered on the origin. \"\"\" V_0 = 13.2 # eV: the L = 1.0e-9 # meters if abs(x) < L/2: V = -V_0 else: V = 0 return V (Imagine what a plot of V(x) vs. x would look like.) Of course, one can simplify this code by taking advantage of the fact that encountering a return statement immediately exits the function: def V(x): \"\"\" Represents the potential energy function V(x) of a quantum particle in a finite square well of depth `V0` and width `L` centered on the origin.= \"\"\" V_0 = 13.2 # eV: the L = 1.0e-9 # meters if abs(x) < L/2: return -V_0 return 0 Here's a function that describes velocity vs. time for a vehicle that sits at rest until \\(t = 0\\) , then accelerates at \\(2.5\\text{ m/s}^2\\) for ten seconds, and then coasts at constant speed for 15 seconds, and then slows down at \\(-1.0\\text{ m/s}^2\\) until it comes to a stop: def vehicle_velocity(t): \"\"\" Describes velocity vs. time, v(t), for a vehicle that sits at rest until $t = 0$, then accelerates at $2.5\\text{ m/s}^2$ for ten seconds, and then coasts at constant speed for 15 seconds, and then slows down at $-1.0\\text{ m/s}^2$ until it comes to a stop. Parameters: - t (float): a time in seconds. Returns: the velocity in m/s. \"\"\" if 0 <= t <= 10: # During acceleration phase: v = 0 + (2.5 m/s^2) * t return 2.5 * t elif 10 < t <= 25: # During coasting phase: constant velocity from the end of # the acceleration phase, vd = 2.5 m/s^2 * 10 s = 25 m/s return 25.0 elif 25 < t <= 40: # During deceleration phase: v = 25 m/s - (1.0 m/s^2) * (t - 25) return 25.0 - 1.0 * (t - 25) else: # t < 0 or t > 40 return 0.0","title":"Examples"},{"location":"recipes/core/functions/conditionals/#bonus-tidbit-the-ternary-operator","text":"You can totally ignore this if you want, but for the curious: python has a \"ternary operator\" that can implement a simple if/else construct in one line. It only works when each clause is a single expression, and where the construct's objective is to return one of two values (rather than, say, doing something else like printing). Here's the template: variable_to_set = value_if_true if boolean_expression else value_if_false Here's the first example above, the potential energy function, rewritten with a single line of body code using construct: def V(x, V_0=13.2, L=1.0e09): \"\"\" Represents the potential energy function V(x) of a quantum particle in a finite square well of depth `V0` and width `L` centered on the origin. \"\"\" return -V_0 if abs(x) < L/2 else 0 Don't overuse it! Code readability can suffer. It's best when the first value is usually the value chosen, but sometimes the second is needed under rare circumstances.","title":"Bonus Tidbit: The Ternary Operator"},{"location":"recipes/core/functions/factoring/","text":"","title":"Factoring"},{"location":"recipes/core/functions/globals/","text":"","title":"Globals"},{"location":"recipes/core/functions/optional-args/","text":"Make Arguments Optional Problem to Solve I want to write a function with an argument that the user can ignore unless they want to override the \"normal\" value with something else. Recipe Step 1: Define the Function With Default Values You can make any one of a function's arguments optional \u2014 meaning that calling code can either specify a value for it or omit it entirely \u2014 by supplying a default value in the function signature: def function_name(arg_1, arg_2=default_value_2): \"\"\" Template for a function that has one required and one optional argument. \"\"\" pass # Replace these two lines with actual code that does pass # something with arg_1 and arg_2. return result Replace default_value_2 with the specific value you want the function to use for the value of arg_2 if the calling code doesn't provide one. - You can specify a numeric literal, a string literal, a variable, or a more complicated python expression. - However, mind that the variable or expression will be evaluated only once, at the time the function definition is sent to the interpreter, and NOT every time the function is called. - A literal number, string, or boolean value is by far the most common kind of default value. Step 2: Call the Function With or Without the Optional Argument When calling a function with an optional argument, you can either provide a value for the optional argument or omit it. If you omit it, the function will use the default value specified in the function definition. Both of these function calls are valid: a = function_name(val_1, val_2) b = function_name(other_val_1) Elaboration: Mixing and Matching Multiple Optional Arguments If more than one argument is optional, and calling code provides fewer than the maximum number of values, which optional arguments get the passed values and which use default values? Any values provided by the calling code will be assigned to arguments from left to right according to the function signature, unless told otherwise by explicit argument names . Consider this function definition: def function_name(x=0, y=0): \"\"\" Template for a function that has two optional arguments. \"\"\" pass # Do something with x and y. return result The function can be called in any of these ways: out_1 = function_name() # Sets x to 0 and y to 0 out_2 = function_name(1) # Sets x to 1 and y to 0 out_3 = function_name(1, 2) # Sets x to 1 and y to 2 out_4 = function_name(y=2) # Sets x to 0 and y to 2 The following are also legitimate, but unnecessary. The first two might be worth writing for the sake of clarity; the third is simply confusing. out_5 = function_name(x=1) # Sets x to 1 and y to 0 out_6 = function_name(x=1, y=2) # Sets x to 1 and y to 2 out_7 = function_name(y=2, x=1) # Sets x to 1 and y to 2 Side note: It is possible to define a function that can accept any number of optional arguments, either with or without argument names in the calling code. However, that requires the use of collections that we have not yet looked at. Example import math def projectile_range(v0, theta, h=0, g=9.81): \"\"\" Calculate the range of a ballistic projectile without air resistance, launched from an arbitrary height above the ground. Parameters: - v0: The projectile's initial velocity (m/s) - theta: the projectile's launch angle above horizontal (degrees) - h: the launch height above the ground (m), defaults to zero - g: the local gravitational constant (m/s**2), defaults to Earth Returns: the horizontal distance the projectile travels, in meters, before hitting the ground. \"\"\" # Convert angle from degrees to radians. theta_rad = math.radians(theta) # Calculate range using the standard formula derived in intro physics. range_ = (v0 * math.cos(theta_rad) / g) * ( v0 * math.sin(theta_rad) + math.sqrt((v0 * math.sin(theta_rad))**2 + 2 * g * h) ) return range_ Note: This uses range_ instead of range for the name of the returned variable because range is the name of a built-in python function that we don't want to collide with. Appending an underscore is a common way of working around conflicts between desirable variable names and already-existing python names. Usage: v, theta, h = 85, 25, 10 print(\"On level ground and in the absence of air drag, the horizontal distance traveled\") print(f\"by a ballistic projectile fired with muzzle speed {v} m/s at an angle of {theta}\") print(f\"degrees above the horizontal is {projectile_range(v, theta):.2f} meters.\") print() print(f\"If the projectile is launched from a height of {h} meters above the ground,\") print(f\"the horizontal distance traveled is {projectile_range(v, theta, h):.2f} meters.\") print() g_moon = 1.625 # Moon's gravity is about 1/6th of Earth's. print(\"If launched on the moon from ground level, the distance traveled would be\") print(f\"{projectile_range(v, theta, g=g_moon):.2f} meters.\")","title":"Make Arguments Optional"},{"location":"recipes/core/functions/optional-args/#make-arguments-optional","text":"","title":"Make Arguments Optional"},{"location":"recipes/core/functions/optional-args/#problem-to-solve","text":"I want to write a function with an argument that the user can ignore unless they want to override the \"normal\" value with something else.","title":"Problem to Solve"},{"location":"recipes/core/functions/optional-args/#recipe","text":"","title":"Recipe"},{"location":"recipes/core/functions/optional-args/#step-1-define-the-function-with-default-values","text":"You can make any one of a function's arguments optional \u2014 meaning that calling code can either specify a value for it or omit it entirely \u2014 by supplying a default value in the function signature: def function_name(arg_1, arg_2=default_value_2): \"\"\" Template for a function that has one required and one optional argument. \"\"\" pass # Replace these two lines with actual code that does pass # something with arg_1 and arg_2. return result Replace default_value_2 with the specific value you want the function to use for the value of arg_2 if the calling code doesn't provide one. - You can specify a numeric literal, a string literal, a variable, or a more complicated python expression. - However, mind that the variable or expression will be evaluated only once, at the time the function definition is sent to the interpreter, and NOT every time the function is called. - A literal number, string, or boolean value is by far the most common kind of default value.","title":"Step 1: Define the Function With Default Values"},{"location":"recipes/core/functions/optional-args/#step-2-call-the-function-with-or-without-the-optional-argument","text":"When calling a function with an optional argument, you can either provide a value for the optional argument or omit it. If you omit it, the function will use the default value specified in the function definition. Both of these function calls are valid: a = function_name(val_1, val_2) b = function_name(other_val_1)","title":"Step 2: Call the Function With or Without the Optional Argument"},{"location":"recipes/core/functions/optional-args/#elaboration-mixing-and-matching-multiple-optional-arguments","text":"If more than one argument is optional, and calling code provides fewer than the maximum number of values, which optional arguments get the passed values and which use default values? Any values provided by the calling code will be assigned to arguments from left to right according to the function signature, unless told otherwise by explicit argument names . Consider this function definition: def function_name(x=0, y=0): \"\"\" Template for a function that has two optional arguments. \"\"\" pass # Do something with x and y. return result The function can be called in any of these ways: out_1 = function_name() # Sets x to 0 and y to 0 out_2 = function_name(1) # Sets x to 1 and y to 0 out_3 = function_name(1, 2) # Sets x to 1 and y to 2 out_4 = function_name(y=2) # Sets x to 0 and y to 2 The following are also legitimate, but unnecessary. The first two might be worth writing for the sake of clarity; the third is simply confusing. out_5 = function_name(x=1) # Sets x to 1 and y to 0 out_6 = function_name(x=1, y=2) # Sets x to 1 and y to 2 out_7 = function_name(y=2, x=1) # Sets x to 1 and y to 2 Side note: It is possible to define a function that can accept any number of optional arguments, either with or without argument names in the calling code. However, that requires the use of collections that we have not yet looked at.","title":"Elaboration: Mixing and Matching Multiple Optional Arguments"},{"location":"recipes/core/functions/optional-args/#example","text":"import math def projectile_range(v0, theta, h=0, g=9.81): \"\"\" Calculate the range of a ballistic projectile without air resistance, launched from an arbitrary height above the ground. Parameters: - v0: The projectile's initial velocity (m/s) - theta: the projectile's launch angle above horizontal (degrees) - h: the launch height above the ground (m), defaults to zero - g: the local gravitational constant (m/s**2), defaults to Earth Returns: the horizontal distance the projectile travels, in meters, before hitting the ground. \"\"\" # Convert angle from degrees to radians. theta_rad = math.radians(theta) # Calculate range using the standard formula derived in intro physics. range_ = (v0 * math.cos(theta_rad) / g) * ( v0 * math.sin(theta_rad) + math.sqrt((v0 * math.sin(theta_rad))**2 + 2 * g * h) ) return range_ Note: This uses range_ instead of range for the name of the returned variable because range is the name of a built-in python function that we don't want to collide with. Appending an underscore is a common way of working around conflicts between desirable variable names and already-existing python names. Usage: v, theta, h = 85, 25, 10 print(\"On level ground and in the absence of air drag, the horizontal distance traveled\") print(f\"by a ballistic projectile fired with muzzle speed {v} m/s at an angle of {theta}\") print(f\"degrees above the horizontal is {projectile_range(v, theta):.2f} meters.\") print() print(f\"If the projectile is launched from a height of {h} meters above the ground,\") print(f\"the horizontal distance traveled is {projectile_range(v, theta, h):.2f} meters.\") print() g_moon = 1.625 # Moon's gravity is about 1/6th of Earth's. print(\"If launched on the moon from ground level, the distance traveled would be\") print(f\"{projectile_range(v, theta, g=g_moon):.2f} meters.\")","title":"Example"},{"location":"recipes/core/functions/run-or-import/","text":"","title":"Run or import"},{"location":"recipes/core/functions/safety-check/","text":"Safety Check Arguments Problem to Solve I want to make my function robust against incorrect or unexpected arguments. When you write quick, short-term-use functions for yourself, you probably don't need to worry about this. However, if you're writing functions as part of a larger project, and/or for others to use, and/or for you to use in the future, sparing a line or few of code to idiot-proof them against inappropriate arguments is wise. I showed you a foretaste of this back in Ask for User Input , but now (a) it's more important, and (b) we've got better tools to deal with it. Recipe A function must guard against two basic kinds of argument error: - being passed a value of an incorrect type (like a float when an integer is expected, or a list [coming soon] instead of a single value), and - being passed a value of the right type but an inappropriate value (like a negative value for a mass). Flavor A: Type Checking To check the type of an argument, you can explicit test whether it's got the right type, like this: def demo_function(x): \"\"\" A function that requires `x` to be a float. \"\"\" if not isinstance(x, float): raise TypeError(\"x must be an int or a float\") # Proceed with the function using `x`... Wait, what's with this raise TypeError(...) stuff?!? \ud83e\uddd0 That's the python way of triggering an error message to the user. raise says `An error has occurred, and unless the code that's called me can do something smart to handle it, the user had better be informed!' TypeError indicates the kind of error that's occurred. Python has many built-in error types for you to choose from and you can even define your own. The two you're most likely to need for now, however, are: TypeError : for when an object of inappropriate type is encountered. ValueError : for when an object of the right type but inappropriate value is encountered. \"x must be an int or a float\" is the message that will be displayed to the user. You can write whatever you like here, but it's good to be specific about what's wrong so the poor user (likely you) has some idea what to do about it. Sometimes, checking an argument value's type this way is the right approach. However, very often we don't actually care what the type of the argument is, so long as we can use it for our purposes. For example, if we want a float, so what if we're given an integer? We can use that just fine anywhere a decimal number is needed! So, instead of checking the type, we just coerce it to an adequate type: def demo_function(x): \"\"\" A function that requires `x` to be interpretable as a float. \"\"\" x = float(x) # Proceed with the function using `x`... If the user (or other code) calls demo_function with any kind of value that can be turned into a float \u2014 such as a float, an integer, or a string representing a legitimate floating-point literal like \"3.2e4\" \u2014 it'll get turned into a float, and the function can happily proceed. OTOH, if the function receives something that can't be coerced into a float, python will raise a ValueError with a message like could not convert string to float: '2.5 m/s' . You don't need to bother with your own raise statement. By the way, there's a third approach: Don't bother to check or coerce the argument at all. Just use it, and let python raise an error when it reaches a point where the argument's type is problematic. Depending on the situation, this might be fine, or it might open the door to hard-to-interpret errors or hard-to-fix bugs. Use your judgment. In particular, if it's obvious that an incorrect argument type will quickly cause an error to occur, you're probably okay omitting the explicit check. However, if an incorrect type might cause unintended behavior rather than an error, explicitly checking becomes essential. Forward reference: A common situation when a wrong type won't raise an error is when code expects a list (which we'll get to soon), but is given a string instead. If x represents a list, x[3] produces the fourth element in the list. However, if x represents a string, x[3] produces the fourth character in the string \u2014 a totally different thing, and potentially very confusing, especially if the list is supposed to be a list of strings! Flavor B: Value Checking This is straightforward: Use an if statement to test the argument's value with the appropriate boolean expressions, and raise a ValueError if the test fails. def demo_function(x): \"\"\" A function that requires `x` to be a positive number. \"\"\" if x <= 0: raise ValueError(\"x must be positive!\") # Proceed with the function using `x`... If your restrictions on the argument's value are more complicated, you can combine boolean expressions with and , or , and not , and/or you can use a multi-clause if/elif/\u2026 construct. If you need to check multiple arguments, just put the checks one after another in the function body. If more than one is invalid, only the first will be caught, but that's usually enough for the user to make progress. By the way, a slightly shorter and quicker way to accomplish this is to use the assert statement introduced earlier. For example: def demo_function(x): \"\"\" A function that requires `x` to be a positive number. \"\"\" assert x > 0, \"x must be positive!\" # Proceed with the function using `x`... The only significant practical difference here is that the user sees AssertionError instead of ValueError . That probably doesn't matter if a human gets the message, but sometimes the calling code will be written to \"catch\" certain errors and respond automatically. Philosophically, however, programmers generally see assertions (using assert ) as safety-checks inside their code that should never raise an error unless something has gone wrong inside the program, whereas exceptions (using raise ) are for when the user or external code has done something wrong. For the purposes of this course, I'll try to be explicit when an assigment cares what type of exception gets raised; otherwise, do as you see fit. Examples Here's a common situation: a function involves code that demands an integer for something, such as the number of time-steps of a simulation to run. In order","title":"Safety Check Arguments"},{"location":"recipes/core/functions/safety-check/#safety-check-arguments","text":"","title":"Safety Check Arguments"},{"location":"recipes/core/functions/safety-check/#problem-to-solve","text":"I want to make my function robust against incorrect or unexpected arguments. When you write quick, short-term-use functions for yourself, you probably don't need to worry about this. However, if you're writing functions as part of a larger project, and/or for others to use, and/or for you to use in the future, sparing a line or few of code to idiot-proof them against inappropriate arguments is wise. I showed you a foretaste of this back in Ask for User Input , but now (a) it's more important, and (b) we've got better tools to deal with it.","title":"Problem to Solve"},{"location":"recipes/core/functions/safety-check/#recipe","text":"A function must guard against two basic kinds of argument error: - being passed a value of an incorrect type (like a float when an integer is expected, or a list [coming soon] instead of a single value), and - being passed a value of the right type but an inappropriate value (like a negative value for a mass).","title":"Recipe"},{"location":"recipes/core/functions/safety-check/#flavor-a-type-checking","text":"To check the type of an argument, you can explicit test whether it's got the right type, like this: def demo_function(x): \"\"\" A function that requires `x` to be a float. \"\"\" if not isinstance(x, float): raise TypeError(\"x must be an int or a float\") # Proceed with the function using `x`... Wait, what's with this raise TypeError(...) stuff?!? \ud83e\uddd0 That's the python way of triggering an error message to the user. raise says `An error has occurred, and unless the code that's called me can do something smart to handle it, the user had better be informed!' TypeError indicates the kind of error that's occurred. Python has many built-in error types for you to choose from and you can even define your own. The two you're most likely to need for now, however, are: TypeError : for when an object of inappropriate type is encountered. ValueError : for when an object of the right type but inappropriate value is encountered. \"x must be an int or a float\" is the message that will be displayed to the user. You can write whatever you like here, but it's good to be specific about what's wrong so the poor user (likely you) has some idea what to do about it. Sometimes, checking an argument value's type this way is the right approach. However, very often we don't actually care what the type of the argument is, so long as we can use it for our purposes. For example, if we want a float, so what if we're given an integer? We can use that just fine anywhere a decimal number is needed! So, instead of checking the type, we just coerce it to an adequate type: def demo_function(x): \"\"\" A function that requires `x` to be interpretable as a float. \"\"\" x = float(x) # Proceed with the function using `x`... If the user (or other code) calls demo_function with any kind of value that can be turned into a float \u2014 such as a float, an integer, or a string representing a legitimate floating-point literal like \"3.2e4\" \u2014 it'll get turned into a float, and the function can happily proceed. OTOH, if the function receives something that can't be coerced into a float, python will raise a ValueError with a message like could not convert string to float: '2.5 m/s' . You don't need to bother with your own raise statement. By the way, there's a third approach: Don't bother to check or coerce the argument at all. Just use it, and let python raise an error when it reaches a point where the argument's type is problematic. Depending on the situation, this might be fine, or it might open the door to hard-to-interpret errors or hard-to-fix bugs. Use your judgment. In particular, if it's obvious that an incorrect argument type will quickly cause an error to occur, you're probably okay omitting the explicit check. However, if an incorrect type might cause unintended behavior rather than an error, explicitly checking becomes essential. Forward reference: A common situation when a wrong type won't raise an error is when code expects a list (which we'll get to soon), but is given a string instead. If x represents a list, x[3] produces the fourth element in the list. However, if x represents a string, x[3] produces the fourth character in the string \u2014 a totally different thing, and potentially very confusing, especially if the list is supposed to be a list of strings!","title":"Flavor A: Type Checking"},{"location":"recipes/core/functions/safety-check/#flavor-b-value-checking","text":"This is straightforward: Use an if statement to test the argument's value with the appropriate boolean expressions, and raise a ValueError if the test fails. def demo_function(x): \"\"\" A function that requires `x` to be a positive number. \"\"\" if x <= 0: raise ValueError(\"x must be positive!\") # Proceed with the function using `x`... If your restrictions on the argument's value are more complicated, you can combine boolean expressions with and , or , and not , and/or you can use a multi-clause if/elif/\u2026 construct. If you need to check multiple arguments, just put the checks one after another in the function body. If more than one is invalid, only the first will be caught, but that's usually enough for the user to make progress. By the way, a slightly shorter and quicker way to accomplish this is to use the assert statement introduced earlier. For example: def demo_function(x): \"\"\" A function that requires `x` to be a positive number. \"\"\" assert x > 0, \"x must be positive!\" # Proceed with the function using `x`... The only significant practical difference here is that the user sees AssertionError instead of ValueError . That probably doesn't matter if a human gets the message, but sometimes the calling code will be written to \"catch\" certain errors and respond automatically. Philosophically, however, programmers generally see assertions (using assert ) as safety-checks inside their code that should never raise an error unless something has gone wrong inside the program, whereas exceptions (using raise ) are for when the user or external code has done something wrong. For the purposes of this course, I'll try to be explicit when an assigment cares what type of exception gets raised; otherwise, do as you see fit.","title":"Flavor B: Value Checking"},{"location":"recipes/core/functions/safety-check/#examples","text":"Here's a common situation: a function involves code that demands an integer for something, such as the number of time-steps of a simulation to run. In order","title":"Examples"},{"location":"recipes/core/functions/writing-functions/","text":"Write Your Own Functions Problem to Solve I want to easily reuse a particular calculation multiple times, with different givens. Introduction IMHO, the biggest challenge facing coders of any level, writing code for any kind of application, is managing the complexity of the task. In any program beyond the truly trivial (or larger software ecosystem!), there is simply more going on \u2014 more bits of functionality, more state information to track, more causal interconnections \u2014 than any human being can hold in their head. Without some powerful methodologies for managing the complexity, the task can be nearly impossible; and even if one completes a program that seems to work, it's really hard to be confident it's bug-free and reliable. Defining your own functions that wrap up well-defined chunks of functionality into reusable units is one of the most powerful tools programmers have devised to deal with this. The basic idea is that one takes a sub-task of manageable complexity and writes code to accomplish it, in a way that is as decoupled from the rest of the larger problem as possible. That chunk of code is packaged in such a way that other code can refer to it and use it as a single python expression \u2014 a \"function\". In that way, once the function has been written and tested, the programmer can forget about the complexity it encapsulates, and for cognitive load purposes it becomes a single \"thing\". Here's an example: How do you think the computer calculates, say, math.sin(0.143) when you put that into your program? Deep in the code for the math module is a function definition that instructs the computer to calculate a fairly complicated series approximation to the sine, with lots of logic to accurately and efficiently handle edge cases like very tiny angles. Do you really want to have to think about all of that every time you need to take the sine of something? Nope\u2026 Okay, enough philosophy. Let's get to the nuts-and-bolts. Recipe Step 1: Define The Function Before your code can use a function, it has to define a function. If you want do_thing(3) to mean something to the python interpreter when it encounters that expression, you first have to send code to the interpreter that tells it what that expression means. This is the template for a function definition : def function_name(arg_1, arg_2, \u2026): \"\"\" Here goes a descriptive comment telling a human reader what the function does, including what the various arguments will affect and what kind of value it will return. \"\"\" pass # REPLACE this with the code that will implement your function's pass # behavior, in as many or few lines as is required. return result_to_return # Other code that follows here is NOT part of the function. Notes: The first line, beginning with def , is called the function signature . It specifies everything that client code \u2014 code that uses this function \u2014 needs to know about how to call it. Replace function_name with a name for your function that communicates, fairly clearly, what the function's purpose is. In python, function names must follow the same rules as variable names: They must start with a letter, and consist only of letters, digits, and the underscore character. (Technically, the first character can be an underscore, but the python convention reserves this for special-purpose functions we don't need to get into here.) Python culture goes farther, recommending that function names begin with lowercase letters and use \"snake_case\", (an underscore between words) rather than \"camelCase\" (capital letter to start new words). Replace arg_1, arg_2, \u2026 with a comma-separated list of arguments that will be given specific values when the function is called (used, executed). The names you put here will become variables \"holding\" those values that the body of the function can refer to. The names you use here can be different than whatever variables \"outside the function\" might be used to hand value to the function. Code inside the function shouldn't care about the details of code outside the function, and vice-versa. A function can specify that it wants no arguments, or one, or two, or more\u2026 Or it can even be flexible in how many it requires (see below). The descriptive comment just below the function signature line is called the docstring . The docstring is optional, but it's worth writing. Someone else trying to figure out your code, or maybe even future you, will be very glad you took the time. It's really good habit to write this comment FIRST, before you start writing the actual code. That can help you clarify in your own mind what, precisely, the function should do. BTW, the triple-quotes bound a special kind of string literal that can span multiple lines. Other than the line breaks, it's just a normal string, like \"blah blah\" . In python, indentation matters! The only thing telling the python interpreter which subsequent lines belong to the function definition and which are part of some other, subsequent code is the fact that the body of the function is indented, and all by the same amount. Warning: multiple space characters may look like the same indentation as a tab character, but are not the same as far as the python interpreter is concerned. Fortunately, most modern code editors will proactively replace tabs with spaces for you, protecting you from this potentially infuriating source of mystery errors. The code in the function body is not evaluated when the function definition is sent to the interpreter! Rather, it is stashed, and is later executed when the function is called (used) by other code, using whatever argument values have been specified at that time. Replace result_to_return with an expression that will evaluate to the result you want your function to return to whatever code called it. You can replace result_to_return with the name of a variable that is defined and given a value in the function. Alternatively, you can replace it with an expression that will be evaluated when the value is to be returned. It's even possible for a function to have no body at all other than the return line, and still be useful if that return line contains a calculation. Some functions don't return anything, but have some desirable side effect such as writing data to a file or printing text to the screen. Those can either return None or have no return line at all. Step 2: Call the Function Once your code has defined a function, any code that is subsequently executed can call (use) it simply by giving its name, followed by parentheses containing a list of values to be passed to the function's arguments: some_variable = function_name(value_1, value_2, \u2026) different_function( function_name(other_value_1, other_value_2, \u2026) ) Note a critical difference: In python, function_name by itself is a reference to the function's code, whereas function_name(\u2026) causes the function to execute (whether or not the parentheses are empty). The presence of the parentheses are the trigger that says \"execute this\". Black-belt tidbit: In python, you can pass a function around as an object, just like you can with a variable, by using its name without parentheses. The function's body is its \"value\" in the way that a number or string is a regular variable's value. That means you can actually pass a function as an argument to another function, and that other function can execute the one it's been given without knowing what it actually does! This is called a callback , and is a very useful technique for \"decoupling\" different portions of a code. In essence, it lets you pass \"actions\" around in the same way that you pass \"values\" around. Elaboration: Return Multiple Values A recipe can easily return two or three (or, in principle, more) separate values via the \"comma trick\": def function_name(some_arg): \"\"\" Template for a function that returns two values \"\"\" pass # Calculate result_1 and result_2 in some way. return result_1, result_2 To catch them, calling code also uses the comma trick: thing_1, thing_2 = function_name(val_for_some_arg) Notes: Technically, the function only returning one \"value\", but that value is something called a tuple that packages multiple values together. The comma-separated list on the left-hand side of the calling code's assignment statement unpacks the tuple into separate variables. We'll look at tuples more closely in an upcoming level. There is, in principle, no limit to the number of values a function can return this way. However, if you're going to return more than two or three, you're probably better off wrapping them in one of python's collections , which are the focus of two upcoming levels. Similarly, if the function needs to be flexible about how many values to return, the comma trick won't suffice and you'll need a collection object. Some Examples These examples are pretty trivial, mostly because we haven't yet introduced the python structures (such as conditional logic and iteration) that get used in more complicated ones. Please take them in that spirit. No Arguments Functions that take no arguments are uncommon, but are occasionally convenient. For example: from random import randint def roll_3d6(): \"\"\" Simulate rolling three six-sided dice and return the sum. \"\"\" return randint(1, 6) + randint(1, 6) + randint(1, 6) One Argument from math import degrees def degrees_bounded(angle_in_rad): \"\"\" Convert the given angle in radians to degrees, within the range [0, 360). Angles 360\u02da or greater get mapped to the equivalent angle within the first revolution, and negative angles get mapped to the equivalent positive angle. \"\"\" return degres(angle) % 360 Two Arguments def kinetic_energy(m, v): \"\"\" Calculate the kinetic energy of an object with the given mass and velocity. \"\"\" return 0.5 * mass * velocity**2 Multiple Return Values def cartesian_to_polar(x, y): \"\"\" Converts the given 2D Cartesian coordinates to polar coordinates. Returns the polar coordinates as (r, theta) with theta in radians. \"\"\" r = math.sqrt(x**2 + y**2) theta = math.atan2(y, x) return r, theta Note: This function body could be rewritten as a one-liner, def cartesian_to_polar(x, y): \"\"\" Converts the given 2D Cartesian coordinates to polar coordinates. Returns the polar coordinates as (r, theta) with theta in radians. \"\"\" return math.sqrt(x**2 + y**2), math.atan2(y, x) but sacrificing readability for brevity is rarely worthwhile.","title":"Write Your Own Functions"},{"location":"recipes/core/functions/writing-functions/#write-your-own-functions","text":"","title":"Write Your Own Functions"},{"location":"recipes/core/functions/writing-functions/#problem-to-solve","text":"I want to easily reuse a particular calculation multiple times, with different givens.","title":"Problem to Solve"},{"location":"recipes/core/functions/writing-functions/#introduction","text":"IMHO, the biggest challenge facing coders of any level, writing code for any kind of application, is managing the complexity of the task. In any program beyond the truly trivial (or larger software ecosystem!), there is simply more going on \u2014 more bits of functionality, more state information to track, more causal interconnections \u2014 than any human being can hold in their head. Without some powerful methodologies for managing the complexity, the task can be nearly impossible; and even if one completes a program that seems to work, it's really hard to be confident it's bug-free and reliable. Defining your own functions that wrap up well-defined chunks of functionality into reusable units is one of the most powerful tools programmers have devised to deal with this. The basic idea is that one takes a sub-task of manageable complexity and writes code to accomplish it, in a way that is as decoupled from the rest of the larger problem as possible. That chunk of code is packaged in such a way that other code can refer to it and use it as a single python expression \u2014 a \"function\". In that way, once the function has been written and tested, the programmer can forget about the complexity it encapsulates, and for cognitive load purposes it becomes a single \"thing\". Here's an example: How do you think the computer calculates, say, math.sin(0.143) when you put that into your program? Deep in the code for the math module is a function definition that instructs the computer to calculate a fairly complicated series approximation to the sine, with lots of logic to accurately and efficiently handle edge cases like very tiny angles. Do you really want to have to think about all of that every time you need to take the sine of something? Nope\u2026 Okay, enough philosophy. Let's get to the nuts-and-bolts.","title":"Introduction"},{"location":"recipes/core/functions/writing-functions/#recipe","text":"","title":"Recipe"},{"location":"recipes/core/functions/writing-functions/#step-1-define-the-function","text":"Before your code can use a function, it has to define a function. If you want do_thing(3) to mean something to the python interpreter when it encounters that expression, you first have to send code to the interpreter that tells it what that expression means. This is the template for a function definition : def function_name(arg_1, arg_2, \u2026): \"\"\" Here goes a descriptive comment telling a human reader what the function does, including what the various arguments will affect and what kind of value it will return. \"\"\" pass # REPLACE this with the code that will implement your function's pass # behavior, in as many or few lines as is required. return result_to_return # Other code that follows here is NOT part of the function. Notes: The first line, beginning with def , is called the function signature . It specifies everything that client code \u2014 code that uses this function \u2014 needs to know about how to call it. Replace function_name with a name for your function that communicates, fairly clearly, what the function's purpose is. In python, function names must follow the same rules as variable names: They must start with a letter, and consist only of letters, digits, and the underscore character. (Technically, the first character can be an underscore, but the python convention reserves this for special-purpose functions we don't need to get into here.) Python culture goes farther, recommending that function names begin with lowercase letters and use \"snake_case\", (an underscore between words) rather than \"camelCase\" (capital letter to start new words). Replace arg_1, arg_2, \u2026 with a comma-separated list of arguments that will be given specific values when the function is called (used, executed). The names you put here will become variables \"holding\" those values that the body of the function can refer to. The names you use here can be different than whatever variables \"outside the function\" might be used to hand value to the function. Code inside the function shouldn't care about the details of code outside the function, and vice-versa. A function can specify that it wants no arguments, or one, or two, or more\u2026 Or it can even be flexible in how many it requires (see below). The descriptive comment just below the function signature line is called the docstring . The docstring is optional, but it's worth writing. Someone else trying to figure out your code, or maybe even future you, will be very glad you took the time. It's really good habit to write this comment FIRST, before you start writing the actual code. That can help you clarify in your own mind what, precisely, the function should do. BTW, the triple-quotes bound a special kind of string literal that can span multiple lines. Other than the line breaks, it's just a normal string, like \"blah blah\" . In python, indentation matters! The only thing telling the python interpreter which subsequent lines belong to the function definition and which are part of some other, subsequent code is the fact that the body of the function is indented, and all by the same amount. Warning: multiple space characters may look like the same indentation as a tab character, but are not the same as far as the python interpreter is concerned. Fortunately, most modern code editors will proactively replace tabs with spaces for you, protecting you from this potentially infuriating source of mystery errors. The code in the function body is not evaluated when the function definition is sent to the interpreter! Rather, it is stashed, and is later executed when the function is called (used) by other code, using whatever argument values have been specified at that time. Replace result_to_return with an expression that will evaluate to the result you want your function to return to whatever code called it. You can replace result_to_return with the name of a variable that is defined and given a value in the function. Alternatively, you can replace it with an expression that will be evaluated when the value is to be returned. It's even possible for a function to have no body at all other than the return line, and still be useful if that return line contains a calculation. Some functions don't return anything, but have some desirable side effect such as writing data to a file or printing text to the screen. Those can either return None or have no return line at all.","title":"Step 1: Define The Function"},{"location":"recipes/core/functions/writing-functions/#step-2-call-the-function","text":"Once your code has defined a function, any code that is subsequently executed can call (use) it simply by giving its name, followed by parentheses containing a list of values to be passed to the function's arguments: some_variable = function_name(value_1, value_2, \u2026) different_function( function_name(other_value_1, other_value_2, \u2026) ) Note a critical difference: In python, function_name by itself is a reference to the function's code, whereas function_name(\u2026) causes the function to execute (whether or not the parentheses are empty). The presence of the parentheses are the trigger that says \"execute this\". Black-belt tidbit: In python, you can pass a function around as an object, just like you can with a variable, by using its name without parentheses. The function's body is its \"value\" in the way that a number or string is a regular variable's value. That means you can actually pass a function as an argument to another function, and that other function can execute the one it's been given without knowing what it actually does! This is called a callback , and is a very useful technique for \"decoupling\" different portions of a code. In essence, it lets you pass \"actions\" around in the same way that you pass \"values\" around.","title":"Step 2: Call the Function"},{"location":"recipes/core/functions/writing-functions/#elaboration-return-multiple-values","text":"A recipe can easily return two or three (or, in principle, more) separate values via the \"comma trick\": def function_name(some_arg): \"\"\" Template for a function that returns two values \"\"\" pass # Calculate result_1 and result_2 in some way. return result_1, result_2 To catch them, calling code also uses the comma trick: thing_1, thing_2 = function_name(val_for_some_arg) Notes: Technically, the function only returning one \"value\", but that value is something called a tuple that packages multiple values together. The comma-separated list on the left-hand side of the calling code's assignment statement unpacks the tuple into separate variables. We'll look at tuples more closely in an upcoming level. There is, in principle, no limit to the number of values a function can return this way. However, if you're going to return more than two or three, you're probably better off wrapping them in one of python's collections , which are the focus of two upcoming levels. Similarly, if the function needs to be flexible about how many values to return, the comma trick won't suffice and you'll need a collection object.","title":"Elaboration: Return Multiple Values"},{"location":"recipes/core/functions/writing-functions/#some-examples","text":"These examples are pretty trivial, mostly because we haven't yet introduced the python structures (such as conditional logic and iteration) that get used in more complicated ones. Please take them in that spirit.","title":"Some Examples"},{"location":"recipes/core/functions/writing-functions/#no-arguments","text":"Functions that take no arguments are uncommon, but are occasionally convenient. For example: from random import randint def roll_3d6(): \"\"\" Simulate rolling three six-sided dice and return the sum. \"\"\" return randint(1, 6) + randint(1, 6) + randint(1, 6)","title":"No Arguments"},{"location":"recipes/core/functions/writing-functions/#one-argument","text":"from math import degrees def degrees_bounded(angle_in_rad): \"\"\" Convert the given angle in radians to degrees, within the range [0, 360). Angles 360\u02da or greater get mapped to the equivalent angle within the first revolution, and negative angles get mapped to the equivalent positive angle. \"\"\" return degres(angle) % 360","title":"One Argument"},{"location":"recipes/core/functions/writing-functions/#two-arguments","text":"def kinetic_energy(m, v): \"\"\" Calculate the kinetic energy of an object with the given mass and velocity. \"\"\" return 0.5 * mass * velocity**2","title":"Two Arguments"},{"location":"recipes/core/functions/writing-functions/#multiple-return-values","text":"def cartesian_to_polar(x, y): \"\"\" Converts the given 2D Cartesian coordinates to polar coordinates. Returns the polar coordinates as (r, theta) with theta in radians. \"\"\" r = math.sqrt(x**2 + y**2) theta = math.atan2(y, x) return r, theta Note: This function body could be rewritten as a one-liner, def cartesian_to_polar(x, y): \"\"\" Converts the given 2D Cartesian coordinates to polar coordinates. Returns the polar coordinates as (r, theta) with theta in radians. \"\"\" return math.sqrt(x**2 + y**2), math.atan2(y, x) but sacrificing readability for brevity is rarely worthwhile.","title":"Multiple Return Values"},{"location":"recipes/core/iteration/","text":"Function Recipes Recipes for iterating over, looping through, and repeating stuff: TBW\u2026","title":"(Recipe List)"},{"location":"recipes/core/iteration/#function-recipes","text":"Recipes for iterating over, looping through, and repeating stuff: TBW\u2026","title":"Function Recipes"},{"location":"recipes/core/iteration/monte-carlo/","text":"","title":"Monte carlo"},{"location":"recipes/core/iteration/ranges/","text":"","title":"Ranges"},{"location":"recipes/core/iteration/skip-break/","text":"","title":"Skip break"},{"location":"recipes/core/iteration/while/","text":"","title":"While"},{"location":"recipes/core/sets-dicts/","text":"Set and Dictionary Recipes Recipes for creating and using some other, specialized collections ( sets and dictionaries ): TBW\u2026","title":"(Recipe List)"},{"location":"recipes/core/sets-dicts/#set-and-dictionary-recipes","text":"Recipes for creating and using some other, specialized collections ( sets and dictionaries ): TBW\u2026","title":"Set and Dictionary Recipes"},{"location":"recipes/core/sets-dicts/counters/","text":"","title":"Counters"},{"location":"recipes/core/sets-dicts/dict-iteration/","text":"","title":"Dict iteration"},{"location":"recipes/core/sets-dicts/dicts/","text":"","title":"Dicts"},{"location":"recipes/core/sets-dicts/overlap/","text":"","title":"Overlap"},{"location":"recipes/core/sets-dicts/sets/","text":"","title":"Sets"},{"location":"recipes/core/tuples-lists/","text":"Tuple and List Recipes Recipes for creating and using ordered sequences of things ( tuples and lists ): TBW\u2026","title":"(Recipe List)"},{"location":"recipes/core/tuples-lists/#tuple-and-list-recipes","text":"Recipes for creating and using ordered sequences of things ( tuples and lists ): TBW\u2026","title":"Tuple and List Recipes"},{"location":"recipes/core/tuples-lists/combine-lists/","text":"","title":"Combine lists"},{"location":"recipes/core/tuples-lists/find-in-list/","text":"","title":"Find in list"},{"location":"recipes/core/tuples-lists/iterate/","text":"","title":"Iterate"},{"location":"recipes/core/tuples-lists/lists/","text":"","title":"Lists"},{"location":"recipes/core/tuples-lists/set-or-append/","text":"","title":"Set or append"},{"location":"recipes/core/tuples-lists/tuples/","text":"","title":"Tuples"},{"location":"recipes/core/workflow/","text":"Workflow Recipes The \"recipes\" in this group are all \"procedural\", meaning that they consist of a set of steps to follow rather than a particular bit of code to use. Some must be followed precisely as stated, and others just illustrate tools and skills you can mix-and-match as needed. Some of these recipes include one-time-only steps that you should only need to do once, or perhaps once every so often, mixed in with steps you'll do every time you follow the recipe. I'll try to be clear about which steps are once-only. Overall, these recipes \u2014 or rather, the process of applying and getting comfortable with them \u2014 will familiarize you with key elements of the course \"tech stack\": the GitHub website and our course \"org\" within it; Beskar , the Linux server you'll use for all your coding work; JupyterHub , the browser-based coding environment that will be your \"front door\" and primary workbench on Beskar; and a bit of the behind-the-scenes plumbing on Beskar. The Recipes Here are some recipes for basic processes required to use the course \"tech stack\" to get, do, and submit assignments. (It is very much not an accident that these same processes are widely useful in computational physics, and well beyond it into all kinds of software development work. \ud83d\ude0f) Find and Fork a Repo on GitHub : I want to make my own copy of a course level repo (the \"package\" that assignments come bundled in) so that I can start working on it. Log Into Beskar and JupyterLab : I want to work on course assignments (or maybe apply what I'm learning to another course or project, or just noodle around with python). Open and Use the System Terminal : I want to do something that must be done, or is easiest to do, directly with Beskar's operating system and filesystem (\"behind the scenes\") rather than in JupyterHub. Authenticate Your Beskar Account with GitHub : I want to be able to copy course level (and other) repos from GitHub to Beskar without having to enter my GitHub username and password each time. Clone a Repo to Beskar : I want to copy my fork of a course level repo from GitHub to Beskar so that I can start working on it in JupyterHub. Edit a File in an Assignment : I want to make changes to the name or content of a file that came with a course level repo. Commit and Push Changes to GitHub : I want to make a snapshot of my work so far in case I need to roll back changes, and copy the current repo state back to GitHub for safekeeping. Execute Interactive Python : I want to execute python commands interactively (perhaps to do a one-off calculation or just try things out). Submit a Level via Commit-Push-Pullreq : I want to submit a repo (level) of completed work for course credit.","title":"(Recipe List)"},{"location":"recipes/core/workflow/#workflow-recipes","text":"The \"recipes\" in this group are all \"procedural\", meaning that they consist of a set of steps to follow rather than a particular bit of code to use. Some must be followed precisely as stated, and others just illustrate tools and skills you can mix-and-match as needed. Some of these recipes include one-time-only steps that you should only need to do once, or perhaps once every so often, mixed in with steps you'll do every time you follow the recipe. I'll try to be clear about which steps are once-only. Overall, these recipes \u2014 or rather, the process of applying and getting comfortable with them \u2014 will familiarize you with key elements of the course \"tech stack\": the GitHub website and our course \"org\" within it; Beskar , the Linux server you'll use for all your coding work; JupyterHub , the browser-based coding environment that will be your \"front door\" and primary workbench on Beskar; and a bit of the behind-the-scenes plumbing on Beskar.","title":"Workflow Recipes"},{"location":"recipes/core/workflow/#the-recipes","text":"Here are some recipes for basic processes required to use the course \"tech stack\" to get, do, and submit assignments. (It is very much not an accident that these same processes are widely useful in computational physics, and well beyond it into all kinds of software development work. \ud83d\ude0f) Find and Fork a Repo on GitHub : I want to make my own copy of a course level repo (the \"package\" that assignments come bundled in) so that I can start working on it. Log Into Beskar and JupyterLab : I want to work on course assignments (or maybe apply what I'm learning to another course or project, or just noodle around with python). Open and Use the System Terminal : I want to do something that must be done, or is easiest to do, directly with Beskar's operating system and filesystem (\"behind the scenes\") rather than in JupyterHub. Authenticate Your Beskar Account with GitHub : I want to be able to copy course level (and other) repos from GitHub to Beskar without having to enter my GitHub username and password each time. Clone a Repo to Beskar : I want to copy my fork of a course level repo from GitHub to Beskar so that I can start working on it in JupyterHub. Edit a File in an Assignment : I want to make changes to the name or content of a file that came with a course level repo. Commit and Push Changes to GitHub : I want to make a snapshot of my work so far in case I need to roll back changes, and copy the current repo state back to GitHub for safekeeping. Execute Interactive Python : I want to execute python commands interactively (perhaps to do a one-off calculation or just try things out). Submit a Level via Commit-Push-Pullreq : I want to submit a repo (level) of completed work for course credit.","title":"The Recipes"},{"location":"recipes/core/workflow/authenticate-to-github/","text":"Authenticate Your Beskar Account with GitHub Problem to Solve I want to be able to copy course level (and other) repos from GitHub to Beskar without having to enter my GitHub username and password each time. Recipe","title":"Authenticate Your Beskar Account with GitHub"},{"location":"recipes/core/workflow/authenticate-to-github/#authenticate-your-beskar-account-with-github","text":"","title":"Authenticate Your Beskar Account with GitHub"},{"location":"recipes/core/workflow/authenticate-to-github/#problem-to-solve","text":"I want to be able to copy course level (and other) repos from GitHub to Beskar without having to enter my GitHub username and password each time.","title":"Problem to Solve"},{"location":"recipes/core/workflow/authenticate-to-github/#recipe","text":"","title":"Recipe"},{"location":"recipes/core/workflow/beskar-and-jlab/","text":"Log Into Beskar and JupyterLab Problem to Solve I want to work on course assignments (or maybe apply what I'm learning to another course or project, or just noodle around with python). Recipe (This one is really quick and easy. It doesn't really deserve to be called a \"recipe\", but it's an important little step and I needed somewhere to put this information.) Part A: Log Into Beskar Point your web browser to https://beskar.uncg.edu/ . That should take you to a \"sign in\" page. Enter your UNCG user ID for \"Username\". Enter your Beskar password\u2026 The very first time you do this, whatever you enter will become your Beskar password. So, choose it carefully, and type it very carefully . You might consider using your UNCG password for this, too. That is at least guaranteed to be (1) hiqh-quality, and (2) something you'll remember. Click the \"Sign In\" button. That should take you to the main interface of JupyterLab, our coding environment. Part B: Welcome to JupyterLab","title":"Log Into Beskar and JupyterLab"},{"location":"recipes/core/workflow/beskar-and-jlab/#log-into-beskar-and-jupyterlab","text":"","title":"Log Into Beskar and JupyterLab"},{"location":"recipes/core/workflow/beskar-and-jlab/#problem-to-solve","text":"I want to work on course assignments (or maybe apply what I'm learning to another course or project, or just noodle around with python).","title":"Problem to Solve"},{"location":"recipes/core/workflow/beskar-and-jlab/#recipe","text":"(This one is really quick and easy. It doesn't really deserve to be called a \"recipe\", but it's an important little step and I needed somewhere to put this information.)","title":"Recipe"},{"location":"recipes/core/workflow/beskar-and-jlab/#part-a-log-into-beskar","text":"Point your web browser to https://beskar.uncg.edu/ . That should take you to a \"sign in\" page. Enter your UNCG user ID for \"Username\". Enter your Beskar password\u2026 The very first time you do this, whatever you enter will become your Beskar password. So, choose it carefully, and type it very carefully . You might consider using your UNCG password for this, too. That is at least guaranteed to be (1) hiqh-quality, and (2) something you'll remember. Click the \"Sign In\" button. That should take you to the main interface of JupyterLab, our coding environment.","title":"Part A: Log Into Beskar"},{"location":"recipes/core/workflow/beskar-and-jlab/#part-b-welcome-to-jupyterlab","text":"","title":"Part B: Welcome to JupyterLab"},{"location":"recipes/core/workflow/clone-to-beskar/","text":"Clone a Repo to Beskar Problem to Solve I want to copy my fork of a course level repo from GitHub to Beskar so that I can start working on it in JupyterHub. Recipe Old Version Part B: Clone it to Beskar This part makes a copy of the assignment repo on the server you'll do your actual coding work on. Locate the green \"<> Code\" button at the top of the page, just above the top right corner of the file list. Click on it. That should produce a dropdown menu with a bunch of information in it. In the dropdown, select the \"Local\" tab if it's not already selected. In the line that says \"HTTPS SSH GitHub CLI\", select \"GitHub CLI\" . The box right below where you click should now contain text that looks something like gh repo clone UNCG-PHY-351-S25/L1.E , where the last bit is the repo name. Click the copy button (the two overlapping squares) to the right of this text box to copy the text snippet into your computer's clipboard. Open a new web browser tab or window and, in it, navigate to Beskar . TBC\u2026","title":"Clone a Repo to Beskar"},{"location":"recipes/core/workflow/clone-to-beskar/#clone-a-repo-to-beskar","text":"","title":"Clone a Repo to Beskar"},{"location":"recipes/core/workflow/clone-to-beskar/#problem-to-solve","text":"I want to copy my fork of a course level repo from GitHub to Beskar so that I can start working on it in JupyterHub.","title":"Problem to Solve"},{"location":"recipes/core/workflow/clone-to-beskar/#recipe","text":"","title":"Recipe"},{"location":"recipes/core/workflow/clone-to-beskar/#old-version","text":"","title":"Old Version"},{"location":"recipes/core/workflow/clone-to-beskar/#part-b-clone-it-to-beskar","text":"This part makes a copy of the assignment repo on the server you'll do your actual coding work on. Locate the green \"<> Code\" button at the top of the page, just above the top right corner of the file list. Click on it. That should produce a dropdown menu with a bunch of information in it. In the dropdown, select the \"Local\" tab if it's not already selected. In the line that says \"HTTPS SSH GitHub CLI\", select \"GitHub CLI\" . The box right below where you click should now contain text that looks something like gh repo clone UNCG-PHY-351-S25/L1.E , where the last bit is the repo name. Click the copy button (the two overlapping squares) to the right of this text box to copy the text snippet into your computer's clipboard. Open a new web browser tab or window and, in it, navigate to Beskar . TBC\u2026","title":"Part B: Clone it to Beskar"},{"location":"recipes/core/workflow/commit-push/","text":"Commit and Push Changes to GitHub Problem to Solve I want to make a snapshot of my work so far in case I need to roll back changes, and copy the current repo state back to GitHub for safekeeping. Recipe","title":"Commit and Push Changes to GitHub"},{"location":"recipes/core/workflow/commit-push/#commit-and-push-changes-to-github","text":"","title":"Commit and Push Changes to GitHub"},{"location":"recipes/core/workflow/commit-push/#problem-to-solve","text":"I want to make a snapshot of my work so far in case I need to roll back changes, and copy the current repo state back to GitHub for safekeeping.","title":"Problem to Solve"},{"location":"recipes/core/workflow/commit-push/#recipe","text":"","title":"Recipe"},{"location":"recipes/core/workflow/edit-file/","text":"Edit a File in an Assignment Problem to Solve I want to make changes to the name or content of a file that came with a course level repo. Recipe","title":"Edit a File in an Assignment"},{"location":"recipes/core/workflow/edit-file/#edit-a-file-in-an-assignment","text":"","title":"Edit a File in an Assignment"},{"location":"recipes/core/workflow/edit-file/#problem-to-solve","text":"I want to make changes to the name or content of a file that came with a course level repo.","title":"Problem to Solve"},{"location":"recipes/core/workflow/edit-file/#recipe","text":"","title":"Recipe"},{"location":"recipes/core/workflow/find-and-fork/","text":"Find and Fork a Repo on GitHub Problem to Solve I want to make my own copy of a course level repo (the \"package\" that assignments come bundled in) so that I can start working on it. Background Knowledge Git and GitHub Git is a software tool and system that helps programmers manage and collaborate on complex coding projects. One can install and run Git on just about any computer. GitHub is an online service that provides web-based Git support. It helps developer teams collaborate, keep track of (and occasionally roll back) changes to a software project, and track issues to address. We'll use it as a way for me to distribute assignment files to you, for you to submit your work back to me, and for me to provide you with specific feedback about your code. GitHub runs on some huge server farm somewhere, and talks to Git runningh on your computer. On GitHub , an organization (\"org\") is a space for a group of people to share and collaborate on coding projects. Prof. Beatty has created an organization for PHY 351. Repos and Course Assignments On GitHub, the fundamental container or package for a coding project is called a repository , or \" repo \" for short. A repo is a collection of files and directories that can be shared with others and perhaps jointly edited. GitHub is built upon the git version control system, which takes care of (a) keeping a historical record of all changes to a repo's files over time, with snapshots of how it looked at various points in time; and (b) checking for and helping to reconcile conflicts that might arise between different contributor's edits and contributions. I've divided the PHY 351 course content into six \"worlds\" (if we get that far). Each world is divided into multiple \"levels\". For example, World A is about Core Python skills. Within it, Level 01 is called Workflow and focuses on how to use the course's \"tech stack\" \u2014 the combination of technology platforms and tools you'll use to do the course. A level consists of several individual \"Exercises\", each of which focuses on one of the course's computational physics \"Recipes\". Most levels end with a \"Miniboss\", a slightly more complex challenge that asks you to apply a combination of the recipes from the level. I've chosen to package each \"level\" as one GitHub repo (repository). To \"do\" a level, the essence of what you need to accomplish is: Find the level repo in our course \"org\" (organization) on GitHub. Fork that repo to make your own copy to do your work in. Clone your copy of the level repo to your account on Beskar, the server where you'll do your coding work. Read the instructions in the repo and complete the specified tasks for each of the exercises and the miniboss. Periodically commit your work to version control (to create snapshots that you could roll back to if necessary), and push all changes your copy of the repo on GitHub. When all work for the exercises and miniboss is done, do a final commit-push, and then submit your work to me for credit by opening a pull request (\"pullreq\") from your copy of the repo to the course org's original version of repo. (This sounds weird. I'll explain more when we get there.) For this recipe, we're just focusing on Steps 1 and 2 of this process, which includes getting familiar with GitHub and how I've set up our course \"org\" within it. Recipe Part A: Create a GitHub Account (once only) For this course, you'll need to have your own account with the GitHub service. Even if you already have one, you'll probably need to create a new one, because you'll need a GitHub account whose username is your UNCG username. Here's how to do that: In a web browser, open https://github.com/ in a new browser tab or window. The page you land on should have a prominent \"Sign up for GitHub\" button next to a blank for your email address. Enter your UNCG email address and click. Follow the account creation steps (email authentication, etc.). IMPORTANT: When prompted for \"Username\", choose your UNCG user ID: The portion of your UNCG email address before the \"@\" symbol. Pick your password carefully, as you'll need to use it frequently. (May I suggest getting and learning to use a good password management program? I use 1Password .) At the appropriate step, identify yourself as a \"student\". Choose the free student plan. When you get to the page with \"The home for all developers \u2014 including you\" at the top, you've succeeded! Part B: Get Added to the Course \"Org\" (once only) Now that you've created your GitHub account, tell Prof. Beatty. He'll add you to the coure GitHub org. Wait\u2026 \u23f3\u231b\ufe0f\u2026 until\u2026 Prof. Beatty lets you know that you've been added. Then, you can progress to the next step. Part C: Find the Course Org When I tell you I've done that (or you're impatient and want to check by yourself): Point your web browser to https://github.com/UNCG-PHY-351-F22 . (You might want to bookmark this.) If you see \"This organization has no public repositories\", I haven't added you yet (or I did it wrong). If you see \"You made it! Welcome to the private GitHub space for UNCG's PHY 351 in Spring 2025\", all is good and you're ready to proceed to the next task. Feel free to explore a little, if you wish. Don't go too far down any rabbit-holes, however: We've got work to do! Part D: Find the Level Repo Remember that course assignments are packaged up into repositories (\"repos\"), one level per repo. All the org repos available to you are listed on the org's repo page. Along the top of the GitHub page for our org are several tab-style links: \"Overview\", \"Repositories\", \"Projects\", etc. Click on \"Repositories\" . This should take you to a page listing repositories, with names like uncg-phy-351-s25.github.io and A-01 . If the list of repos gets inconveniently long as the semester progresses and Beatty releases more levels, note that the page has tools to let you search by repo name (or just a part of a name), sort the list in various ways, etc. Click on the name of the repo you want to start work on. This should take you to the repo's home page. Under a bit of fairly cryptic header info you'll see a list of files and folders in the repo. In the right sidebar is a brief \"About\" section. Part E: Fork the repo (once per repo/level) In GitHub parlance, forking a repo means making your own copy of it, so that you can make modifications without affecting anyone else. A forked repo keeps track of the original \"upstream\" repo that it was forked from. One benefit is if the upstream repo changes, you can choose to sync your forked repo with the changes in the upstream repo. (For a course level repo, that will probably occur when I inevitably discover bugs or confusing bits in an assignment that students have already started working on.) As the owner of a forked repo, you can also request that the upstream repo incorporate changes you've made in your fork. This is called issuing a pull request (\"pullreq\" \u2014 my own nickname for it). Before you can start working on the assignments in a course level, you have to fork the level repo. (Otherwise, every student would be making changes to the same set of files, and pandemonium would erupt.) If you're not already looking at the home page of the level repo (on the GitHub website), get there as described above in Part D. Way up at the top right of that page, find the button that says \"Fork\". Click it. (Don't click on the little down-arrow to its right; click the main part that has the word \"Fork\".) This should take you to a \"Create a new fork\" page. In the form, change \"Owner\" to \"UNCG-PHY-351-S25\". That will cause a scary red warning that \"The repository [XXX] already exists on this account.\" Don't worry about it! Instead: To the end of the repo name (such as \"A-01\"), append a hyphen and your GitHub ID (to make the name something like \"A-01-idbeatty\"). Leave \"Description\" as it is (though changing it won't break anything). Leave \"Copy the main branch only\" checked. Click the big green \"Create fork\" button. When you do, you should be taken to the home page of your new repo. The repo name, which includes both the level name and your GitHub ID, will help you distinguish your copy of the repo from the original distributed by Prof. Beatty.","title":"Find and Fork a Repo on GitHub"},{"location":"recipes/core/workflow/find-and-fork/#find-and-fork-a-repo-on-github","text":"","title":"Find and Fork a Repo on GitHub"},{"location":"recipes/core/workflow/find-and-fork/#problem-to-solve","text":"I want to make my own copy of a course level repo (the \"package\" that assignments come bundled in) so that I can start working on it.","title":"Problem to Solve"},{"location":"recipes/core/workflow/find-and-fork/#background-knowledge","text":"","title":"Background Knowledge"},{"location":"recipes/core/workflow/find-and-fork/#git-and-github","text":"Git is a software tool and system that helps programmers manage and collaborate on complex coding projects. One can install and run Git on just about any computer. GitHub is an online service that provides web-based Git support. It helps developer teams collaborate, keep track of (and occasionally roll back) changes to a software project, and track issues to address. We'll use it as a way for me to distribute assignment files to you, for you to submit your work back to me, and for me to provide you with specific feedback about your code. GitHub runs on some huge server farm somewhere, and talks to Git runningh on your computer. On GitHub , an organization (\"org\") is a space for a group of people to share and collaborate on coding projects. Prof. Beatty has created an organization for PHY 351.","title":"Git and GitHub"},{"location":"recipes/core/workflow/find-and-fork/#repos-and-course-assignments","text":"On GitHub, the fundamental container or package for a coding project is called a repository , or \" repo \" for short. A repo is a collection of files and directories that can be shared with others and perhaps jointly edited. GitHub is built upon the git version control system, which takes care of (a) keeping a historical record of all changes to a repo's files over time, with snapshots of how it looked at various points in time; and (b) checking for and helping to reconcile conflicts that might arise between different contributor's edits and contributions. I've divided the PHY 351 course content into six \"worlds\" (if we get that far). Each world is divided into multiple \"levels\". For example, World A is about Core Python skills. Within it, Level 01 is called Workflow and focuses on how to use the course's \"tech stack\" \u2014 the combination of technology platforms and tools you'll use to do the course. A level consists of several individual \"Exercises\", each of which focuses on one of the course's computational physics \"Recipes\". Most levels end with a \"Miniboss\", a slightly more complex challenge that asks you to apply a combination of the recipes from the level. I've chosen to package each \"level\" as one GitHub repo (repository). To \"do\" a level, the essence of what you need to accomplish is: Find the level repo in our course \"org\" (organization) on GitHub. Fork that repo to make your own copy to do your work in. Clone your copy of the level repo to your account on Beskar, the server where you'll do your coding work. Read the instructions in the repo and complete the specified tasks for each of the exercises and the miniboss. Periodically commit your work to version control (to create snapshots that you could roll back to if necessary), and push all changes your copy of the repo on GitHub. When all work for the exercises and miniboss is done, do a final commit-push, and then submit your work to me for credit by opening a pull request (\"pullreq\") from your copy of the repo to the course org's original version of repo. (This sounds weird. I'll explain more when we get there.) For this recipe, we're just focusing on Steps 1 and 2 of this process, which includes getting familiar with GitHub and how I've set up our course \"org\" within it.","title":"Repos and Course Assignments"},{"location":"recipes/core/workflow/find-and-fork/#recipe","text":"","title":"Recipe"},{"location":"recipes/core/workflow/find-and-fork/#part-a-create-a-github-account-once-only","text":"For this course, you'll need to have your own account with the GitHub service. Even if you already have one, you'll probably need to create a new one, because you'll need a GitHub account whose username is your UNCG username. Here's how to do that: In a web browser, open https://github.com/ in a new browser tab or window. The page you land on should have a prominent \"Sign up for GitHub\" button next to a blank for your email address. Enter your UNCG email address and click. Follow the account creation steps (email authentication, etc.). IMPORTANT: When prompted for \"Username\", choose your UNCG user ID: The portion of your UNCG email address before the \"@\" symbol. Pick your password carefully, as you'll need to use it frequently. (May I suggest getting and learning to use a good password management program? I use 1Password .) At the appropriate step, identify yourself as a \"student\". Choose the free student plan. When you get to the page with \"The home for all developers \u2014 including you\" at the top, you've succeeded!","title":"Part A: Create a GitHub Account (once only)"},{"location":"recipes/core/workflow/find-and-fork/#part-b-get-added-to-the-course-org-once-only","text":"Now that you've created your GitHub account, tell Prof. Beatty. He'll add you to the coure GitHub org. Wait\u2026 \u23f3\u231b\ufe0f\u2026 until\u2026 Prof. Beatty lets you know that you've been added. Then, you can progress to the next step.","title":"Part B: Get Added to the Course \"Org\" (once only)"},{"location":"recipes/core/workflow/find-and-fork/#part-c-find-the-course-org","text":"When I tell you I've done that (or you're impatient and want to check by yourself): Point your web browser to https://github.com/UNCG-PHY-351-F22 . (You might want to bookmark this.) If you see \"This organization has no public repositories\", I haven't added you yet (or I did it wrong). If you see \"You made it! Welcome to the private GitHub space for UNCG's PHY 351 in Spring 2025\", all is good and you're ready to proceed to the next task. Feel free to explore a little, if you wish. Don't go too far down any rabbit-holes, however: We've got work to do!","title":"Part C: Find the Course Org"},{"location":"recipes/core/workflow/find-and-fork/#part-d-find-the-level-repo","text":"Remember that course assignments are packaged up into repositories (\"repos\"), one level per repo. All the org repos available to you are listed on the org's repo page. Along the top of the GitHub page for our org are several tab-style links: \"Overview\", \"Repositories\", \"Projects\", etc. Click on \"Repositories\" . This should take you to a page listing repositories, with names like uncg-phy-351-s25.github.io and A-01 . If the list of repos gets inconveniently long as the semester progresses and Beatty releases more levels, note that the page has tools to let you search by repo name (or just a part of a name), sort the list in various ways, etc. Click on the name of the repo you want to start work on. This should take you to the repo's home page. Under a bit of fairly cryptic header info you'll see a list of files and folders in the repo. In the right sidebar is a brief \"About\" section.","title":"Part D: Find the Level Repo"},{"location":"recipes/core/workflow/find-and-fork/#part-e-fork-the-repo-once-per-repolevel","text":"In GitHub parlance, forking a repo means making your own copy of it, so that you can make modifications without affecting anyone else. A forked repo keeps track of the original \"upstream\" repo that it was forked from. One benefit is if the upstream repo changes, you can choose to sync your forked repo with the changes in the upstream repo. (For a course level repo, that will probably occur when I inevitably discover bugs or confusing bits in an assignment that students have already started working on.) As the owner of a forked repo, you can also request that the upstream repo incorporate changes you've made in your fork. This is called issuing a pull request (\"pullreq\" \u2014 my own nickname for it). Before you can start working on the assignments in a course level, you have to fork the level repo. (Otherwise, every student would be making changes to the same set of files, and pandemonium would erupt.) If you're not already looking at the home page of the level repo (on the GitHub website), get there as described above in Part D. Way up at the top right of that page, find the button that says \"Fork\". Click it. (Don't click on the little down-arrow to its right; click the main part that has the word \"Fork\".) This should take you to a \"Create a new fork\" page. In the form, change \"Owner\" to \"UNCG-PHY-351-S25\". That will cause a scary red warning that \"The repository [XXX] already exists on this account.\" Don't worry about it! Instead: To the end of the repo name (such as \"A-01\"), append a hyphen and your GitHub ID (to make the name something like \"A-01-idbeatty\"). Leave \"Description\" as it is (though changing it won't break anything). Leave \"Copy the main branch only\" checked. Click the big green \"Create fork\" button. When you do, you should be taken to the home page of your new repo. The repo name, which includes both the level name and your GitHub ID, will help you distinguish your copy of the repo from the original distributed by Prof. Beatty.","title":"Part E: Fork the repo (once per repo/level)"},{"location":"recipes/core/workflow/interactive-python/","text":"Execute Interactive Python Problem to Solve I want to execute python commands interactively (perhaps to do a one-off calculation or just try things out). Recipe Old Version Recipe to Solve It This is another \"procedural\" recipe. Part A, Version 1: Starting IPython from JupyterLab If you are logged into Beskar and looking at the JupyterLab interface\u2026 If no \"Launcher\" tab is open in the main JupyterLab window, open the Launcher by clicking on the + button to the right of whatever tab(s) is/are open. A tab labeled \"Launcher\" should appear in the main window. Alternatively, you can click on the blue + button at the top of the File Browser in the left sidebar. If the sidebar is collapsed or is showing something else, view the File Browser by clicking on the folder icon in the very left window border. Launch an IPython console by clicking on the button labeled \"Python 3 (ipykernel)\" in the Console section , not the identical button in the Notebook section above it . The Launcher tab should disappear, replaced by a tab labeled \"Console N\" (where N is some number). You now have an active IPython session. Type python expressions and statements into the input box at the bottom of the pane, and hit Shift-Enter (or possibly just Enter) to send them to the python interpreter for execution. You can decide whether you want to use Shift-Enter or just Enter to execute statements. Click the Settings menu in the JupyterLab browser window, pick \"Console Run Keystroke\" from the menu that appears, and select the option you prefer. If you use \"Enter\" to execute code, you can use Shift-Enter to insert a line break for multiline input. Part A, Version 2: Starting IPython from the terminal If you are working on your own computer or are logged into a different server, you can use IPython without JupyterLab. The visual appearance is different, but the functionality is equivalent. Open a terminal window in whatever way is appropriate for your operating system. In JupyterLab, you can do this by opening the Launcher (see Version 1 above) and clicking on the \"Terminal\" button in the \"Other\" section at the bottom. On a Mac or Linux machine, launch the Terminal app or an equivalent application. (I prefer the \"Warp\" app.) On Windows, you can use the Command Prompt or PowerShell. At the terminal's command line, type ipython and hit Enter. If you get a message like \"command not found: ipython\", either your computer doesn't have IPython installed, or it's in a \"virtual environment\" that you don't have activated. Resolving that is beyond the scope of this recipe. For PHY 351, just use JupyterLab on Beskar and you should be fine. Part B: Do the calculation Enter and execute a succession of python expressions and statements to accomplish your goals. (Details about how to do this are coming in future recipes, especially the next one .) The window above the input box/prompt will show you your IPython session's prior history of commands and their results. JupyterLab and most terminal programs will let you scroll back through that history, at least for a while. Part C: Save, if desired If you want, you can save your IPython session's history to a file so that you have a record of what you did. Execute %save filename.txt , replacing filename with something meaningful to your situation. This will save all your inputs and python's responses, for the entire IPython session. You can save just a subset of the history by specifying the line numbers along with the %save command. For example, if you want to save lines 12 through 30, you would type %save filename.txt 12-30 . Locate your history file and, if desired, move it somewhere more convenient. By default, it gets saved in the \"current working directory\". If you're using the JupyterLab interface, the \"current working directory\" will be whatever directory is currently displayed in the JupyterLab File Browser. If you're using a terminal, it will be the directory your terminal was \"in\" when you launched IPython. If you're thinking ahead, navigate the JupyterLab File Browser or terminal to the folder/directory you'll want your history file to be stored in before launching IPython. Technically, it is possible to reload a stored session by re-running all commands in a history file. However, this is tricky and unreliable, because any errors in the file \u2014 from times that you entered something wrong and then redid or fixed it \u2014 will cause the re-running process to halt. In general, I recommend re-doing rather than restoring prior work if you need to resume an IPython session. (For anything complex enough to make this annoying, see the Scripts recipe.) Part D, Version 1: Quitting IPython from JupyterLab Close the console tab by clicking the \"X\" at the right side of the \"Console N\" tab. Kill the background interpreter by clicking on the square-within-a-circle icon in JupyterLab's far left border (it says \"Running Terminals and Kernels\" if hovered over) and clicking \"Shut Down All\" next to \"KERNELS\". (Or, expand the Kernels section, hover over the line for \"Console N\", and click the \"X\" that appears to its right.) Part D, Version 2: Quitting IPython from the terminal Enter and execute quit at the console prompt. This will return you to the terminal's command line. (Unfortunately, if you do this within the JupyterLab IPython console, it'll quit and then automatically restart the console \u2014 quite annoying.) Comments Again, this may look long and complicated, but it's the work of a few seconds once you're comfortable firing up JupyterLab or a terminal session. The result is an easy-access calculator that is superior in most ways to whatever handheld calculator or phone calculator app you might generally use.","title":"Execute Interactive Python"},{"location":"recipes/core/workflow/interactive-python/#execute-interactive-python","text":"","title":"Execute Interactive Python"},{"location":"recipes/core/workflow/interactive-python/#problem-to-solve","text":"I want to execute python commands interactively (perhaps to do a one-off calculation or just try things out).","title":"Problem to Solve"},{"location":"recipes/core/workflow/interactive-python/#recipe","text":"","title":"Recipe"},{"location":"recipes/core/workflow/interactive-python/#old-version","text":"","title":"Old Version"},{"location":"recipes/core/workflow/interactive-python/#recipe-to-solve-it","text":"This is another \"procedural\" recipe.","title":"Recipe to Solve It"},{"location":"recipes/core/workflow/interactive-python/#part-a-version-1-starting-ipython-from-jupyterlab","text":"If you are logged into Beskar and looking at the JupyterLab interface\u2026 If no \"Launcher\" tab is open in the main JupyterLab window, open the Launcher by clicking on the + button to the right of whatever tab(s) is/are open. A tab labeled \"Launcher\" should appear in the main window. Alternatively, you can click on the blue + button at the top of the File Browser in the left sidebar. If the sidebar is collapsed or is showing something else, view the File Browser by clicking on the folder icon in the very left window border. Launch an IPython console by clicking on the button labeled \"Python 3 (ipykernel)\" in the Console section , not the identical button in the Notebook section above it . The Launcher tab should disappear, replaced by a tab labeled \"Console N\" (where N is some number). You now have an active IPython session. Type python expressions and statements into the input box at the bottom of the pane, and hit Shift-Enter (or possibly just Enter) to send them to the python interpreter for execution. You can decide whether you want to use Shift-Enter or just Enter to execute statements. Click the Settings menu in the JupyterLab browser window, pick \"Console Run Keystroke\" from the menu that appears, and select the option you prefer. If you use \"Enter\" to execute code, you can use Shift-Enter to insert a line break for multiline input.","title":"Part A, Version 1: Starting IPython from JupyterLab"},{"location":"recipes/core/workflow/interactive-python/#part-a-version-2-starting-ipython-from-the-terminal","text":"If you are working on your own computer or are logged into a different server, you can use IPython without JupyterLab. The visual appearance is different, but the functionality is equivalent. Open a terminal window in whatever way is appropriate for your operating system. In JupyterLab, you can do this by opening the Launcher (see Version 1 above) and clicking on the \"Terminal\" button in the \"Other\" section at the bottom. On a Mac or Linux machine, launch the Terminal app or an equivalent application. (I prefer the \"Warp\" app.) On Windows, you can use the Command Prompt or PowerShell. At the terminal's command line, type ipython and hit Enter. If you get a message like \"command not found: ipython\", either your computer doesn't have IPython installed, or it's in a \"virtual environment\" that you don't have activated. Resolving that is beyond the scope of this recipe. For PHY 351, just use JupyterLab on Beskar and you should be fine.","title":"Part A, Version 2: Starting IPython from the terminal"},{"location":"recipes/core/workflow/interactive-python/#part-b-do-the-calculation","text":"Enter and execute a succession of python expressions and statements to accomplish your goals. (Details about how to do this are coming in future recipes, especially the next one .) The window above the input box/prompt will show you your IPython session's prior history of commands and their results. JupyterLab and most terminal programs will let you scroll back through that history, at least for a while.","title":"Part B: Do the calculation"},{"location":"recipes/core/workflow/interactive-python/#part-c-save-if-desired","text":"If you want, you can save your IPython session's history to a file so that you have a record of what you did. Execute %save filename.txt , replacing filename with something meaningful to your situation. This will save all your inputs and python's responses, for the entire IPython session. You can save just a subset of the history by specifying the line numbers along with the %save command. For example, if you want to save lines 12 through 30, you would type %save filename.txt 12-30 . Locate your history file and, if desired, move it somewhere more convenient. By default, it gets saved in the \"current working directory\". If you're using the JupyterLab interface, the \"current working directory\" will be whatever directory is currently displayed in the JupyterLab File Browser. If you're using a terminal, it will be the directory your terminal was \"in\" when you launched IPython. If you're thinking ahead, navigate the JupyterLab File Browser or terminal to the folder/directory you'll want your history file to be stored in before launching IPython. Technically, it is possible to reload a stored session by re-running all commands in a history file. However, this is tricky and unreliable, because any errors in the file \u2014 from times that you entered something wrong and then redid or fixed it \u2014 will cause the re-running process to halt. In general, I recommend re-doing rather than restoring prior work if you need to resume an IPython session. (For anything complex enough to make this annoying, see the Scripts recipe.)","title":"Part C: Save, if desired"},{"location":"recipes/core/workflow/interactive-python/#part-d-version-1-quitting-ipython-from-jupyterlab","text":"Close the console tab by clicking the \"X\" at the right side of the \"Console N\" tab. Kill the background interpreter by clicking on the square-within-a-circle icon in JupyterLab's far left border (it says \"Running Terminals and Kernels\" if hovered over) and clicking \"Shut Down All\" next to \"KERNELS\". (Or, expand the Kernels section, hover over the line for \"Console N\", and click the \"X\" that appears to its right.)","title":"Part D, Version 1: Quitting IPython from JupyterLab"},{"location":"recipes/core/workflow/interactive-python/#part-d-version-2-quitting-ipython-from-the-terminal","text":"Enter and execute quit at the console prompt. This will return you to the terminal's command line. (Unfortunately, if you do this within the JupyterLab IPython console, it'll quit and then automatically restart the console \u2014 quite annoying.)","title":"Part D, Version 2: Quitting IPython from the terminal"},{"location":"recipes/core/workflow/interactive-python/#comments","text":"Again, this may look long and complicated, but it's the work of a few seconds once you're comfortable firing up JupyterLab or a terminal session. The result is an easy-access calculator that is superior in most ways to whatever handheld calculator or phone calculator app you might generally use.","title":"Comments"},{"location":"recipes/core/workflow/submit-level/","text":"Submit a Level via Commit-Push-Pullreq Problem to Solve I want to submit a repo (level) of completed work for course credit. Recipe","title":"Submit a Level via Commit-Push-Pullreq"},{"location":"recipes/core/workflow/submit-level/#submit-a-level-via-commit-push-pullreq","text":"","title":"Submit a Level via Commit-Push-Pullreq"},{"location":"recipes/core/workflow/submit-level/#problem-to-solve","text":"I want to submit a repo (level) of completed work for course credit.","title":"Problem to Solve"},{"location":"recipes/core/workflow/submit-level/#recipe","text":"","title":"Recipe"},{"location":"recipes/core/workflow/system-terminal/","text":"Open and Use the System Terminal Problem to Solve I want to do something that must be done, or is easiest to do, directly with Beskar's operating system and filesystem (\"behind the scenes\") rather than in JupyterHub. Recipe","title":"Open and Use the System Terminal"},{"location":"recipes/core/workflow/system-terminal/#open-and-use-the-system-terminal","text":"","title":"Open and Use the System Terminal"},{"location":"recipes/core/workflow/system-terminal/#problem-to-solve","text":"I want to do something that must be done, or is easiest to do, directly with Beskar's operating system and filesystem (\"behind the scenes\") rather than in JupyterHub.","title":"Problem to Solve"},{"location":"recipes/core/workflow/system-terminal/#recipe","text":"","title":"Recipe"},{"location":"recipes/num1/","text":"Numerical Methods 1: Finding Roots & Extrema \"Numerical methods\" are algorithms \u2014 recipes, if you will \u2014 for solving mathematical problems via numerical calculations on a computer. There is a vast vast VAST literature on such things, and this course will barely scratch the surface. That, however, should be enough to give you a sense of how the game is played, and to empower you to track down the methods you need when you do. Our first set of numerical methods focus on two things you might want to do to an equation: solve it (i.e., \"find its root(s)\"), and find its extrema (maxima and/or minima). For some equations, this is easily done with analytic methods (paper and pencil rearranging of symbols). For others, analytic methods fail, and numerical methods are the only way to go. In between, we get cases that could in principle be solved analytically, given enough time and a big enough whiteboard, but why bother when a computer can do it quickly and easily? Solving nonlinear equations: Three different algorithms for \"finding the roots of an equation\", each with its own advantages and disadvantages. Finding extrema: A recipe for finding maxima or minima of a one-dimensional function, and another for finding extrema of 2D, 3D, and higher-dimensional functions.","title":"Numerical Methods 1: Finding Roots &amp; Extrema"},{"location":"recipes/num1/#numerical-methods-1-finding-roots-extrema","text":"\"Numerical methods\" are algorithms \u2014 recipes, if you will \u2014 for solving mathematical problems via numerical calculations on a computer. There is a vast vast VAST literature on such things, and this course will barely scratch the surface. That, however, should be enough to give you a sense of how the game is played, and to empower you to track down the methods you need when you do. Our first set of numerical methods focus on two things you might want to do to an equation: solve it (i.e., \"find its root(s)\"), and find its extrema (maxima and/or minima). For some equations, this is easily done with analytic methods (paper and pencil rearranging of symbols). For others, analytic methods fail, and numerical methods are the only way to go. In between, we get cases that could in principle be solved analytically, given enough time and a big enough whiteboard, but why bother when a computer can do it quickly and easily? Solving nonlinear equations: Three different algorithms for \"finding the roots of an equation\", each with its own advantages and disadvantages. Finding extrema: A recipe for finding maxima or minima of a one-dimensional function, and another for finding extrema of 2D, 3D, and higher-dimensional functions.","title":"Numerical Methods 1: Finding Roots &amp; Extrema"},{"location":"recipes/num2/","text":"Numerical Methods 2: Numerical Calculus Doing math involves more than solving equations; it often requires taking derivatives and integrating. Computers can do that too! The key involves forgetting most of what you learned in calculus courses, and going back to the initial definitions of \"derivative\" and \"integral\"\u2026 and then applying a whole lot of numerical cleverness.","title":"Numerical Methods 2: Numerical Calculus"},{"location":"recipes/num2/#numerical-methods-2-numerical-calculus","text":"Doing math involves more than solving equations; it often requires taking derivatives and integrating. Computers can do that too! The key involves forgetting most of what you learned in calculus courses, and going back to the initial definitions of \"derivative\" and \"integral\"\u2026 and then applying a whole lot of numerical cleverness.","title":"Numerical Methods 2: Numerical Calculus"},{"location":"recipes/num3/","text":"Numerical Methods 3: ODE Integration Most of the central principles of physics are expressed as differential equations, and \u2014 consequently \u2014 a great deal of \"doing physics\" comes down to solving differential equations. In the space of all differential equations that we might reasonably encounter in physical problems, only a tiny sliver can be solved analytically. For the rest, we turn to computational methods. In this chunk, we introduce recipes for solving ordinary differential equations (ODEs) numerically. (Partial differential equations \u2014 PDEs \u2014 are such a vast topic that we won't be able to address them in this course. Sorry! )","title":"Numerical Methods 3: ODE Integration"},{"location":"recipes/num3/#numerical-methods-3-ode-integration","text":"Most of the central principles of physics are expressed as differential equations, and \u2014 consequently \u2014 a great deal of \"doing physics\" comes down to solving differential equations. In the space of all differential equations that we might reasonably encounter in physical problems, only a tiny sliver can be solved analytically. For the rest, we turn to computational methods. In this chunk, we introduce recipes for solving ordinary differential equations (ODEs) numerically. (Partial differential equations \u2014 PDEs \u2014 are such a vast topic that we won't be able to address them in this course. Sorry! )","title":"Numerical Methods 3: ODE Integration"},{"location":"recipes/scipy/","text":"Skillset B: Scientific Python Here we introduce recipes focused on aspects of python central to numerically-intensive work. These include a deep understanding of how computers handle numbers, working with arrays and matrices of values, creating plots and other data visualizations, and reading to or writing from data files. Along the way, we'll introduce numpy and matplotlib , add-ons to the python language that support numerically-focused work. Machine arithmetic: Recipes for working with numerical values safely, accurately, and efficiently. Arrays: Recipes for using numpy arrays (1D, 2D, and even higher) to accomplish stuff. Plotting: Recipes for using matplotlib to construct 2D, y vs. x plots all tweaked out and ready to publish. Histograms: Because a y vs. x plot is not always the right data visualization tool for the job. Files: Recipes for reading in datafiles, including high-maintenance ones, and for writing out your own results to files for safekeeping or sharing.","title":"Skillset B: Scientific Python"},{"location":"recipes/scipy/#skillset-b-scientific-python","text":"Here we introduce recipes focused on aspects of python central to numerically-intensive work. These include a deep understanding of how computers handle numbers, working with arrays and matrices of values, creating plots and other data visualizations, and reading to or writing from data files. Along the way, we'll introduce numpy and matplotlib , add-ons to the python language that support numerically-focused work. Machine arithmetic: Recipes for working with numerical values safely, accurately, and efficiently. Arrays: Recipes for using numpy arrays (1D, 2D, and even higher) to accomplish stuff. Plotting: Recipes for using matplotlib to construct 2D, y vs. x plots all tweaked out and ready to publish. Histograms: Because a y vs. x plot is not always the right data visualization tool for the job. Files: Recipes for reading in datafiles, including high-maintenance ones, and for writing out your own results to files for safekeeping or sharing.","title":"Skillset B: Scientific Python"},{"location":"recipes/visual/","text":"Skillset C: Visual Python Yeah, \"solving\" a physics problem and getting a bunch of numbers out \u2013 or even a pretty plot \u2014 is nice, but there's no substitute for seeing the behavior of your modeled system evolve in realtime. VPython (\"visual python\") is an add-on toolkit for doing exactly that, and it makes constructing and animating 3D simulations embarrassingly easy.","title":"Skillset C: Visual Python"},{"location":"recipes/visual/#skillset-c-visual-python","text":"Yeah, \"solving\" a physics problem and getting a bunch of numbers out \u2013 or even a pretty plot \u2014 is nice, but there's no substitute for seeing the behavior of your modeled system evolve in realtime. VPython (\"visual python\") is an add-on toolkit for doing exactly that, and it makes constructing and animating 3D simulations embarrassingly easy.","title":"Skillset C: Visual Python"},{"location":"topics/","text":"Python Topics Reference This section of the website contains miscellaneous bits and pieces about various aspects of python. (I needed someplace to throw tidbits that aren't directly associated with a particular recipe.) This area is likely to grow and reorganize organically, so use the navigation menu above to see what's here.","title":"Overview"},{"location":"topics/#python-topics-reference","text":"This section of the website contains miscellaneous bits and pieces about various aspects of python. (I needed someplace to throw tidbits that aren't directly associated with a particular recipe.) This area is likely to grow and reorganize organically, so use the navigation menu above to see what's here.","title":"Python Topics Reference"},{"location":"topics/external/","text":"External Tutorials of Possible Utility This is a list of topically-focused python-related tutorial and reference articles that I've stumbled across while putting this course together, thought might be useful to y'all, and not been excessively annoyed by. Do NOT assume that you're supposed to learn or know everything in them! Workflow Topics The Python Standard REPL: Try Out Code and Ideas Quickly by Real Python Core Python Topics Real Python has several good Python Basics tutorials , including: Numbers in Python Basic Data Types in Python: A Quick Exploration Variables in Python: Usage and Best Practices Operators and Expressions in Python Python Modules and Packages \u2013 An Introduction Python's Built-in Functions: A Complete Exploration Simplify Complex Numbers With Python Your Guide to the Python print() Function Formatting Floats Inside Python F-Strings How to Read User Input From the Keyboard in Python How to Read Python Input as Integers Lists vs Tuples in Python Python range(): Represent Numerical Ranges Using the zip() Function for Parallel Iteration Python enumerate(): Simplify Loops That Need Counters Defining Your Own Python Function Using Python Optional Arguments When Defining Functions Namespaces and Scope in Python","title":"External Tutorials"},{"location":"topics/external/#external-tutorials-of-possible-utility","text":"This is a list of topically-focused python-related tutorial and reference articles that I've stumbled across while putting this course together, thought might be useful to y'all, and not been excessively annoyed by. Do NOT assume that you're supposed to learn or know everything in them!","title":"External Tutorials of Possible Utility"},{"location":"topics/external/#workflow-topics","text":"The Python Standard REPL: Try Out Code and Ideas Quickly by Real Python","title":"Workflow Topics"},{"location":"topics/external/#core-python-topics","text":"Real Python has several good Python Basics tutorials , including: Numbers in Python Basic Data Types in Python: A Quick Exploration Variables in Python: Usage and Best Practices Operators and Expressions in Python Python Modules and Packages \u2013 An Introduction Python's Built-in Functions: A Complete Exploration Simplify Complex Numbers With Python Your Guide to the Python print() Function Formatting Floats Inside Python F-Strings How to Read User Input From the Keyboard in Python How to Read Python Input as Integers Lists vs Tuples in Python Python range(): Represent Numerical Ranges Using the zip() Function for Parallel Iteration Python enumerate(): Simplify Loops That Need Counters Defining Your Own Python Function Using Python Optional Arguments When Defining Functions Namespaces and Scope in Python","title":"Core Python Topics"},{"location":"topics/core/operators/","text":"Arithmetic Operators the binary operators Knowing your python arithmetic operators is essential. Here are python's relevant binary operators . (\"Binary\" means that they act on two quantities by being placed between them.) Addition: + Just like standard mathematical notation. Implement \" \\(3+4\\) \" as 3 + 4 . Subtraction: - Also just like standard mathematical notation. Implement \" \\(3-4\\) \" as 3 - 4 . Multiplication: * NOT like standard mathematical notation. Python uses the asterisk character instead of the \"times\" sign, and does not recognize implicit multiplication when two quantities are side-by-side. Implement \" \\(3 \\times 4\\) \" as 3 * 4 , and \" \\(2x\\) \" as 2 * x . In python, 2a is an illegal variable name (because it begins with a digit), and 2 a is just invalid syntax in most contexts. Division: / Like some standard mathematical notation. Implement \" \\(3 \\div 4\\) \" as 3 / 4 . The numerator and denominator go on the left and right. Python has no way to arrange them vertically, as in \" \\(\\frac{3}{4}\\) \". That means you can't put a compound expression like \" \\(1 + x\\) \" in the numerator or denominator without using parentheses to group it. (We'll discuss this more thoroughly in Operator Precedence .) Exponentiation: ** NOT like standard mathematical notation OR most other programming languages OR scientific calculators OR just about anything else! Implement \" \\(3^4\\) \" like this: 3**4 . By the way, do NOT use the exponentiation operator for scientific notation. A numeric literal like \\(2.99 \\times 10^8\\) should be entered as 2.99e8 , not as 2.99 * 10**8 . Why? Because python can interpret the first form directly as a floating-point number, with no arithmetic calculations needed. If you use the second form, python has to do two two floating-point calculations \u2014 exponentiation and multiplication. Both take processor time, and both introduce a tiny bit of round-off error. While the impact is tiny, it can really add up within a big loop or matrix. (Also, the first form is way more compact and generally easier to read.) Beware the up-carat! A very very VERY common error among physics students (and instructors too \ud83d\ude2c) is to use an up-carat ^ , as in 3^4 , instead of the double-asterisk \u2014 simply because it's such a habit from non-python work. Unfortunately, if you make this mistake in python, you won't get an error message or any other clear sign that you did something wrong, because the up-carat IS a legitimate arithmetic operator in python! It just doesn't do what you think it should. It does \"bitwise exclusive or\", an obscure binary-logic operation you'll probably never need. So if you accidentally use ^ instead of ** , your calculation or program will probably run without errors. You'll either pull your hair out trying to figure out why its results are wacky, or \u2014 worse \u2014 be blithely ignorant that they're totally wrong. You have been warned. \ud83d\udc40 Modulo % (Also called the modulus operator.) x % y yields the remainder when \\(x\\) is divided by \\(y\\) . For example, 7 % 3 yields 1 , and 7.5 % 3 yields 1.5 . Floor Division // This is complementary to modulo. x % y yields the integer number of times that \\(y\\) divides into \\(x\\) \u2014 in other words, the integer part of \\(x \\div y\\) , discarding the remainder. You can be confident that you understand these operators when it's obvious to you why (x // y) * y + x % y always evaluates to the same value as x / y . Modulo and floor division don't show up much in physics, but they can be surprisingly useful in simplifying the logic of a program. For example, if you're iterating over \\(N\\) things in groups of \\(m\\) at a time, N // m is the number of full-sized groups you'll process and N % m is the number \"left over\" for a final, undersized group. the unary operator Unary operators act on a single quantity. Python only has two you're likely to need (unless you get into bitwise binary logic), and only one is meant for numeric calculations. (We'll meet the other one in an upcoming encounter with Boolean Logic .) Negation: - Sticking a minus sign in front of a numerical quantity flips its sign, from positive to negative or negative to positive, exactly as you would expect. -3 + 4 will evaluate to 1 , and -(2 - 5) to 3 . How does python know whether to interpret - as a binary subtraction operator or a unary negation operator? I can't think of an expression in which both interpretations of a particular - are syntactically legal. the assignment operators It's fairly common in coding to want to set a variable's value to \"its current value plus \\(k\\) \" or \"its current value minus \\(k\\) or \" \\(n\\) times its current value\" or \"one- \\(n^\\text{th}\\) of its current value\", or something like that. The point is that you want to change the value of a variable to be the result of a simple algebraic expression involving its current value. This is easy enough to do with the algebraic operators above: x = x + k , x = x - k , x = x * n , x = x / n , etc. However, because this is so common, python offers you some shortcuts that are slightly more compact, and definitely quicker for a human reader to digest: the assignment operators . shortcut is equivalent to shortcut is equivalent to a += b a = a + b a **= b a = a**b a -= b a = a - b a %= b a = a % b a *= b a = a * b a //= b a = a // b a /= b a = a / b the importance of whitespace The python interpreter doesn't care whether you put space characters around your operators or not. As far as it is concerned, m=32/-2 , m = 32 / - 2 , m = 32/- 2 , m = 32/ - 2 , m=32 / -2 , and m = 32 / -2 are all entirely equivalent. However\u2026 which is easiest for a human to interpret at a glance? That is NOT a small consideration! Important: Strive to make your code, and especially your numerical calculations, as clear and easy-to-read as possible. Adopting this habit will drastically reduce the likelihood that your calculations will contain unintended errors, and will make it easier for you to find errors when you're debugging. It will also reduce the cognitive burden on someone reading the code to figure out what it does. (That someone might very well be you, in the future, trying to remember WTH you were thinking when you wrote it.) As a general rule: Unless you have a very specific reason to do otherwise, Put one space character on either side of a binary operator. That makes it easier to distinguish the operators from their operands. Exception: Don't put spaces around ( ** ) for exponentiation. That helps a reader quickly distinguish it from multiplication. And, as you'll see soon in operator precedence , it better communicates the order in which the operations will occur. Don't put a space between a unary minus and the value it's negating. That makes clear it's a sign flip, not a subtraction. Put a space on either side of an assignment operator, whether that be normal assignment with = or one of the shortcut operators like += . That makes it easier to visually distinguish the expression to evaluate from the variable it's assigned to. (The \"walrus operator\" is a bit of a special case, because it usually needs parentheses to have the intended effect. More on this later.) Remember, space characters don't cost you anything and don't run out. You don't get bonus points for making your code as dense as possible. Quite the contrary \u2014 readability does count!","title":"Arithmetic Operators"},{"location":"topics/core/operators/#arithmetic-operators","text":"","title":"Arithmetic Operators"},{"location":"topics/core/operators/#the-binary-operators","text":"Knowing your python arithmetic operators is essential. Here are python's relevant binary operators . (\"Binary\" means that they act on two quantities by being placed between them.) Addition: + Just like standard mathematical notation. Implement \" \\(3+4\\) \" as 3 + 4 . Subtraction: - Also just like standard mathematical notation. Implement \" \\(3-4\\) \" as 3 - 4 . Multiplication: * NOT like standard mathematical notation. Python uses the asterisk character instead of the \"times\" sign, and does not recognize implicit multiplication when two quantities are side-by-side. Implement \" \\(3 \\times 4\\) \" as 3 * 4 , and \" \\(2x\\) \" as 2 * x . In python, 2a is an illegal variable name (because it begins with a digit), and 2 a is just invalid syntax in most contexts. Division: / Like some standard mathematical notation. Implement \" \\(3 \\div 4\\) \" as 3 / 4 . The numerator and denominator go on the left and right. Python has no way to arrange them vertically, as in \" \\(\\frac{3}{4}\\) \". That means you can't put a compound expression like \" \\(1 + x\\) \" in the numerator or denominator without using parentheses to group it. (We'll discuss this more thoroughly in Operator Precedence .) Exponentiation: ** NOT like standard mathematical notation OR most other programming languages OR scientific calculators OR just about anything else! Implement \" \\(3^4\\) \" like this: 3**4 . By the way, do NOT use the exponentiation operator for scientific notation. A numeric literal like \\(2.99 \\times 10^8\\) should be entered as 2.99e8 , not as 2.99 * 10**8 . Why? Because python can interpret the first form directly as a floating-point number, with no arithmetic calculations needed. If you use the second form, python has to do two two floating-point calculations \u2014 exponentiation and multiplication. Both take processor time, and both introduce a tiny bit of round-off error. While the impact is tiny, it can really add up within a big loop or matrix. (Also, the first form is way more compact and generally easier to read.) Beware the up-carat! A very very VERY common error among physics students (and instructors too \ud83d\ude2c) is to use an up-carat ^ , as in 3^4 , instead of the double-asterisk \u2014 simply because it's such a habit from non-python work. Unfortunately, if you make this mistake in python, you won't get an error message or any other clear sign that you did something wrong, because the up-carat IS a legitimate arithmetic operator in python! It just doesn't do what you think it should. It does \"bitwise exclusive or\", an obscure binary-logic operation you'll probably never need. So if you accidentally use ^ instead of ** , your calculation or program will probably run without errors. You'll either pull your hair out trying to figure out why its results are wacky, or \u2014 worse \u2014 be blithely ignorant that they're totally wrong. You have been warned. \ud83d\udc40 Modulo % (Also called the modulus operator.) x % y yields the remainder when \\(x\\) is divided by \\(y\\) . For example, 7 % 3 yields 1 , and 7.5 % 3 yields 1.5 . Floor Division // This is complementary to modulo. x % y yields the integer number of times that \\(y\\) divides into \\(x\\) \u2014 in other words, the integer part of \\(x \\div y\\) , discarding the remainder. You can be confident that you understand these operators when it's obvious to you why (x // y) * y + x % y always evaluates to the same value as x / y . Modulo and floor division don't show up much in physics, but they can be surprisingly useful in simplifying the logic of a program. For example, if you're iterating over \\(N\\) things in groups of \\(m\\) at a time, N // m is the number of full-sized groups you'll process and N % m is the number \"left over\" for a final, undersized group.","title":"the binary operators"},{"location":"topics/core/operators/#the-unary-operator","text":"Unary operators act on a single quantity. Python only has two you're likely to need (unless you get into bitwise binary logic), and only one is meant for numeric calculations. (We'll meet the other one in an upcoming encounter with Boolean Logic .) Negation: - Sticking a minus sign in front of a numerical quantity flips its sign, from positive to negative or negative to positive, exactly as you would expect. -3 + 4 will evaluate to 1 , and -(2 - 5) to 3 . How does python know whether to interpret - as a binary subtraction operator or a unary negation operator? I can't think of an expression in which both interpretations of a particular - are syntactically legal.","title":"the unary operator"},{"location":"topics/core/operators/#the-assignment-operators","text":"It's fairly common in coding to want to set a variable's value to \"its current value plus \\(k\\) \" or \"its current value minus \\(k\\) or \" \\(n\\) times its current value\" or \"one- \\(n^\\text{th}\\) of its current value\", or something like that. The point is that you want to change the value of a variable to be the result of a simple algebraic expression involving its current value. This is easy enough to do with the algebraic operators above: x = x + k , x = x - k , x = x * n , x = x / n , etc. However, because this is so common, python offers you some shortcuts that are slightly more compact, and definitely quicker for a human reader to digest: the assignment operators . shortcut is equivalent to shortcut is equivalent to a += b a = a + b a **= b a = a**b a -= b a = a - b a %= b a = a % b a *= b a = a * b a //= b a = a // b a /= b a = a / b","title":"the assignment operators"},{"location":"topics/core/operators/#the-importance-of-whitespace","text":"The python interpreter doesn't care whether you put space characters around your operators or not. As far as it is concerned, m=32/-2 , m = 32 / - 2 , m = 32/- 2 , m = 32/ - 2 , m=32 / -2 , and m = 32 / -2 are all entirely equivalent. However\u2026 which is easiest for a human to interpret at a glance? That is NOT a small consideration! Important: Strive to make your code, and especially your numerical calculations, as clear and easy-to-read as possible. Adopting this habit will drastically reduce the likelihood that your calculations will contain unintended errors, and will make it easier for you to find errors when you're debugging. It will also reduce the cognitive burden on someone reading the code to figure out what it does. (That someone might very well be you, in the future, trying to remember WTH you were thinking when you wrote it.) As a general rule: Unless you have a very specific reason to do otherwise, Put one space character on either side of a binary operator. That makes it easier to distinguish the operators from their operands. Exception: Don't put spaces around ( ** ) for exponentiation. That helps a reader quickly distinguish it from multiplication. And, as you'll see soon in operator precedence , it better communicates the order in which the operations will occur. Don't put a space between a unary minus and the value it's negating. That makes clear it's a sign flip, not a subtraction. Put a space on either side of an assignment operator, whether that be normal assignment with = or one of the shortcut operators like += . That makes it easier to visually distinguish the expression to evaluate from the variable it's assigned to. (The \"walrus operator\" is a bit of a special case, because it usually needs parentheses to have the intended effect. More on this later.) Remember, space characters don't cost you anything and don't run out. You don't get bonus points for making your code as dense as possible. Quite the contrary \u2014 readability does count!","title":"the importance of whitespace"},{"location":"topics/core/precedence/","text":"Operator Precedence TBW\u2026","title":"Operator Precedence"},{"location":"topics/core/precedence/#operator-precedence","text":"TBW\u2026","title":"Operator Precedence"},{"location":"topics/scipy/numpy/","text":"Introduction to Numpy TBW\u2026","title":"Introduction to Numpy"},{"location":"topics/scipy/numpy/#introduction-to-numpy","text":"TBW\u2026","title":"Introduction to Numpy"},{"location":"topics/tools/github/","text":"Useful Links About Git and GitHub An Intro to Git and GitHub for Beginners (Tutorial)","title":"Useful Links About Git and GitHub"},{"location":"topics/tools/github/#useful-links-about-git-and-github","text":"An Intro to Git and GitHub for Beginners (Tutorial)","title":"Useful Links About Git and GitHub"}]}