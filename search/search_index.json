{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"PHY 351 Reference Course Administrivia Course syllabus Recipes This compendium of computational physics \"recipes\" is the primary reference material of the PHY 351 course. Rather than reading it straight through, as you might a traditional textbook, let the course assignments guide you. The various exercises each specify one recipe that you are to try for yourself; that is a good time to read the recipe in detail. You'll probably want to refer back to prior recipes at least occasionally, until you've internalized them. What is a \"recipe\"? World A: Core Python World B: Numerical Methods 1 \u2014 Numerical Solving, Finding & Randomness World C: Scientific Python World D: Numerical Methods 2: Numerical Calculus World E: Visual Python Topics This section of the website contains a grab-bag of miscellaneous general reference information, tips about using python, and links to helpful outside resources. Some of the recipes link to specific topics here for further detail.","title":"PHY 351 Reference"},{"location":"#phy-351-reference","text":"","title":"PHY 351 Reference"},{"location":"#course-administrivia","text":"Course syllabus","title":"Course Administrivia"},{"location":"#recipes","text":"This compendium of computational physics \"recipes\" is the primary reference material of the PHY 351 course. Rather than reading it straight through, as you might a traditional textbook, let the course assignments guide you. The various exercises each specify one recipe that you are to try for yourself; that is a good time to read the recipe in detail. You'll probably want to refer back to prior recipes at least occasionally, until you've internalized them. What is a \"recipe\"? World A: Core Python World B: Numerical Methods 1 \u2014 Numerical Solving, Finding & Randomness World C: Scientific Python World D: Numerical Methods 2: Numerical Calculus World E: Visual Python","title":"Recipes"},{"location":"#topics","text":"This section of the website contains a grab-bag of miscellaneous general reference information, tips about using python, and links to helpful outside resources. Some of the recipes link to specific topics here for further detail.","title":"Topics"},{"location":"admin/syllabus/","text":"Physics 351 Spring 2025 Course Syllabus Version 1.1, 2025-01-16 Welcome to PHY 351, Introduction to Computational Physics ! Computers have become essential in all aspects of physics. That shouldn't surprise you, because they've become essential in almost all aspects of almost anything; even my toothbrush has a tiny computer in it, and I didn't even get the version that talks to an iPhone app \ud83d\ude26. Let's zoom in on a key function of computers in physics: they can do math for us. In experimental physics , computers can analyze huge quantities of data in extraordinarily sophisticated ways (in addition to controlling the apparatus and collecting the data). In theoretical physics , they can perform calculations and solve equations that would be difficult or even impossible with analytic (\"paper-and-pencil\") methods alone. They've also created a third branch of physics, computational physics , in which we use direct computer simulation of physical systems (rather than physical experiments or analytic modeling) to explore their behavior and develop understanding. Much of the software to do such things is custom-written by physicists, using specialized coding tools and approaches. Skill with these tools and approaches is a scientific superpower that will pay off over and over, whether you stay in physics or take your skills to something else \u2014 like, for example, epidemiology, computational immunology, or financial modeling. The purpose of this course is to show you the foundational tools and methods of computational physics, and to start your journey along the path from beginner \u2192 fluent \u2192 expert. Administrivia Catalog information Credits: 3 (3:3:0 \u21d2 150 min/wk in class + 6-ish hrs/wk outside class for a \u201ctypical\u201d course). Course format: Face-to-face synchronous on-campus, technically (but not really, see below). Prerequisites: Grade of C or better in both PHY 292 and CSC 120, or permission of instructor. Corequisites: PHY 321, or permission of instructor. Corequisite need not be taken concurrently; prior completion is adequate. For whom planned: This course is designed for Physics majors, and is required for the Physics BS and BA degrees. Bulletin description: Introduction to computational methods used in physics and engineering, including computational simulation of physical systems, numerical solution of mathematical problems, and familiarity with scientific programming tools. Instructor information Instructor: Associate Prof. Ian D. Beatty (he, him, his) Email: idbeatty@uncg.edu Office: Petty 328 Phone: 336.256.1279 (goes to MS Teams, not my actual phone, so \ud83e\udd37\u200d\u2642\ufe0f) Physics & Astro Slack: @Beatty Twitter : Nope. So done with that. Instead, Bluesky : @ianbeatty.com Office Hours: To be announced \u2014 once I find out what days & times work best for y\u2019all. In the meantime, ask me when you can drop by, or make an appointment. Office hours are in person (Petty 328) or via MS Teams (with prior notice so I can start it up), as you prefer. Connection details are on the course Canvas site. Communication Slack is generally the fastest way to reach me. (Details are on Canvas .) Email is safer for something that must not fall through the cracks, but you may have to wait a few hours or even until the next day. I try to be responsive during off-hours, especially to things that might prevent you from working productively, but please do not assume you can reliably get my attention during evenings or weekends. I have three kids and an under-maintained house that need my attention too. I will occasionally need to reach you, personally or collectively, about important course changes, reminders, or issues. It is essential that you receive and actually read messages I send to your UNCG email address, either directly or via Canvas course announcements. Please configure your Canvas notification settings, email filters, and personal habits accordingly. Course Objectives Overall Goal Consider learning a foreign language: Knowing the meaning of a collection of words is marginally useful if you're trying to communicate with someone. Being fluent is orders of magnitude more useful, and lets you communicate things that are orders of magnitude more complex. One part of \"fluency\" is having practiced the translation of words often enough that it becomes automatic in your head, so you don't have to think about it. Another part is knowing a toolkit of idioms and other common language patterns for accomplishing specific communication goals. Knowing an idiom or pattern for a particular idea means I don't have to figure out how to piece words together to communicate it; that problem is already solved. I just reiterate the pattern, tweaking it as appropriate for the situation at hand. This course is organized around the idea that much of the challenge of becoming \"fluent\" with scientific coding is assembling a mental library of common idioms and patterns \u2014 known ways to arrange chunks of code to accomplish specific kinds of tasks. We'll call them recipes . Some are one-liners, some are patterns spread over many lines of code or even an entire program, and some are just sequences of steps to follow. All have the same purpose: Faced with a computational task, knowing a recipe for it means you don't have to stare at the screen and wonder how to start. The \"course content\" is a collection of recipes for you to learn. They are organized on a website, for convenient access. We have no textbook or other reading material, except for miscellaneous online reference materials to supplement the recipes. Learning Objectives By learning what the recipes accomplish and how to apply them, you will achieve the course learning outcomes: Be able to use the \"scientific python stack\" to perform interactive calculations, write programs, run programs, and work with data. This \"stack\" includes the core python language; scientific python libraries (specifically numpy , matplotlib , and scipy ); git and GitHub ; and the JupyterLab environment and its tools. Be able to construct and customize publication-quality data plots, with features like error bars and best-fit lines. Understand computer representations of numbers and their implications for accuracy and efficiency. Be able to create animated three-dimensional visual simulations of physical systems. Know and be able to apply some foundational \"numerical methods\" for doing math computationally, including solving nonlinear equations, finding the maxima and minima of functions, calculating derivatives and integrals, and solving ordinary differential equations. Philosophy and Instructional Approach I started programming in seventh grade when I went to junior high school, met friends who had Apple II computers, and encountered BASIC. It rocked my world, magnitude 9.5. Since then I've written functional, useful code in at least a dozen different programming languages, and dabbled with a dozen more. During that entire time I've taken precisely one programming course, in high school. Almost everything I've learned about coding and computer use has been self-taught. I firmly believe that one learns coding by doing it, not by reading about it or listening to someone explain it. Learning to program, and writing programs, and getting better at it is endless problem-solving , problem after problem after problem. You can embrace the struggle and enjoy the puzzles, or\u2026 \ud83d\ude35 Consequently, this course consists almost entirely of you working your way through a carefully-orchestrated sequence of computational physics challenges. I won't be lecturing or assigning readings. I've tried to give you enough initial orientation to each challenge and enough supporting reference material that you'll have a pretty good idea how to proceed. You will get stuck on things and encounter moments of confusion and, yes, frustration. That's not only normal, it's desirable: because that flash of insight or key bit of information that gets you unstuck and unconfused is where the most important learning happens. However, you are NOT meant to struggle through this alone and intolerably frustrated. One part of my role in the course is to create the structure and scaffolding for you to work through. Another is to be available to help you when, where, and how you need: to answer a question, to suggest a better approach, to inform you of a key language feature you are unaware of, to help you find a bug, to interpret a mysterious error message, and so on. This is way more efficient for both of us, and way more effective for you than, if I tried to pre-warn you of everything you might struggle with and everything you might need to know. You are also welcome to support each other, as-comrades-in-arms, as long as you mind the boundary between \"getting help\" and \"plagiarizing\". For specifics on that boundary, see the Academic Integrity Policy section below. And, I'll be showing you some ways that you can leverage AI tools to help you faster and better; see the Artificial Intelligence Policy section below. Textbook and Technology Course \"Textbook\" This course has no textbook. Why? I'm glad you asked\u2026 One of the most difficult aspects of learning to code \u2014 for physics, or any other purpose \u2014 is staring at a blank code editor with only a general, fuzzy idea of what you want to accomplish, and no clear idea of what code to write to accomplish it. This is the coder's version of the writer's \"blank page problem\". Ever been there? Yeah, me too. If you've solved similar coding problems before, then you can probably start by recreating what you did and modifying it. But what if you haven't? If you can find an example of someone else's solution to a similar problem, you may be able to copy and modify it\u2026 though depending on the complexity of the problem and the transparency or opaqueness of the example, understanding it well enough to know what to modify (and how), without breaking anything, may be be hair-pullingly infuriating. My solution to this is to offer you a cookbook of \"recipes\" \u2014 starting points that show you how to accomplish various common kinds of coding and computational physics tasks. They are meant to be clear, especially about which bits are essential and which are meant for you to fit to your specific needs. They also include examples, and sometimes variations upon the basic recipe for situations that are similar but differ in some important way. Some recipes are procedural, describing a sequence of steps for you to follow. Some are syntactic, showing specific python code to accomplish a task. Some are structural, recommending approaches to organizing code in pursuit of your goal. Often, recipes include key conceptual and/or informational knowledge about python, numerical methods, and the practice of computational physics. Understanding the ideas and knowing the facts is an essential part of using the recipes correctly, flexibly, and successfully. The collection of recipes is available to you on a website linked to from Canvas. Technology Our course Canvas site will serve as (a) a place to put general information such as my contact info, (b) a place for announcements, and (c) a place to keep track of the assignments you've completed. We'll use the GitHub website to distribute assignments to you and for you to submit your completed work back to me. (Don't worry, walking you through the setup and process for this is all in World A, Level 1.) You'll do your actual coding-and-running on Beskar , the name I've given to the 48-core, 384-GB beast of a computational physics server that sits on my desk. You'll connect to it from wherever you want via web browser, so you don't need to worry about installing anything on your own computer, or whether your decrepit old laptop can manage. Outside of class, the best way for us to communicate outside of class time is via Slack . Details are on Canvas. You are, of course, welcome to drop in on me during my open-office hours (listed on Canvas), or to make an appointment if that works better. It's really helpful for me to be able to send the occasional short, all-class announcement via Slack, so I really hope we can get everyone on board. Assignments, Grading, and Grades To understand the structure of this course, don't look to other courses you've taken\u2026 Look to video games! \ud83d\udd79\ufe0f Organization Content material of the course, and the assignments accompanying it, is divided into five Worlds : World A: Core Python World B: Numerical Solving, Finding & Randomness World C: Scientific Python World D: Numerical Calculus World E: Visual Python for Simulation Each world is divided into several (~3-9) Levels . That's too many to list here, so you can find them in the Modules section on Canvas. (Warning: That's a work in progress. Levels for the first worlds will appear soon/already; later ones will appear\u2026 later. We're building this airplane as we fly! \ud83d\ude2c) Just like a videogame level has a sequence of challenges followed by a level boss, a course \"level\" has a sequence of exercises followed by what I'm calling a miniboss . Each exercise targets one particular computational physics recipe . (See below; for now, think of that as one skill or idea.) The miniboss is a somewhat more complex challenge that requires you to combine several of the level's recipes. In addition to its levels, each world ends with a superboss challenge: A considerably more complex, authentic computational physics investigation. In addition to identifying and applying the various recipes, you'll need to manage greater complexity and make important judgment calls about how to approach it. You'll also need to write up a bit of an \"investigation report\" documenting what your investigation revealed. The whole course is kicked off by a brief Intro with a couple of super-easy warm-up levels, and ended by an Outro that's really just a final reflection assignment. This set of levels (exercises and miniboss), superbosses, and the intro/outro bits are the only required work in the course. It has no quizzes, exams, attendance requirements, papers, or other such things. \ud83e\udd73 Learn by doing, and prove it by having done. Assignment Grading Let's call a level, superboss, or intro/outro level-type thing an \"assignment\". Every assignment is graded on an entirely all-or-nothing basis: Either it meets all the assignment specifications and is accepted, or it does not and is rejected. (Video game analogy: Either you make it through the level, or you die.) Fortunately, rejected just means \"not accepted yet\". You can fix and resubmit an assignment as often as necessary to meet all the specs and be accepted. (Analogy: If you die, you start the level over.) You will progress much faster, and experience much less frustration, if you can figure out whether your solution meets ALL the specs BEFORE submitting it. (You'll also keep me sane.) To help with that, most assignments come packaged with a battery of automated tests that will check your solution. You can MUST run and pass this before submitting it to me for verification. The test code won't catch absolutely everything, but should catch most errors and oversights. If we both do our jobs well, all I have to do is rubber-stamp your submission; you can already be confident that it will pass. (Analogy: When you screw up in a video game, you discover it immediately and usually dramatically.) Course Grades You begin the course as a Rank 0 computational physicist. Every time you successfully complete an assignment (level or superboss), you level up one rank. Simple, no? Ranks correspond to course grades . The higher your rank at the end of the course, the higher your final grade. The final rank-to-grade table is not yet finalized, since I haven't yet nailed down exactly what all the levels will be, and (more seriously) I am unsure how realistic my plan is. Here's a tentative version: grade: A A\u2013 B+ B B\u2013 C+ C C\u2013 D+ D D\u2013 F rank: 27 25 24 22 21 20 18 17 15 14 13 0 Note that your rank can never decrease (barring some kind of academic integrity or course administration disaster). The implication is that once you've levelled up to a certain grade, that's the lowest grade you can possibly earn no matter what happens for the remainder of the semester . So relax! The only way to shoot yourself in the foot is to proceed too slowly. Due Dates Let me reiterate that: The only way to shoot yourself in the foot is to proceed too slowly. The course is entirely self-paced. The only deadline is the end-of-term one I'm imposing so that I have time to process the last batch of submissions and enter course grades before the University-imposed deadline for grade submission. Only work that meets all assignment specifications and is submitted by the end of the day (midnight) on Wednesday March 07 will count for course credit. Take note: I am giving you a whole lot of rope to hang yourself with. If you fail to set a good pace right from the start of the course, you will be in a whole world of hurt when the end of the semester hurtles towards you. \\[ \\frac{d}{dt}\\left(\\text{successful level completion}\\right) \\approx \\frac{\\text{desired grade}}{\\text{remaining time}} \\] Note that as the remaining time decreases, the rate at which you must pass levels limits to infinity. And remember: Later assignments are harder. Superbosses take longer than minibosses, which take longer than exercises. Your other courses will likely get busier towards the end of the semester, leaving you less time for this one. When you start feeling the panic of the end-of-term approaching, you'll shift from a mindset of \"take the time to figure this stuff out\" to \"frantically try different things hoping to make the damn tests pass\". The latter is generally LESS efficient, and definitely produces less actual learning. It's also just a sucky place to be, psychologically. I will undoubtedly get quite busy with late-semester submissions, leaving me less time to kick back no-pass assignments quickly or help you when you're stuck. You may not have time for multiple submit-correct-resubmit cycles near the end, and if you're rushing, kickbacks become more likely. You have been warned. \ud83e\uddd0 Policies Attendance Policy Given what you've read so far, you might be wondering what the purpose of class meetings is, and whether you need bother attending. Good question! Attending the first class or two will be critical for getting you up and running with our workflow: the various accounts, login identities, and tools you'll need to \"do work\" in this course. After that, class time is really nothing other than a place and time for you to work while I and other students are close at hand to answer questions and help you get unstuck. Don't underestimate the value of instantaneous on-call support. Plus, having at least that 150 minutes per week of distraction-free time committed to the course can be a big help in keeping you on track. I reserve the right to declare any particular class meeting \"mandatory\", with advance warning to you. I would do this if, for example, I've got something important to show or discuss with you that does not lend itself well to written channels, and that should be of value to all the students. Spoiler alert: I intend to do this one day early on to demonstrate some ways of using AI tools to help you learn course skillz faster and better. Missing such a \"mandatory\" class would incur no grade penalty aside from the natural consequences of missing out. The room we've been assigned is inconvenient. We may collectively agree to move class to a more convenient venue in Petty. For any particular class meeting, if nobody shows up for the start of class, I will probably go back to my office after a few minutes. You can still find me there. Either way, I will be \"on call\" for you between 2:00 and 3:15 every Monday and Wednesday afternoon. 1 Late Work Policy You saw the part above about \"no deadlines except for the final end-of-term submission deadlines\", right? Late work is a non-issue in this course. That being said: Do not ask me for an \"incomplete\" simply because you haven't quite finished everything you wanted to by the deadlines. According to the UNCG Catalog, a grade of incomplete \"indicates that the completion of some part of the work for the course has been deferred because of prolonged illness of the student or because of some serious circumstances beyond the student\u2019s control.\" Accommodations UNCG seeks to comply fully with the Americans with Disabilities Act (ADA). Students requesting accommodations based on a disability must be registered with the Office of Accessibility Resources and Services (OARS, 215 Elliott University Center, 336.334.5440, http://oars.uncg.edu ). Academic Integrity Policy You are, of course, expected to know and heed the University\u2019s Academic Integrity Policy . Violations will be reported to the Dean of Students. A second violation at any time during your years as a student here leads to automatic suspension or expulsion, so this is serious stuff. https://osrr.uncg.edu/academic-integrity-policy-pledge/ As stated above, I encourage you to help each other and to work together to figure things out, but any work you submit must be your own and represent your own understanding. Here's the bright red line: Every line of code you submit must be crafted by you.* Not just typed, but crafted . Someone else can suggest a technique, or tell you that you need a third argument to something-or-other function, or point out the location of a syntax error in your code, but they can\u2019t type it for you. They can\u2019t dictate what you should type. They can\u2019t give you a copy of their code to copy-paste or mimic. You can discuss solutions with other students, but you should then write up your code by yourself, starting from an empty screen. If you can\u2019t do that, you don\u2019t really understand it, and it\u2019s dishonest to pretend that you do. If at any time you are in doubt about where to draw the line between collaboration and plagiarism, ask me to clarify. My experience is that the Physics majors who take this course are ethical and conscientious students who genuinely want to learn the topic and not just cheat their way to an undeserved grade. However, even usually-trustworthy students can make bad choices when they get overwhelmed and desperate. Recognize the temptation and ask me for help! Even better, don\u2019t let yourself fall behind to the point that you might be so tempted. And don\u2019t lend your solutions to another student, even to \u201cjust learn from, not copy.\u201d That rarely ends well for anyone. Code is inevitably idiosyncratic. Everyone's looks a little different in myriad ways that are really hard to fake, and I notice uncanny similarities even without looking for them. Don't take the chance. Seriously, don\u2019t jeopardize your reputation. Trust is easy to lose and very, very hard to regain. Artificial Intelligence Policy By the way, you may have noticed the asterisk * on the above \"bright red line\". That's because of AI. Tools like ChatGPT are changing the way coding is done, very dramatically and rapidly, and I'd rather help you learn how to ride that wave than hold you back. So, I'll show you some ways to use AI tools to accelerate rather than bypass your computational physics learning. I'll share the \"what to do\" details as we go. The explosive arrival and improvement of AI tools like ChatGPT over the past couple of years have caused quite a furor within universities. Is it cheating for students to consult an AI tool for help on an assignment, or an improvement in learning efficiency? Does it bypass learning, or does it develop new skills that will be critical in the near-future economy? Well, duh. All of the above, obviously. It depends very much on how the AI is used. In that way it's no different from consulting a classmate or other human for help: They could help you learn, or save you the trouble of learning. One big difference here is that unlike a human, an AI can't make the judgment call about whether what you're asking is ethical, or about the best way to support your learning. So, that's all on you. I'll say a bit more about specific do's and don'ts soon, when I show you some really cool ways to leverage AI. For now, here's the general rule: Ask an AI tool to answer general questions, suggest general approaches, explain specific functions or language features, give you an example of code that uses a particular function or language feature, identify a bug in your code that you can't find, or offer suggestions on a block of your code. Do not have an AI tool produce code to solve your specific course assignment problems, and do not present code written by an AI as part of your own. Here's one other requirement: Any time you use an AI to help you with an assignment, you must say how in your submission. You can do that by including some comment lines in your code, or including a note in a separate markdown/text file you add to the submission file, or whatever makes sense in the context. The most important reason for this is that I want to learn how y'all are using AI, so that I can get better at helping you learn to get better at using it! This is new terrain for all of us. When in doubt, let's talk it out. I haven't figured it all out either. \ud83d\ude35\u200d\ud83d\udcab Congratulations for making it all the way to the end! \ud83c\udfc6 As of the time I'm writing this, I am recovering from a serious health issue that may affect some of the details of my availability during the Spring 2025 semester in ways I don't yet know. I'll keep you posted. \u21a9","title":"Syllabus"},{"location":"admin/syllabus/#physics-351-spring-2025-course-syllabus","text":"Version 1.1, 2025-01-16 Welcome to PHY 351, Introduction to Computational Physics ! Computers have become essential in all aspects of physics. That shouldn't surprise you, because they've become essential in almost all aspects of almost anything; even my toothbrush has a tiny computer in it, and I didn't even get the version that talks to an iPhone app \ud83d\ude26. Let's zoom in on a key function of computers in physics: they can do math for us. In experimental physics , computers can analyze huge quantities of data in extraordinarily sophisticated ways (in addition to controlling the apparatus and collecting the data). In theoretical physics , they can perform calculations and solve equations that would be difficult or even impossible with analytic (\"paper-and-pencil\") methods alone. They've also created a third branch of physics, computational physics , in which we use direct computer simulation of physical systems (rather than physical experiments or analytic modeling) to explore their behavior and develop understanding. Much of the software to do such things is custom-written by physicists, using specialized coding tools and approaches. Skill with these tools and approaches is a scientific superpower that will pay off over and over, whether you stay in physics or take your skills to something else \u2014 like, for example, epidemiology, computational immunology, or financial modeling. The purpose of this course is to show you the foundational tools and methods of computational physics, and to start your journey along the path from beginner \u2192 fluent \u2192 expert.","title":"Physics 351 Spring 2025 Course Syllabus"},{"location":"admin/syllabus/#administrivia","text":"","title":"Administrivia"},{"location":"admin/syllabus/#catalog-information","text":"Credits: 3 (3:3:0 \u21d2 150 min/wk in class + 6-ish hrs/wk outside class for a \u201ctypical\u201d course). Course format: Face-to-face synchronous on-campus, technically (but not really, see below). Prerequisites: Grade of C or better in both PHY 292 and CSC 120, or permission of instructor. Corequisites: PHY 321, or permission of instructor. Corequisite need not be taken concurrently; prior completion is adequate. For whom planned: This course is designed for Physics majors, and is required for the Physics BS and BA degrees. Bulletin description: Introduction to computational methods used in physics and engineering, including computational simulation of physical systems, numerical solution of mathematical problems, and familiarity with scientific programming tools.","title":"Catalog information"},{"location":"admin/syllabus/#instructor-information","text":"Instructor: Associate Prof. Ian D. Beatty (he, him, his) Email: idbeatty@uncg.edu Office: Petty 328 Phone: 336.256.1279 (goes to MS Teams, not my actual phone, so \ud83e\udd37\u200d\u2642\ufe0f) Physics & Astro Slack: @Beatty Twitter : Nope. So done with that. Instead, Bluesky : @ianbeatty.com Office Hours: To be announced \u2014 once I find out what days & times work best for y\u2019all. In the meantime, ask me when you can drop by, or make an appointment. Office hours are in person (Petty 328) or via MS Teams (with prior notice so I can start it up), as you prefer. Connection details are on the course Canvas site.","title":"Instructor information"},{"location":"admin/syllabus/#communication","text":"Slack is generally the fastest way to reach me. (Details are on Canvas .) Email is safer for something that must not fall through the cracks, but you may have to wait a few hours or even until the next day. I try to be responsive during off-hours, especially to things that might prevent you from working productively, but please do not assume you can reliably get my attention during evenings or weekends. I have three kids and an under-maintained house that need my attention too. I will occasionally need to reach you, personally or collectively, about important course changes, reminders, or issues. It is essential that you receive and actually read messages I send to your UNCG email address, either directly or via Canvas course announcements. Please configure your Canvas notification settings, email filters, and personal habits accordingly.","title":"Communication"},{"location":"admin/syllabus/#course-objectives","text":"","title":"Course Objectives"},{"location":"admin/syllabus/#overall-goal","text":"Consider learning a foreign language: Knowing the meaning of a collection of words is marginally useful if you're trying to communicate with someone. Being fluent is orders of magnitude more useful, and lets you communicate things that are orders of magnitude more complex. One part of \"fluency\" is having practiced the translation of words often enough that it becomes automatic in your head, so you don't have to think about it. Another part is knowing a toolkit of idioms and other common language patterns for accomplishing specific communication goals. Knowing an idiom or pattern for a particular idea means I don't have to figure out how to piece words together to communicate it; that problem is already solved. I just reiterate the pattern, tweaking it as appropriate for the situation at hand. This course is organized around the idea that much of the challenge of becoming \"fluent\" with scientific coding is assembling a mental library of common idioms and patterns \u2014 known ways to arrange chunks of code to accomplish specific kinds of tasks. We'll call them recipes . Some are one-liners, some are patterns spread over many lines of code or even an entire program, and some are just sequences of steps to follow. All have the same purpose: Faced with a computational task, knowing a recipe for it means you don't have to stare at the screen and wonder how to start. The \"course content\" is a collection of recipes for you to learn. They are organized on a website, for convenient access. We have no textbook or other reading material, except for miscellaneous online reference materials to supplement the recipes.","title":"Overall Goal"},{"location":"admin/syllabus/#learning-objectives","text":"By learning what the recipes accomplish and how to apply them, you will achieve the course learning outcomes: Be able to use the \"scientific python stack\" to perform interactive calculations, write programs, run programs, and work with data. This \"stack\" includes the core python language; scientific python libraries (specifically numpy , matplotlib , and scipy ); git and GitHub ; and the JupyterLab environment and its tools. Be able to construct and customize publication-quality data plots, with features like error bars and best-fit lines. Understand computer representations of numbers and their implications for accuracy and efficiency. Be able to create animated three-dimensional visual simulations of physical systems. Know and be able to apply some foundational \"numerical methods\" for doing math computationally, including solving nonlinear equations, finding the maxima and minima of functions, calculating derivatives and integrals, and solving ordinary differential equations.","title":"Learning Objectives"},{"location":"admin/syllabus/#philosophy-and-instructional-approach","text":"I started programming in seventh grade when I went to junior high school, met friends who had Apple II computers, and encountered BASIC. It rocked my world, magnitude 9.5. Since then I've written functional, useful code in at least a dozen different programming languages, and dabbled with a dozen more. During that entire time I've taken precisely one programming course, in high school. Almost everything I've learned about coding and computer use has been self-taught. I firmly believe that one learns coding by doing it, not by reading about it or listening to someone explain it. Learning to program, and writing programs, and getting better at it is endless problem-solving , problem after problem after problem. You can embrace the struggle and enjoy the puzzles, or\u2026 \ud83d\ude35 Consequently, this course consists almost entirely of you working your way through a carefully-orchestrated sequence of computational physics challenges. I won't be lecturing or assigning readings. I've tried to give you enough initial orientation to each challenge and enough supporting reference material that you'll have a pretty good idea how to proceed. You will get stuck on things and encounter moments of confusion and, yes, frustration. That's not only normal, it's desirable: because that flash of insight or key bit of information that gets you unstuck and unconfused is where the most important learning happens. However, you are NOT meant to struggle through this alone and intolerably frustrated. One part of my role in the course is to create the structure and scaffolding for you to work through. Another is to be available to help you when, where, and how you need: to answer a question, to suggest a better approach, to inform you of a key language feature you are unaware of, to help you find a bug, to interpret a mysterious error message, and so on. This is way more efficient for both of us, and way more effective for you than, if I tried to pre-warn you of everything you might struggle with and everything you might need to know. You are also welcome to support each other, as-comrades-in-arms, as long as you mind the boundary between \"getting help\" and \"plagiarizing\". For specifics on that boundary, see the Academic Integrity Policy section below. And, I'll be showing you some ways that you can leverage AI tools to help you faster and better; see the Artificial Intelligence Policy section below.","title":"Philosophy and Instructional Approach"},{"location":"admin/syllabus/#textbook-and-technology","text":"","title":"Textbook and Technology"},{"location":"admin/syllabus/#course-textbook","text":"This course has no textbook. Why? I'm glad you asked\u2026 One of the most difficult aspects of learning to code \u2014 for physics, or any other purpose \u2014 is staring at a blank code editor with only a general, fuzzy idea of what you want to accomplish, and no clear idea of what code to write to accomplish it. This is the coder's version of the writer's \"blank page problem\". Ever been there? Yeah, me too. If you've solved similar coding problems before, then you can probably start by recreating what you did and modifying it. But what if you haven't? If you can find an example of someone else's solution to a similar problem, you may be able to copy and modify it\u2026 though depending on the complexity of the problem and the transparency or opaqueness of the example, understanding it well enough to know what to modify (and how), without breaking anything, may be be hair-pullingly infuriating. My solution to this is to offer you a cookbook of \"recipes\" \u2014 starting points that show you how to accomplish various common kinds of coding and computational physics tasks. They are meant to be clear, especially about which bits are essential and which are meant for you to fit to your specific needs. They also include examples, and sometimes variations upon the basic recipe for situations that are similar but differ in some important way. Some recipes are procedural, describing a sequence of steps for you to follow. Some are syntactic, showing specific python code to accomplish a task. Some are structural, recommending approaches to organizing code in pursuit of your goal. Often, recipes include key conceptual and/or informational knowledge about python, numerical methods, and the practice of computational physics. Understanding the ideas and knowing the facts is an essential part of using the recipes correctly, flexibly, and successfully. The collection of recipes is available to you on a website linked to from Canvas.","title":"Course \"Textbook\""},{"location":"admin/syllabus/#technology","text":"Our course Canvas site will serve as (a) a place to put general information such as my contact info, (b) a place for announcements, and (c) a place to keep track of the assignments you've completed. We'll use the GitHub website to distribute assignments to you and for you to submit your completed work back to me. (Don't worry, walking you through the setup and process for this is all in World A, Level 1.) You'll do your actual coding-and-running on Beskar , the name I've given to the 48-core, 384-GB beast of a computational physics server that sits on my desk. You'll connect to it from wherever you want via web browser, so you don't need to worry about installing anything on your own computer, or whether your decrepit old laptop can manage. Outside of class, the best way for us to communicate outside of class time is via Slack . Details are on Canvas. You are, of course, welcome to drop in on me during my open-office hours (listed on Canvas), or to make an appointment if that works better. It's really helpful for me to be able to send the occasional short, all-class announcement via Slack, so I really hope we can get everyone on board.","title":"Technology"},{"location":"admin/syllabus/#assignments-grading-and-grades","text":"To understand the structure of this course, don't look to other courses you've taken\u2026 Look to video games! \ud83d\udd79\ufe0f","title":"Assignments, Grading, and Grades"},{"location":"admin/syllabus/#organization","text":"Content material of the course, and the assignments accompanying it, is divided into five Worlds : World A: Core Python World B: Numerical Solving, Finding & Randomness World C: Scientific Python World D: Numerical Calculus World E: Visual Python for Simulation Each world is divided into several (~3-9) Levels . That's too many to list here, so you can find them in the Modules section on Canvas. (Warning: That's a work in progress. Levels for the first worlds will appear soon/already; later ones will appear\u2026 later. We're building this airplane as we fly! \ud83d\ude2c) Just like a videogame level has a sequence of challenges followed by a level boss, a course \"level\" has a sequence of exercises followed by what I'm calling a miniboss . Each exercise targets one particular computational physics recipe . (See below; for now, think of that as one skill or idea.) The miniboss is a somewhat more complex challenge that requires you to combine several of the level's recipes. In addition to its levels, each world ends with a superboss challenge: A considerably more complex, authentic computational physics investigation. In addition to identifying and applying the various recipes, you'll need to manage greater complexity and make important judgment calls about how to approach it. You'll also need to write up a bit of an \"investigation report\" documenting what your investigation revealed. The whole course is kicked off by a brief Intro with a couple of super-easy warm-up levels, and ended by an Outro that's really just a final reflection assignment. This set of levels (exercises and miniboss), superbosses, and the intro/outro bits are the only required work in the course. It has no quizzes, exams, attendance requirements, papers, or other such things. \ud83e\udd73 Learn by doing, and prove it by having done.","title":"Organization"},{"location":"admin/syllabus/#assignment-grading","text":"Let's call a level, superboss, or intro/outro level-type thing an \"assignment\". Every assignment is graded on an entirely all-or-nothing basis: Either it meets all the assignment specifications and is accepted, or it does not and is rejected. (Video game analogy: Either you make it through the level, or you die.) Fortunately, rejected just means \"not accepted yet\". You can fix and resubmit an assignment as often as necessary to meet all the specs and be accepted. (Analogy: If you die, you start the level over.) You will progress much faster, and experience much less frustration, if you can figure out whether your solution meets ALL the specs BEFORE submitting it. (You'll also keep me sane.) To help with that, most assignments come packaged with a battery of automated tests that will check your solution. You can MUST run and pass this before submitting it to me for verification. The test code won't catch absolutely everything, but should catch most errors and oversights. If we both do our jobs well, all I have to do is rubber-stamp your submission; you can already be confident that it will pass. (Analogy: When you screw up in a video game, you discover it immediately and usually dramatically.)","title":"Assignment Grading"},{"location":"admin/syllabus/#course-grades","text":"You begin the course as a Rank 0 computational physicist. Every time you successfully complete an assignment (level or superboss), you level up one rank. Simple, no? Ranks correspond to course grades . The higher your rank at the end of the course, the higher your final grade. The final rank-to-grade table is not yet finalized, since I haven't yet nailed down exactly what all the levels will be, and (more seriously) I am unsure how realistic my plan is. Here's a tentative version: grade: A A\u2013 B+ B B\u2013 C+ C C\u2013 D+ D D\u2013 F rank: 27 25 24 22 21 20 18 17 15 14 13 0 Note that your rank can never decrease (barring some kind of academic integrity or course administration disaster). The implication is that once you've levelled up to a certain grade, that's the lowest grade you can possibly earn no matter what happens for the remainder of the semester . So relax! The only way to shoot yourself in the foot is to proceed too slowly.","title":"Course Grades"},{"location":"admin/syllabus/#due-dates","text":"Let me reiterate that: The only way to shoot yourself in the foot is to proceed too slowly. The course is entirely self-paced. The only deadline is the end-of-term one I'm imposing so that I have time to process the last batch of submissions and enter course grades before the University-imposed deadline for grade submission. Only work that meets all assignment specifications and is submitted by the end of the day (midnight) on Wednesday March 07 will count for course credit. Take note: I am giving you a whole lot of rope to hang yourself with. If you fail to set a good pace right from the start of the course, you will be in a whole world of hurt when the end of the semester hurtles towards you. \\[ \\frac{d}{dt}\\left(\\text{successful level completion}\\right) \\approx \\frac{\\text{desired grade}}{\\text{remaining time}} \\] Note that as the remaining time decreases, the rate at which you must pass levels limits to infinity. And remember: Later assignments are harder. Superbosses take longer than minibosses, which take longer than exercises. Your other courses will likely get busier towards the end of the semester, leaving you less time for this one. When you start feeling the panic of the end-of-term approaching, you'll shift from a mindset of \"take the time to figure this stuff out\" to \"frantically try different things hoping to make the damn tests pass\". The latter is generally LESS efficient, and definitely produces less actual learning. It's also just a sucky place to be, psychologically. I will undoubtedly get quite busy with late-semester submissions, leaving me less time to kick back no-pass assignments quickly or help you when you're stuck. You may not have time for multiple submit-correct-resubmit cycles near the end, and if you're rushing, kickbacks become more likely. You have been warned. \ud83e\uddd0","title":"Due Dates"},{"location":"admin/syllabus/#policies","text":"","title":"Policies"},{"location":"admin/syllabus/#attendance-policy","text":"Given what you've read so far, you might be wondering what the purpose of class meetings is, and whether you need bother attending. Good question! Attending the first class or two will be critical for getting you up and running with our workflow: the various accounts, login identities, and tools you'll need to \"do work\" in this course. After that, class time is really nothing other than a place and time for you to work while I and other students are close at hand to answer questions and help you get unstuck. Don't underestimate the value of instantaneous on-call support. Plus, having at least that 150 minutes per week of distraction-free time committed to the course can be a big help in keeping you on track. I reserve the right to declare any particular class meeting \"mandatory\", with advance warning to you. I would do this if, for example, I've got something important to show or discuss with you that does not lend itself well to written channels, and that should be of value to all the students. Spoiler alert: I intend to do this one day early on to demonstrate some ways of using AI tools to help you learn course skillz faster and better. Missing such a \"mandatory\" class would incur no grade penalty aside from the natural consequences of missing out. The room we've been assigned is inconvenient. We may collectively agree to move class to a more convenient venue in Petty. For any particular class meeting, if nobody shows up for the start of class, I will probably go back to my office after a few minutes. You can still find me there. Either way, I will be \"on call\" for you between 2:00 and 3:15 every Monday and Wednesday afternoon. 1","title":"Attendance Policy"},{"location":"admin/syllabus/#late-work-policy","text":"You saw the part above about \"no deadlines except for the final end-of-term submission deadlines\", right? Late work is a non-issue in this course. That being said: Do not ask me for an \"incomplete\" simply because you haven't quite finished everything you wanted to by the deadlines. According to the UNCG Catalog, a grade of incomplete \"indicates that the completion of some part of the work for the course has been deferred because of prolonged illness of the student or because of some serious circumstances beyond the student\u2019s control.\"","title":"Late Work Policy"},{"location":"admin/syllabus/#accommodations","text":"UNCG seeks to comply fully with the Americans with Disabilities Act (ADA). Students requesting accommodations based on a disability must be registered with the Office of Accessibility Resources and Services (OARS, 215 Elliott University Center, 336.334.5440, http://oars.uncg.edu ).","title":"Accommodations"},{"location":"admin/syllabus/#academic-integrity-policy","text":"You are, of course, expected to know and heed the University\u2019s Academic Integrity Policy . Violations will be reported to the Dean of Students. A second violation at any time during your years as a student here leads to automatic suspension or expulsion, so this is serious stuff. https://osrr.uncg.edu/academic-integrity-policy-pledge/ As stated above, I encourage you to help each other and to work together to figure things out, but any work you submit must be your own and represent your own understanding. Here's the bright red line: Every line of code you submit must be crafted by you.* Not just typed, but crafted . Someone else can suggest a technique, or tell you that you need a third argument to something-or-other function, or point out the location of a syntax error in your code, but they can\u2019t type it for you. They can\u2019t dictate what you should type. They can\u2019t give you a copy of their code to copy-paste or mimic. You can discuss solutions with other students, but you should then write up your code by yourself, starting from an empty screen. If you can\u2019t do that, you don\u2019t really understand it, and it\u2019s dishonest to pretend that you do. If at any time you are in doubt about where to draw the line between collaboration and plagiarism, ask me to clarify. My experience is that the Physics majors who take this course are ethical and conscientious students who genuinely want to learn the topic and not just cheat their way to an undeserved grade. However, even usually-trustworthy students can make bad choices when they get overwhelmed and desperate. Recognize the temptation and ask me for help! Even better, don\u2019t let yourself fall behind to the point that you might be so tempted. And don\u2019t lend your solutions to another student, even to \u201cjust learn from, not copy.\u201d That rarely ends well for anyone. Code is inevitably idiosyncratic. Everyone's looks a little different in myriad ways that are really hard to fake, and I notice uncanny similarities even without looking for them. Don't take the chance. Seriously, don\u2019t jeopardize your reputation. Trust is easy to lose and very, very hard to regain.","title":"Academic Integrity Policy"},{"location":"admin/syllabus/#artificial-intelligence-policy","text":"By the way, you may have noticed the asterisk * on the above \"bright red line\". That's because of AI. Tools like ChatGPT are changing the way coding is done, very dramatically and rapidly, and I'd rather help you learn how to ride that wave than hold you back. So, I'll show you some ways to use AI tools to accelerate rather than bypass your computational physics learning. I'll share the \"what to do\" details as we go. The explosive arrival and improvement of AI tools like ChatGPT over the past couple of years have caused quite a furor within universities. Is it cheating for students to consult an AI tool for help on an assignment, or an improvement in learning efficiency? Does it bypass learning, or does it develop new skills that will be critical in the near-future economy? Well, duh. All of the above, obviously. It depends very much on how the AI is used. In that way it's no different from consulting a classmate or other human for help: They could help you learn, or save you the trouble of learning. One big difference here is that unlike a human, an AI can't make the judgment call about whether what you're asking is ethical, or about the best way to support your learning. So, that's all on you. I'll say a bit more about specific do's and don'ts soon, when I show you some really cool ways to leverage AI. For now, here's the general rule: Ask an AI tool to answer general questions, suggest general approaches, explain specific functions or language features, give you an example of code that uses a particular function or language feature, identify a bug in your code that you can't find, or offer suggestions on a block of your code. Do not have an AI tool produce code to solve your specific course assignment problems, and do not present code written by an AI as part of your own. Here's one other requirement: Any time you use an AI to help you with an assignment, you must say how in your submission. You can do that by including some comment lines in your code, or including a note in a separate markdown/text file you add to the submission file, or whatever makes sense in the context. The most important reason for this is that I want to learn how y'all are using AI, so that I can get better at helping you learn to get better at using it! This is new terrain for all of us. When in doubt, let's talk it out. I haven't figured it all out either. \ud83d\ude35\u200d\ud83d\udcab Congratulations for making it all the way to the end! \ud83c\udfc6 As of the time I'm writing this, I am recovering from a serious health issue that may affect some of the details of my availability during the Spring 2025 semester in ways I don't yet know. I'll keep you posted. \u21a9","title":"Artificial Intelligence Policy"},{"location":"recipes/","text":"Computational Physics Recipes What is a computational physics \"recipe\"? One of the most difficult aspects of learning to code \u2014 for physics, or any other end \u2014 is staring at a blank code editor with only a general, high-level of what you want to accomplish, and no clear idea of what code to write to accomplish it. This is the \"blank page problem.\" Ever been there? Yeah, me too. If you've solved similar problems before, then you can probably start by recreating what you did and modifying it. But what if you haven't? If you can find an example of someone else's solution to a similar problem, you may be able to copy and modify it\u2026 Although depending on the complexity of the problem and the transparency or opaqueness of the example, understanding it well enough to know what to modify (and how), without breaking anything, may be be hair-pullingly infuriating. My solution to this is to offer you a cookbook of \"recipes\" \u2014 starting points that show you how to accomplish various common kinds of coding and computational physics tasks. They are meant to be clear, especially about which bits are essential and which are meant for you to fit to your specific needs. They also include examples, and sometimes variations upon the basic recipe for situations that are similar but differ in some important way. Some recipes are procedural, describing a sequence of steps for you to follow. Some are syntactic, showing specific python code to accomplish a task. Some are structural, recommending approaches to organizing code in pursuit of your goal. Often, recipes include key conceptual and/or informational knowledge about python, numerical methods, and the practice of computational physics. Understanding the ideas and knowing the facts is an essential part of using the recipes correctly, flexibly, and successfully. The recipes in this compendium are organized in the order of the course assignments that accompany them, grouped into \"units\" or \"chapters\" or whatever you want to call them: Recipes by PHY 351 course unit World A: Core Python I use the term core python to mean the standard parts of the python ecosystem: the base python language and the \"standard library\" of modules that is typically installed along with it. For purposes of this course I'm also including the tool stack we'll use to work with python: GitHub and git , JupyterLab and its pieces, and a little of the Unix command-line. World B: Numerical Methods 1 \u2014 Numerical Solving, Finding & Randomness Now that we've covered the essentials of python, let's take a break from \"learning to code\" in order to \"learn why to code\" \u2014 that is, how to use those skillz to do some physics-y stuff. World C: Scientific Python Here we introduce recipes focused on aspects of python central to numerically-intensive work. These include a deep understanding of how computers handle numbers, working with arrays and matrices of values, creating plots and other data visualizations, and reading to or writing from data files. Along the way, we'll introduce numpy and matplotlib , add-ons to the python language that support numerically-focused work. World D: Numerical Methods 2: Numerical Calculus Doing math involves more than solving algebraic equations! It often requires taking derivatives, integrating, and solving differential equations. Computers can do that too! The key involves forgetting most of what you learned in calculus courses, and going back to the initial definitions of \"derivative\" and \"integral\"\u2026 and then applying a whole lot of numerical cleverness. World E: Visual Python Yeah, \"solving\" a physics problem and getting a bunch of numbers out \u2013 or even a pretty plot \u2014 is nice, but there's no substitute for seeing the behavior of your modeled system evolve in realtime. VPython (\"visual python\") is an add-on toolkit for doing exactly that, and it makes constructing and animating 3D simulations embarrassingly easy.","title":"Intro to Recipes"},{"location":"recipes/#computational-physics-recipes","text":"","title":"Computational Physics Recipes"},{"location":"recipes/#what-is-a-computational-physics-recipe","text":"One of the most difficult aspects of learning to code \u2014 for physics, or any other end \u2014 is staring at a blank code editor with only a general, high-level of what you want to accomplish, and no clear idea of what code to write to accomplish it. This is the \"blank page problem.\" Ever been there? Yeah, me too. If you've solved similar problems before, then you can probably start by recreating what you did and modifying it. But what if you haven't? If you can find an example of someone else's solution to a similar problem, you may be able to copy and modify it\u2026 Although depending on the complexity of the problem and the transparency or opaqueness of the example, understanding it well enough to know what to modify (and how), without breaking anything, may be be hair-pullingly infuriating. My solution to this is to offer you a cookbook of \"recipes\" \u2014 starting points that show you how to accomplish various common kinds of coding and computational physics tasks. They are meant to be clear, especially about which bits are essential and which are meant for you to fit to your specific needs. They also include examples, and sometimes variations upon the basic recipe for situations that are similar but differ in some important way. Some recipes are procedural, describing a sequence of steps for you to follow. Some are syntactic, showing specific python code to accomplish a task. Some are structural, recommending approaches to organizing code in pursuit of your goal. Often, recipes include key conceptual and/or informational knowledge about python, numerical methods, and the practice of computational physics. Understanding the ideas and knowing the facts is an essential part of using the recipes correctly, flexibly, and successfully. The recipes in this compendium are organized in the order of the course assignments that accompany them, grouped into \"units\" or \"chapters\" or whatever you want to call them:","title":"What is a computational physics \"recipe\"?"},{"location":"recipes/#recipes-by-phy-351-course-unit","text":"World A: Core Python I use the term core python to mean the standard parts of the python ecosystem: the base python language and the \"standard library\" of modules that is typically installed along with it. For purposes of this course I'm also including the tool stack we'll use to work with python: GitHub and git , JupyterLab and its pieces, and a little of the Unix command-line. World B: Numerical Methods 1 \u2014 Numerical Solving, Finding & Randomness Now that we've covered the essentials of python, let's take a break from \"learning to code\" in order to \"learn why to code\" \u2014 that is, how to use those skillz to do some physics-y stuff. World C: Scientific Python Here we introduce recipes focused on aspects of python central to numerically-intensive work. These include a deep understanding of how computers handle numbers, working with arrays and matrices of values, creating plots and other data visualizations, and reading to or writing from data files. Along the way, we'll introduce numpy and matplotlib , add-ons to the python language that support numerically-focused work. World D: Numerical Methods 2: Numerical Calculus Doing math involves more than solving algebraic equations! It often requires taking derivatives, integrating, and solving differential equations. Computers can do that too! The key involves forgetting most of what you learned in calculus courses, and going back to the initial definitions of \"derivative\" and \"integral\"\u2026 and then applying a whole lot of numerical cleverness. World E: Visual Python Yeah, \"solving\" a physics problem and getting a bunch of numbers out \u2013 or even a pretty plot \u2014 is nice, but there's no substitute for seeing the behavior of your modeled system evolve in realtime. VPython (\"visual python\") is an add-on toolkit for doing exactly that, and it makes constructing and animating 3D simulations embarrassingly easy.","title":"Recipes by PHY 351 course unit"},{"location":"recipes/core/","text":"Core Python Recipes I use the term core python to mean the standard parts of the python ecosystem: the base python language and the \"standard library\" of modules that is typically installed along with it. For purposes of this course I'm also including the tool stack we'll use to work with python: GitHub and git , JupyterLab and its pieces, and a little of the Unix command-line. I've divided that up in to the following chunks: Workflow Recipes : Basic procedures for getting stuff done in this course (and hopefully beyond it). Calculation Recipes : Procedures, tools, and tricks to help you do numeric calculations such as you might encounter in physics homework from other courses (or, perhaps some day, in a physics-ish job). Function Recipes : Defining functions takes python from \"oversized calculator\" to \"full-fledged programming language.\" These recipes address various aspects of writing your own functions in the service of doing physics. Iteration Recipes : Humans hate doing the same thing over and over with only tiny variations. Computers excel at it. These recipes illustrate various ways of taking advantage of that. Collection Recipes : Recipes for using python's various collection types: tuples , lists , sets , and dictionaries (\"dicts\").","title":"Overview"},{"location":"recipes/core/#core-python-recipes","text":"I use the term core python to mean the standard parts of the python ecosystem: the base python language and the \"standard library\" of modules that is typically installed along with it. For purposes of this course I'm also including the tool stack we'll use to work with python: GitHub and git , JupyterLab and its pieces, and a little of the Unix command-line. I've divided that up in to the following chunks: Workflow Recipes : Basic procedures for getting stuff done in this course (and hopefully beyond it). Calculation Recipes : Procedures, tools, and tricks to help you do numeric calculations such as you might encounter in physics homework from other courses (or, perhaps some day, in a physics-ish job). Function Recipes : Defining functions takes python from \"oversized calculator\" to \"full-fledged programming language.\" These recipes address various aspects of writing your own functions in the service of doing physics. Iteration Recipes : Humans hate doing the same thing over and over with only tiny variations. Computers excel at it. These recipes illustrate various ways of taking advantage of that. Collection Recipes : Recipes for using python's various collection types: tuples , lists , sets , and dictionaries (\"dicts\").","title":"Core Python Recipes"},{"location":"recipes/core/calculation/","text":"Calculation Recipes Recipes for using python as a (powerful) calculator: Calculate Interactively : I want to do a physics calculation that would be easy to do incorrectly in a calculator, and/or I might need to repeat it with different givens. Use Python Functions : I want to use predefined mathematical (or other) functions, like sine or absolute-value, in my calculation. Use Complex Numbers : I want to do a calculation that involves complex numbers. Print Formatted Output : I want to control the output of my code so that I can include text, specify precision, and so on. Script a Calculation : I want to make a multi-step calculation easier to construct and debug, run multiple times, run again later, and/or have a permanent record of. Ask for User Input : I want to be able to run my script (or let someone else run it) with various given values, without having to edit the script each time.","title":"(Recipe List)"},{"location":"recipes/core/calculation/#calculation-recipes","text":"Recipes for using python as a (powerful) calculator: Calculate Interactively : I want to do a physics calculation that would be easy to do incorrectly in a calculator, and/or I might need to repeat it with different givens. Use Python Functions : I want to use predefined mathematical (or other) functions, like sine or absolute-value, in my calculation. Use Complex Numbers : I want to do a calculation that involves complex numbers. Print Formatted Output : I want to control the output of my code so that I can include text, specify precision, and so on. Script a Calculation : I want to make a multi-step calculation easier to construct and debug, run multiple times, run again later, and/or have a permanent record of. Ask for User Input : I want to be able to run my script (or let someone else run it) with various given values, without having to edit the script each time.","title":"Calculation Recipes"},{"location":"recipes/core/calculation/calc-interactively/","text":"Calculate Interactively Problem to Solve I want to do a physics calculation that would be easy to do incorrectly in a calculator, and/or I might need to repeat it with different givens. Recipe to Solve It This, too, is a \"procedural\" recipe. (I promise that actual code recipes are coming soon!) Let's assume that either you've solved the problem in question via paper-and-pencil, symbolically, and are now ready to plug in given constants, parameters, initial conditions, etc. to calculate one or more numerical results. Pro tip: Solve all but the most trivial physics problems symbolically , deriving a symbolic answer algebraically and simplifying as much as possible before inserting numerical values. If you're given numerical values and not variable names in the problem, define your own symbols! Even the local gravitational constant should be written as \\(g\\) instead of \\(9.81 \\, \\text{m/s}^2\\) or (gasp!) \\(9.8\\) until the very end. Overall, follow the Interactive Python recipe . This recipe provides advice on what to execute during the interactive IPython session. Define variables for the constants you'll need, such as g = 9.81 or c = 3.00e8 . Make sure your units are consistent! Putting everything into SI units (MKS) is often safest. Define variables for the other \"given values\" in the problem. Use legitimate python variable names that are as close as possible to the mathematical variable names you'd normally use: m1 for \\(m_1\\) , Vx0 for \\(V_{x}(t = 0)\\) , etc. Again, make sure units are consistent. If you're given something in units that need to be converted, it's often easiest to write the conversion calculation directly into the variable definition. For example, if a problem says the mass of body 1 is 34.5 grams, enter m1 = 34.5 / 1000 to get a numeric value in kilograms. Multiple related values can be defined on one line with the \"comma trick\": m1, m2 = 1.5, 4.0 or Vx0, Vy0, Vz0 = 25, 0, 0 . Construct arithmetic expressions with python's arithmetic operators to calculate intermediate or final values. Know and be careful of operator precedence , or you may get incorrect results. Import needed functions from libraries like math and complex as you discover that you need them. (We'll have more about this in the next recipe, use python functions .) Build up complicated expressions from simpler chunks , saving the values of the chunks in variables. Multiple simple expressions are way simpler to check and debug than one big, hairy one. Maximize readability of arithmetic expressions by including appropriate whitespace around operators and (with a few exceptions) avoiding parentheses that are not required by operator precedence. Execute bare expressions to display the final numerical values you seek. You can also do this for intermediate results, as a way of checking your work as you go. An Example Let's say you've got a typical conservation of angular momentum problem from PHY 291: A thin rod of length \\(L = 50\\text{ cm}\\) and mass \\(M = 600\\text{ g}\\) sits on a horizontal surface, anchored to the surface by a pivot through its center. A puck of mass \\(m = 200\\text{ g}\\) slides across the tabletop with speed \\(v_\\text{i} = 0.8\\text{ m/s}\\) strikes the rod at a distance \\(d = 20\\text{ cm}\\) from the pivot, perpendicular to the rod, and sticks to it. What is the rotational speed of the rod after the collision? Assume all forms of friction are negligible. Applying the principle of conservation of angular momentum and some algebraic manipulations, you derive the following expression for the rod's post-collision rotational speed: \\(\\omega = \\frac{m\\,d\\,v_\\text{i}}{m\\,d + I} = v_\\text{i}\\left(1 + \\frac{I}{m\\,d}\\right)^{-1}\\) where \\(I = \\tfrac{1}{12}\\,M\\,L^2\\) is the rotational inertia of the rod about its center. Now it's time to calculate the numerical value, which means it's time to reach for python. After firing up IPython , your interactive session might look something like the following. (IPython provides the bits that look like In [1]: ; you provide what follows those.) Defining constants and givens: In [1]: m, M = 0.200, 0.600 In [2]: L = 0.50 In [3]: d = 0.20 In [4]: v_i = 0.8 Calculate the rod's rotational inertia. (I could instead substitute the expression in for \\(I\\) in the formula for the angular speed, but the result would be complicated enough to raise the risk of a mistake in the corresponding python expression. So, I'm obeying the recipe's advice to \"Build up complicated expressions from simpler chunks\".) In [5]: I = M * L**2 / 12 Calculate the final rotational speed: In [6]: v_i / (1 + I / (m * d)) Out[6]: 0.6095238095238096 (It's up to you to know that based on the units of your variables, the answer is in radians per second.) Let's say that the problem included a part (b) that asks for the final rotational speed if the puck had instead hit and stuck to the very end of the rod. That's easy to calculate without very much repeated work. First, change the value of the relevant variable: In [7]: d = 0.25 Rather than retype the final formula, we can just press the keyboards up-arrow key three times to \"walk back\" through the session's command history, until the formula we want is displayed, and then press Enter to execute it again (with the current values of all variables): In [8]: v_i / (1 + I / (m * d)) Out[8]: 0.64 Out of curiosity, what was the numerical value of the rotational inertia? In [9]: I Out[9]: 0.012499999999999999 (Again, it's up to you to know that based on the units of your variables, the answer is in kilogram-meters-squared. And you should definitely report your answer as \\(0.0125\\text{ kg m}^2\\) , since those repeating-nines are certainly the result of machine round-off error, which we'll talk about in a later section of the course.) Okay, we're done. Most of the time you'd just quit it with exit , but let's illustrate how to save the session history in case you want to refer back to it later. (For example, if you submit your answer and the numerical value gets marked wrong, you might want to compare what you did to the solutions to figure out whether you mis-entered something.) In [10]: %save p291-hw07-p3 The following commands were written to file `p291-hw07-p3.py`: m, M = 0.200, 0.600 L = 0.50 d = 0.20 v_i = 0.8 I = M * L**2 / 12 v_i / (1 + I / (m * d)) d = 0.25 v_i / (1 + I / (m * d)) I In [11]: exit The lines of that output file could be copy-pasted into a new IPython session to recreate the calculations (possibly with some edits as you go, if you wish). Or, you could run the entire file as a python script .","title":"Calculate Interactively"},{"location":"recipes/core/calculation/calc-interactively/#calculate-interactively","text":"","title":"Calculate Interactively"},{"location":"recipes/core/calculation/calc-interactively/#problem-to-solve","text":"I want to do a physics calculation that would be easy to do incorrectly in a calculator, and/or I might need to repeat it with different givens.","title":"Problem to Solve"},{"location":"recipes/core/calculation/calc-interactively/#recipe-to-solve-it","text":"This, too, is a \"procedural\" recipe. (I promise that actual code recipes are coming soon!) Let's assume that either you've solved the problem in question via paper-and-pencil, symbolically, and are now ready to plug in given constants, parameters, initial conditions, etc. to calculate one or more numerical results. Pro tip: Solve all but the most trivial physics problems symbolically , deriving a symbolic answer algebraically and simplifying as much as possible before inserting numerical values. If you're given numerical values and not variable names in the problem, define your own symbols! Even the local gravitational constant should be written as \\(g\\) instead of \\(9.81 \\, \\text{m/s}^2\\) or (gasp!) \\(9.8\\) until the very end. Overall, follow the Interactive Python recipe . This recipe provides advice on what to execute during the interactive IPython session. Define variables for the constants you'll need, such as g = 9.81 or c = 3.00e8 . Make sure your units are consistent! Putting everything into SI units (MKS) is often safest. Define variables for the other \"given values\" in the problem. Use legitimate python variable names that are as close as possible to the mathematical variable names you'd normally use: m1 for \\(m_1\\) , Vx0 for \\(V_{x}(t = 0)\\) , etc. Again, make sure units are consistent. If you're given something in units that need to be converted, it's often easiest to write the conversion calculation directly into the variable definition. For example, if a problem says the mass of body 1 is 34.5 grams, enter m1 = 34.5 / 1000 to get a numeric value in kilograms. Multiple related values can be defined on one line with the \"comma trick\": m1, m2 = 1.5, 4.0 or Vx0, Vy0, Vz0 = 25, 0, 0 . Construct arithmetic expressions with python's arithmetic operators to calculate intermediate or final values. Know and be careful of operator precedence , or you may get incorrect results. Import needed functions from libraries like math and complex as you discover that you need them. (We'll have more about this in the next recipe, use python functions .) Build up complicated expressions from simpler chunks , saving the values of the chunks in variables. Multiple simple expressions are way simpler to check and debug than one big, hairy one. Maximize readability of arithmetic expressions by including appropriate whitespace around operators and (with a few exceptions) avoiding parentheses that are not required by operator precedence. Execute bare expressions to display the final numerical values you seek. You can also do this for intermediate results, as a way of checking your work as you go.","title":"Recipe to Solve It"},{"location":"recipes/core/calculation/calc-interactively/#an-example","text":"Let's say you've got a typical conservation of angular momentum problem from PHY 291: A thin rod of length \\(L = 50\\text{ cm}\\) and mass \\(M = 600\\text{ g}\\) sits on a horizontal surface, anchored to the surface by a pivot through its center. A puck of mass \\(m = 200\\text{ g}\\) slides across the tabletop with speed \\(v_\\text{i} = 0.8\\text{ m/s}\\) strikes the rod at a distance \\(d = 20\\text{ cm}\\) from the pivot, perpendicular to the rod, and sticks to it. What is the rotational speed of the rod after the collision? Assume all forms of friction are negligible. Applying the principle of conservation of angular momentum and some algebraic manipulations, you derive the following expression for the rod's post-collision rotational speed: \\(\\omega = \\frac{m\\,d\\,v_\\text{i}}{m\\,d + I} = v_\\text{i}\\left(1 + \\frac{I}{m\\,d}\\right)^{-1}\\) where \\(I = \\tfrac{1}{12}\\,M\\,L^2\\) is the rotational inertia of the rod about its center. Now it's time to calculate the numerical value, which means it's time to reach for python. After firing up IPython , your interactive session might look something like the following. (IPython provides the bits that look like In [1]: ; you provide what follows those.) Defining constants and givens: In [1]: m, M = 0.200, 0.600 In [2]: L = 0.50 In [3]: d = 0.20 In [4]: v_i = 0.8 Calculate the rod's rotational inertia. (I could instead substitute the expression in for \\(I\\) in the formula for the angular speed, but the result would be complicated enough to raise the risk of a mistake in the corresponding python expression. So, I'm obeying the recipe's advice to \"Build up complicated expressions from simpler chunks\".) In [5]: I = M * L**2 / 12 Calculate the final rotational speed: In [6]: v_i / (1 + I / (m * d)) Out[6]: 0.6095238095238096 (It's up to you to know that based on the units of your variables, the answer is in radians per second.) Let's say that the problem included a part (b) that asks for the final rotational speed if the puck had instead hit and stuck to the very end of the rod. That's easy to calculate without very much repeated work. First, change the value of the relevant variable: In [7]: d = 0.25 Rather than retype the final formula, we can just press the keyboards up-arrow key three times to \"walk back\" through the session's command history, until the formula we want is displayed, and then press Enter to execute it again (with the current values of all variables): In [8]: v_i / (1 + I / (m * d)) Out[8]: 0.64 Out of curiosity, what was the numerical value of the rotational inertia? In [9]: I Out[9]: 0.012499999999999999 (Again, it's up to you to know that based on the units of your variables, the answer is in kilogram-meters-squared. And you should definitely report your answer as \\(0.0125\\text{ kg m}^2\\) , since those repeating-nines are certainly the result of machine round-off error, which we'll talk about in a later section of the course.) Okay, we're done. Most of the time you'd just quit it with exit , but let's illustrate how to save the session history in case you want to refer back to it later. (For example, if you submit your answer and the numerical value gets marked wrong, you might want to compare what you did to the solutions to figure out whether you mis-entered something.) In [10]: %save p291-hw07-p3 The following commands were written to file `p291-hw07-p3.py`: m, M = 0.200, 0.600 L = 0.50 d = 0.20 v_i = 0.8 I = M * L**2 / 12 v_i / (1 + I / (m * d)) d = 0.25 v_i / (1 + I / (m * d)) I In [11]: exit The lines of that output file could be copy-pasted into a new IPython session to recreate the calculations (possibly with some edits as you go, if you wish). Or, you could run the entire file as a python script .","title":"An Example"},{"location":"recipes/core/calculation/complex-numbers/","text":"Use Complex Numbers Problem to Solve I want to do a calculation that involves complex numbers. Introduction Rejoice \u2014 python has built-in support for complex numbers, right alongside integers and real (floating-point) numbers! The only real catch is that the functions in the math module don't work with complex numbers. That's not an issue, since the cmath module has all the same functions, but written to handle both real and complex numbers equally well. Recipe A: Assembling and Disassembling Complex Numbers If you have actual numbers (not variables) for the real and imaginary parts, you can specify a complex number with what's called a literal : >>> c1 = 3 + 2j # positive real and imaginary parts >>> c2 = -3 - 2j # negative real and imaginary parts >>> c3 = 2j # imaginary part only, real part is zero >>> c4 = 3 + 0j # a complex number with zero imaginary part Note that a \"complex number with zero imaginary part\" is still recognized as a complex number by python, even though it's mathematically equivalent to a real number. Also note that you can get \\(\\sqrt{-1}\\) (which we commonly call \"i\" in physics) by using 1j . Python follows the engineering convention of using j to represent the imaginary unit, rather than the mathematician's i . This is because i is often used as a loop index in python code, and j is less likely to be confused with a variable name. If you have real and imaginary parts stored in separate variables, you can construct a complex number from them with the complex() constructor function . Let's assume that the variables a and b already hold numeric values from prior calculations. We can make them the parts of a complex number via: >>> c = complex(a, b) >>> c (3-4j) If you're doing a calculation and you need something like \\(i\\phi\\) where \\(\\phi\\) is a variable represented by phi in your code, you can put that into a python formula as either complex(0, phi) or 1j * phi . I personally prefer the latter, as it's closest to the original math notation. You can extract the real and imaginary part of a complex number thusly: >>> z = 3.5 - 4.2j >>> z.real 3.5 >>> z.imag -4.2 This works for complex expressions, not just variables: >>> (3.5 - 4.2j).real 3.5 >>> (z**2 - 2*z + 1).imag -21.0 It should be obvious to you that: >>> complex(z.real, z.imag) == z True Recipe B: Doing Math with Complex Numbers Python's standard arithmetic operators ( + , - , * , / , ** ) work properly with complex numbers. Nothing special is needed. (Note that the // and % operators for integer division and remainder don't, because those operations are not mathematically defined for complex numbers. Don't blame python.) Python's built-in numeric functions abs() , pow() , and sum() work properly with complex numbers. Others don't, because they're not mathematically well-defined. The functions in the math module do NOT work with complex numbers! However, if you simply use cmath instead of math , you'll get all the same functions, but written to handle both real and complex numbers equally well. Recipe C: Working with Complex Numbers in Polar Form In addition to the rectangular or Cartesian representation of a complex number \\(z = a + b\\,i\\) , in physics we often use the polar representation \\(z = r\\,e^{i\\theta}\\) , where \\(r\\) is called the magnitude of \\(z\\) and \\(\\theta\\) the phase . If we know \\(a\\) and \\(b\\) , we can calculate \\(r\\) and \\(\\theta\\) , or vice-versa. Of course, python can do that for us. In addition to complex-aware copies of the functions in the math module, cmath has a few special-purpose functions for working with complex numbers: abs(z) returns the magnitude \\(r\\) . (Yes, this is the usual built-in abs() function. It's smart enough to know that the \"absolute value\" of a complex number is its magnitude.) cmath.phase(z) returns the phase \\(\\theta\\) , in radians. cmath.polar(z) returns both the magnitude and phase as a two-element tuple (r, theta) . cmath.rect(r, theta) creates a complex number habving magnitude \\(r\\) and phase \\(\\theta\\) . So, if you want to know the imaginary part of a complex number that has magnitude 1 and phase \\(\\pi/4\\) , you can do this: >>> import cmath as cm >>> z = cm.rect(1, cm.pi/4) >>> z.imag Or, more compactly, just cmath.rect(1, cmath.pi/4).imag . (The cmath module defines the same constants as math , such as pi and e , so you don't have to import two different packages. They're still real numbers.) Recipe D: Complex Conjugation One additional operation you might need to do with a complex number (say, \\(z\\) ) is to take its complex conjugate (denoted \\(z^*\\) ). Mathematically, this is defined as flipping the sign ( \\(+ \\leftrightarrow -\\) ) of the imaginary part, or replacing \\(i\\) with \\(-i\\) in the polar form, (or in any form composed of real numbers and explicit \\(i\\) s). Here's a possible, but bad , way to do that in python: >>> z_star = complex(z.real, -z.imag) # Don't do this! Instead, use the conjugate() method that all complex number objects (variables or literals) have: >>> z_star = z.conjugate() That's cleaner and easier for a human to interpret. It's also less error-prone, and slightly faster. However, a warning: Let python do the work for you! You may be so used to doing complex arithmetic \"by hand\" that you try to do that in your code, too. For example, here are three different, mathematically equivalent ways to find the magnitude of a complex number z : >>> z_mag_1 = cm.sqrt(z.real**2 + z.imag**2) # Don't do this. >>> z_mag_2 = cm.sqrt(z.conjugate() * z) # Don't do this either. >>> z_mag_3 = abs(z) # Yes, do this! If you think of the core python abs() function as meaning \"give me the magnitude of this thing\", it becomes a natural extension of absolute value, and results in cleaner, less error-prone, and (slightly) faster code. An Example Let's say that we have a simple series circuit (one loop) with an AC voltage source, a resistor, an inductor, and a capacitor all in series, and we want to know the current flowing through the circuit as a function of time. In a course like PHY 412, you'd learn that it's trivial to analyze such a circuit using the method of complex impedances , and you could derive the following expression for the current in the circuit as a function of time: \\[ I(t) = \\text{Re}\\left(\\frac{V_0\\,e^{i\\omega t}}{R + i \\left( \\omega L - \\frac{1}{\\omega C} \\right)}\\,\\right) \\] where \\(\\text{Re}(\u2026)\\) means \"take the real part of\". For specific numerical values, let's say: The driving voltage is \\(V(t) = V_0\\ \\cos(\\omega t)\\) with \\(V_0 = 10\\text{ V}\\) and \\(f = 100\\text{ Hz}\\) (Remember that the angular frequency \\(\\omega = 2\\pi f\\) ). The resistance, inductance, and capacitance of the resistor, inductor, and capacitor are \\(R = 100\\ \\Omega\\) , \\(L = 200\\text{ mH}\\) , and \\(C = 10\\ \\mu\\text{F}\\) respectively. We want to know the current at times of \\(t = 0, 1, 2, 3, 4, 5, \\text{and } 10\\text{ ms}\\) . Calculating these is easy with python! In [1]: Vo, f = 10, 100 In [2]: R, L, C = 100, 100e-3, 10e-6 In [3]: from cmath import pi, exp In [4]: w = 2 * pi * f In [5]: Z = R + 1j * (w * L - 1 / (w * C)) In [6]: Z Out[6]: (100-96.32309002009944j) In [7]: t = 0 In [8]: (Vo * exp(1j * w * t) / Z).real Out[8]: 0.05187223045425429 In [9]: t = 1e-3 In [10]: (Vo * exp(1j * w * t) / Z).real Out[10]: 0.012596863910223792 In [11]: t = 2e-3 In [12]: (Vo * exp(1j * w * t) / Z).real Out[12]: -0.031490076495855286 In [13]: t = 3e-3 In [14]: (Vo * exp(1j * w * t) / Z).real Out[14]: -0.06354887798885185 In [15]: t = 4e-3 In [16]: (Vo * exp(1j * w * t) / Z).real Out[16]: -0.07133416803702705 In [17]: t = 5e-3 In [18]: (Vo * exp(1j * w * t) / Z).real Out[18]: -0.051872230454254306 In [19]: t = 10e-3 In [20]: (Vo * exp(1j * w * t) / Z).real Out[20]: 0.051872230454254306 A few comments: In entry 5, I'm calculating the denominator of the expression and stashing it in a temporary variable Z . This keeps the overall expression for the current from getting too ugly and error-prone. Since the denominator does not depend upon the time t , I don't have to recalculate it every time I change the value of t . Starting with entry 9, I'm just repeating a cycle of: up-arrowing twice to bring up the prior definition of t ; left-arrowing to put the cursor left of the = e , hitting delete, and typing the new time value; hitting Enter (or shift-Enter) to set the new time value; up-arrowing twice to bring up the prior expression for the current; and hitting Enter or (shift-Enter) to reevaluate it. This is a very efficient way to repeat a calculation for different values of some variable. (Yes, its even easier to use a loop, which we'll get to in an upcoming recipe. And this is a natural situation in which to define a custom function for the current, which we'll also get to soon enough.) Instead of Vo * exp(1j * w * t) it would have been entirely equivalent to use rect(Vo, w * t) after importing rect from cmath . That's probably simpler and easier to read, if you're fluent with the polar form of complex numbers.","title":"Use Complex Numbers"},{"location":"recipes/core/calculation/complex-numbers/#use-complex-numbers","text":"","title":"Use Complex Numbers"},{"location":"recipes/core/calculation/complex-numbers/#problem-to-solve","text":"I want to do a calculation that involves complex numbers.","title":"Problem to Solve"},{"location":"recipes/core/calculation/complex-numbers/#introduction","text":"Rejoice \u2014 python has built-in support for complex numbers, right alongside integers and real (floating-point) numbers! The only real catch is that the functions in the math module don't work with complex numbers. That's not an issue, since the cmath module has all the same functions, but written to handle both real and complex numbers equally well.","title":"Introduction"},{"location":"recipes/core/calculation/complex-numbers/#recipe-a-assembling-and-disassembling-complex-numbers","text":"If you have actual numbers (not variables) for the real and imaginary parts, you can specify a complex number with what's called a literal : >>> c1 = 3 + 2j # positive real and imaginary parts >>> c2 = -3 - 2j # negative real and imaginary parts >>> c3 = 2j # imaginary part only, real part is zero >>> c4 = 3 + 0j # a complex number with zero imaginary part Note that a \"complex number with zero imaginary part\" is still recognized as a complex number by python, even though it's mathematically equivalent to a real number. Also note that you can get \\(\\sqrt{-1}\\) (which we commonly call \"i\" in physics) by using 1j . Python follows the engineering convention of using j to represent the imaginary unit, rather than the mathematician's i . This is because i is often used as a loop index in python code, and j is less likely to be confused with a variable name. If you have real and imaginary parts stored in separate variables, you can construct a complex number from them with the complex() constructor function . Let's assume that the variables a and b already hold numeric values from prior calculations. We can make them the parts of a complex number via: >>> c = complex(a, b) >>> c (3-4j) If you're doing a calculation and you need something like \\(i\\phi\\) where \\(\\phi\\) is a variable represented by phi in your code, you can put that into a python formula as either complex(0, phi) or 1j * phi . I personally prefer the latter, as it's closest to the original math notation. You can extract the real and imaginary part of a complex number thusly: >>> z = 3.5 - 4.2j >>> z.real 3.5 >>> z.imag -4.2 This works for complex expressions, not just variables: >>> (3.5 - 4.2j).real 3.5 >>> (z**2 - 2*z + 1).imag -21.0 It should be obvious to you that: >>> complex(z.real, z.imag) == z True","title":"Recipe A: Assembling and Disassembling Complex Numbers"},{"location":"recipes/core/calculation/complex-numbers/#recipe-b-doing-math-with-complex-numbers","text":"Python's standard arithmetic operators ( + , - , * , / , ** ) work properly with complex numbers. Nothing special is needed. (Note that the // and % operators for integer division and remainder don't, because those operations are not mathematically defined for complex numbers. Don't blame python.) Python's built-in numeric functions abs() , pow() , and sum() work properly with complex numbers. Others don't, because they're not mathematically well-defined. The functions in the math module do NOT work with complex numbers! However, if you simply use cmath instead of math , you'll get all the same functions, but written to handle both real and complex numbers equally well.","title":"Recipe B: Doing Math with Complex Numbers"},{"location":"recipes/core/calculation/complex-numbers/#recipe-c-working-with-complex-numbers-in-polar-form","text":"In addition to the rectangular or Cartesian representation of a complex number \\(z = a + b\\,i\\) , in physics we often use the polar representation \\(z = r\\,e^{i\\theta}\\) , where \\(r\\) is called the magnitude of \\(z\\) and \\(\\theta\\) the phase . If we know \\(a\\) and \\(b\\) , we can calculate \\(r\\) and \\(\\theta\\) , or vice-versa. Of course, python can do that for us. In addition to complex-aware copies of the functions in the math module, cmath has a few special-purpose functions for working with complex numbers: abs(z) returns the magnitude \\(r\\) . (Yes, this is the usual built-in abs() function. It's smart enough to know that the \"absolute value\" of a complex number is its magnitude.) cmath.phase(z) returns the phase \\(\\theta\\) , in radians. cmath.polar(z) returns both the magnitude and phase as a two-element tuple (r, theta) . cmath.rect(r, theta) creates a complex number habving magnitude \\(r\\) and phase \\(\\theta\\) . So, if you want to know the imaginary part of a complex number that has magnitude 1 and phase \\(\\pi/4\\) , you can do this: >>> import cmath as cm >>> z = cm.rect(1, cm.pi/4) >>> z.imag Or, more compactly, just cmath.rect(1, cmath.pi/4).imag . (The cmath module defines the same constants as math , such as pi and e , so you don't have to import two different packages. They're still real numbers.)","title":"Recipe C: Working with Complex Numbers in Polar Form"},{"location":"recipes/core/calculation/complex-numbers/#recipe-d-complex-conjugation","text":"One additional operation you might need to do with a complex number (say, \\(z\\) ) is to take its complex conjugate (denoted \\(z^*\\) ). Mathematically, this is defined as flipping the sign ( \\(+ \\leftrightarrow -\\) ) of the imaginary part, or replacing \\(i\\) with \\(-i\\) in the polar form, (or in any form composed of real numbers and explicit \\(i\\) s). Here's a possible, but bad , way to do that in python: >>> z_star = complex(z.real, -z.imag) # Don't do this! Instead, use the conjugate() method that all complex number objects (variables or literals) have: >>> z_star = z.conjugate() That's cleaner and easier for a human to interpret. It's also less error-prone, and slightly faster. However, a warning: Let python do the work for you! You may be so used to doing complex arithmetic \"by hand\" that you try to do that in your code, too. For example, here are three different, mathematically equivalent ways to find the magnitude of a complex number z : >>> z_mag_1 = cm.sqrt(z.real**2 + z.imag**2) # Don't do this. >>> z_mag_2 = cm.sqrt(z.conjugate() * z) # Don't do this either. >>> z_mag_3 = abs(z) # Yes, do this! If you think of the core python abs() function as meaning \"give me the magnitude of this thing\", it becomes a natural extension of absolute value, and results in cleaner, less error-prone, and (slightly) faster code.","title":"Recipe D: Complex Conjugation"},{"location":"recipes/core/calculation/complex-numbers/#an-example","text":"Let's say that we have a simple series circuit (one loop) with an AC voltage source, a resistor, an inductor, and a capacitor all in series, and we want to know the current flowing through the circuit as a function of time. In a course like PHY 412, you'd learn that it's trivial to analyze such a circuit using the method of complex impedances , and you could derive the following expression for the current in the circuit as a function of time: \\[ I(t) = \\text{Re}\\left(\\frac{V_0\\,e^{i\\omega t}}{R + i \\left( \\omega L - \\frac{1}{\\omega C} \\right)}\\,\\right) \\] where \\(\\text{Re}(\u2026)\\) means \"take the real part of\". For specific numerical values, let's say: The driving voltage is \\(V(t) = V_0\\ \\cos(\\omega t)\\) with \\(V_0 = 10\\text{ V}\\) and \\(f = 100\\text{ Hz}\\) (Remember that the angular frequency \\(\\omega = 2\\pi f\\) ). The resistance, inductance, and capacitance of the resistor, inductor, and capacitor are \\(R = 100\\ \\Omega\\) , \\(L = 200\\text{ mH}\\) , and \\(C = 10\\ \\mu\\text{F}\\) respectively. We want to know the current at times of \\(t = 0, 1, 2, 3, 4, 5, \\text{and } 10\\text{ ms}\\) . Calculating these is easy with python! In [1]: Vo, f = 10, 100 In [2]: R, L, C = 100, 100e-3, 10e-6 In [3]: from cmath import pi, exp In [4]: w = 2 * pi * f In [5]: Z = R + 1j * (w * L - 1 / (w * C)) In [6]: Z Out[6]: (100-96.32309002009944j) In [7]: t = 0 In [8]: (Vo * exp(1j * w * t) / Z).real Out[8]: 0.05187223045425429 In [9]: t = 1e-3 In [10]: (Vo * exp(1j * w * t) / Z).real Out[10]: 0.012596863910223792 In [11]: t = 2e-3 In [12]: (Vo * exp(1j * w * t) / Z).real Out[12]: -0.031490076495855286 In [13]: t = 3e-3 In [14]: (Vo * exp(1j * w * t) / Z).real Out[14]: -0.06354887798885185 In [15]: t = 4e-3 In [16]: (Vo * exp(1j * w * t) / Z).real Out[16]: -0.07133416803702705 In [17]: t = 5e-3 In [18]: (Vo * exp(1j * w * t) / Z).real Out[18]: -0.051872230454254306 In [19]: t = 10e-3 In [20]: (Vo * exp(1j * w * t) / Z).real Out[20]: 0.051872230454254306 A few comments: In entry 5, I'm calculating the denominator of the expression and stashing it in a temporary variable Z . This keeps the overall expression for the current from getting too ugly and error-prone. Since the denominator does not depend upon the time t , I don't have to recalculate it every time I change the value of t . Starting with entry 9, I'm just repeating a cycle of: up-arrowing twice to bring up the prior definition of t ; left-arrowing to put the cursor left of the = e , hitting delete, and typing the new time value; hitting Enter (or shift-Enter) to set the new time value; up-arrowing twice to bring up the prior expression for the current; and hitting Enter or (shift-Enter) to reevaluate it. This is a very efficient way to repeat a calculation for different values of some variable. (Yes, its even easier to use a loop, which we'll get to in an upcoming recipe. And this is a natural situation in which to define a custom function for the current, which we'll also get to soon enough.) Instead of Vo * exp(1j * w * t) it would have been entirely equivalent to use rect(Vo, w * t) after importing rect from cmath . That's probably simpler and easier to read, if you're fluent with the polar form of complex numbers.","title":"An Example"},{"location":"recipes/core/calculation/print/","text":"Print Formatted Output Problem to Solve I want to control the output of my code so that I can include text, specify precision, and so on. Introduction A bare python expression produces a result when evaluated. That result is of some particular type: an integer, a floating-point or complex number, a text string, or perhaps something else. The IPython console or other interactive python session will display that result according to some default rule it has for that type. The result will probably provide sufficient information, but may be ugly or otherwise not quite as human-friendly as you'd like. (This is especially important when writing scripts , which we'll get to in the next recipe, Write a Calculation Script .) To control the details of python code output, use the built-in print() function. Using it can be drop-dead simple, or mysteriously arcane and complex, depending on what your goals are. We'll build the complexity up gradually in this recipe. A bit of terminology and conceptual background\u2026 Statements are chunks of python code that make changes to the python environment when they are executed, like importing a module or functions from it, or defining a variable and setting its value. Programmers call these \"side effects\". You can think of them as imperative sentences: \"Do this.\" Statements generally stand alone on a line (or a multi-line block), and don't \"return\" a value. Expressions are chunks of python code that are evaluated and converted into some kind of value or object when they are executed. They don't do anything other than produce this value. Often, they are part of a statement, such as the right-hand side of x = 5.0 * sin(radians(15)) . Expressions can be made up of other expressions: 15 is an expression, as are radians(15) and sin(radians(15)) . In IPython, when a \"bare expression\" \u2014 a line of python code that is an expression and not a statement \u2014 is sent to the python interpreter, the interpreter returns its value, and IPython displays that value as an \"output\" line. When working in IPython, the difference between values displayed as the result of expression evaluation and values displayed by print() is easy to overlook. The difference is important, however, and will be much more obvious when we move beyond IPython and start writing script files. For now, the key fact to stick into your memory is that print(...) is a statement that returns no result, but has the \"side effect\" of displaying text to the user. An expression simply returns a value, which might get used as part of a larger expression or statement, might be displayed to the user, or might be totally ignored depending on the context. One benefit of using print() statements to see your calculation results is that you get a whole lot of control over how values are displayed. You can embed numbers in text, control decimal digits or significant figures, force or prevent the use of scientific notation, control widths, etc. Recipe A: Just Print one Value If all you want to do is get a value to display, and you're fine with python's default choices, just pass it to print() as an argument: from math import sin theta = 0.01 sin_theta = sin(theta) print(sin_theta) produces 0.009999833334166664 Recipe B: Print Multiple Values If you pass multiple comma-separated arguments to print() , it will print them all, separated by spaces. (Note that any python expression can be an argument to print() , not just a variable name.) print(theta, sin_theta, theta - sin_theta) produces 0.01 0.009999833334166664 1.6666583333574403e-07 (Note how python automatically switches to scientific notation when the number is very small.) You can change the separation character from a space to something else (say, a comma) by specifying the sep keyword argument: print(theta, sin_theta, theta - sin_theta, sep=', ') produces 0.01, 0.009999833334166664, 1.6666583333574403e-07 You can even squish the values together with no separation at all by specifying an empty string as the separator: print(\"Twelve\", 12.0, 12, sep='') produces Twelve12.012 (This use case makes no sense, but situations do arise where it's helpful.) Recipe C: Inserting Values Into Text Python has a special kind of string called an \"f-string\" (for \"formatted string\") that allows you to insert values into specific locations in a string. To use this, prepend a f before the opening quote, and put curly braces {\u2026} around the value(s) to be inserted: print(f\"Theta is {theta}, its sine is {sin_theta}, and their difference is {theta - sin_theta}.\") produces Theta is 0.01, its sine is 0.009999833334166664, and their difference is 1.6666583333574403e-07. Recipe D: Controlling Number Format Look at that last output line. Notice that python displayed the first two numbers in traditional decimal notation, but chose to display the third number in scientific notation. By default, it displays very large and very small floating-point numbers in scientific notation, and uses decimal notation in between. You can force python to use a particular format by including a format specifier like this: print(f\"Theta is {theta:e}, its sine is {sin_theta:e}, and their difference is {theta - sin_theta:f}.\") This produces Theta is 1.000000e-02, its sine is 9.999833e-03, and their difference is 0.000000. If you include :f (for \"floating-point\") inside the curly-braces and after the variable or expression, python will display the number in decimal notation regardless of its size. If you include :e (for \"exponential\") instead, python will display the number in scientific notation. ( e means \"exponential\".) Or, if you use :g (for \"general\"), python will choose between the two formats based on the number's size. Although :g is very similar to using no specifier at all, the results can be slightly different: diff = theta - sin_theta print(f\"The difference can be shown as {diff}, {diff:f}, {diff:e},or {diff:g}.\") produces The difference can be shown as 1.6666583333574403e-07, 0.000000, 1.666658e-07,or 1.66666e-07. Examine carefully, especially the number of digits shownf Recipe E: Controlling Precision Format specifiers also let you control the number of digits displayed in the number. When using the f or e specifiers, you can specify the number of digits past the decimal point to show. (With the f specifier, the number of digits before the decimal point is whatever it is. With the e specifier, the exponent is chosen so that there's always one digit before the decimal point.) When using g , on the other hand, you can specify the number of significant figures (not decimal digits) to show for whichever format python chooses (floating-point or exponential). Warning : the way that python counts significant figures for floating-point numbers is not always the way physicists count them, so beware! (I've) x = 0.123456789 y = x * 1e-6 z = 0.01 print(f\"x is {x:.4f}, {x:.4e}, and {x:.4g}.\") print(f\"y is {y:.4f}, {y:.4e}, and {y:.4g}.\") print(f\"z is {z:.4f}, {z:.4e}, and {z:.4g}.\") # See what `.4g` does here! produces x is 0.1235, 1.2346e-01, and 0.1235. y is 0.0000, 1.2346e-07, and 1.235e-07. z is 0.0100, 1.0000e-02, and 0.01. Recipe F: Controlling Precision Programmatically This is a cute trick that you probably won't need often, but when you do, is super-handy to know: You can use a variable to specify the number of digits displayed by the f , e , and g formats. Just wrap the variable in its own set of curly braces {...} , inside the normal curly-braces around the value to be displayed. some_value, sigfigs = 22.0 / 7.15e5, 3 print(f\"The value obtained is {some_value:.{sigfigs}g}.\") produces The value obtained is 3.08e-05. Recipe G: Percentages A common way to display numbers between 0 and 1, when they represent the relative amount of something, is as a percentage. If you were doing this by hand, you'd multiply the number by 100 and then stick a \"%\" sign at the end. Python can do that for you! All you have to do is to use % as the format specifier instead of f . A number before the % indicates how many decimal digits to display, just as with f . For example: print(f\"One-sixth is about {1/6:.3%}.\") will produce One-sixth is about 16.667%. Recipe H: Commas for Big Numbers For human readability, grouping the digits of big numbers with commas is common. Here's how to make python do this: big_number = 1234567.89 print(f\"A big number: {big_number:,}!\") produces A big number: 1,234,567.89! (By the way, you can separate long numeric literals in python code for readability too, but you have to use underscores instead of commas. The numbers 1234567 and 1_234_567 mean exactly the same thing, but it's easier to see from the second thats the value is a bit over one million.) Recipe I: Other Formatting Capabilities f-strings have WAY more functionality available, including things like left-padding the output with spaces to fill up a particular total width (in characters), which can be useful for making vertical columns of values line up. For a deeper dive, see: For a wordy introduction, the Real Python tutorial How to Format Floats Within F-Strings in Python . For a \"cheat sheet\" summary of how to do different things, Python Morsels' Python f-string tips & cheat sheets . Here's a neat little trick I personally use a lot when debugging more complicated code: Self-documenting expressions . (This recipe has no \"An Example\" section because the recipe bits are basically all examples.)","title":"Print Formatted Output"},{"location":"recipes/core/calculation/print/#print-formatted-output","text":"","title":"Print Formatted Output"},{"location":"recipes/core/calculation/print/#problem-to-solve","text":"I want to control the output of my code so that I can include text, specify precision, and so on.","title":"Problem to Solve"},{"location":"recipes/core/calculation/print/#introduction","text":"A bare python expression produces a result when evaluated. That result is of some particular type: an integer, a floating-point or complex number, a text string, or perhaps something else. The IPython console or other interactive python session will display that result according to some default rule it has for that type. The result will probably provide sufficient information, but may be ugly or otherwise not quite as human-friendly as you'd like. (This is especially important when writing scripts , which we'll get to in the next recipe, Write a Calculation Script .) To control the details of python code output, use the built-in print() function. Using it can be drop-dead simple, or mysteriously arcane and complex, depending on what your goals are. We'll build the complexity up gradually in this recipe.","title":"Introduction"},{"location":"recipes/core/calculation/print/#a-bit-of-terminology-and-conceptual-background","text":"Statements are chunks of python code that make changes to the python environment when they are executed, like importing a module or functions from it, or defining a variable and setting its value. Programmers call these \"side effects\". You can think of them as imperative sentences: \"Do this.\" Statements generally stand alone on a line (or a multi-line block), and don't \"return\" a value. Expressions are chunks of python code that are evaluated and converted into some kind of value or object when they are executed. They don't do anything other than produce this value. Often, they are part of a statement, such as the right-hand side of x = 5.0 * sin(radians(15)) . Expressions can be made up of other expressions: 15 is an expression, as are radians(15) and sin(radians(15)) . In IPython, when a \"bare expression\" \u2014 a line of python code that is an expression and not a statement \u2014 is sent to the python interpreter, the interpreter returns its value, and IPython displays that value as an \"output\" line. When working in IPython, the difference between values displayed as the result of expression evaluation and values displayed by print() is easy to overlook. The difference is important, however, and will be much more obvious when we move beyond IPython and start writing script files. For now, the key fact to stick into your memory is that print(...) is a statement that returns no result, but has the \"side effect\" of displaying text to the user. An expression simply returns a value, which might get used as part of a larger expression or statement, might be displayed to the user, or might be totally ignored depending on the context. One benefit of using print() statements to see your calculation results is that you get a whole lot of control over how values are displayed. You can embed numbers in text, control decimal digits or significant figures, force or prevent the use of scientific notation, control widths, etc.","title":"A bit of terminology and conceptual background\u2026"},{"location":"recipes/core/calculation/print/#recipe-a-just-print-one-value","text":"If all you want to do is get a value to display, and you're fine with python's default choices, just pass it to print() as an argument: from math import sin theta = 0.01 sin_theta = sin(theta) print(sin_theta) produces 0.009999833334166664","title":"Recipe A: Just Print one Value"},{"location":"recipes/core/calculation/print/#recipe-b-print-multiple-values","text":"If you pass multiple comma-separated arguments to print() , it will print them all, separated by spaces. (Note that any python expression can be an argument to print() , not just a variable name.) print(theta, sin_theta, theta - sin_theta) produces 0.01 0.009999833334166664 1.6666583333574403e-07 (Note how python automatically switches to scientific notation when the number is very small.) You can change the separation character from a space to something else (say, a comma) by specifying the sep keyword argument: print(theta, sin_theta, theta - sin_theta, sep=', ') produces 0.01, 0.009999833334166664, 1.6666583333574403e-07 You can even squish the values together with no separation at all by specifying an empty string as the separator: print(\"Twelve\", 12.0, 12, sep='') produces Twelve12.012 (This use case makes no sense, but situations do arise where it's helpful.)","title":"Recipe B: Print Multiple Values"},{"location":"recipes/core/calculation/print/#recipe-c-inserting-values-into-text","text":"Python has a special kind of string called an \"f-string\" (for \"formatted string\") that allows you to insert values into specific locations in a string. To use this, prepend a f before the opening quote, and put curly braces {\u2026} around the value(s) to be inserted: print(f\"Theta is {theta}, its sine is {sin_theta}, and their difference is {theta - sin_theta}.\") produces Theta is 0.01, its sine is 0.009999833334166664, and their difference is 1.6666583333574403e-07.","title":"Recipe C: Inserting Values Into Text"},{"location":"recipes/core/calculation/print/#recipe-d-controlling-number-format","text":"Look at that last output line. Notice that python displayed the first two numbers in traditional decimal notation, but chose to display the third number in scientific notation. By default, it displays very large and very small floating-point numbers in scientific notation, and uses decimal notation in between. You can force python to use a particular format by including a format specifier like this: print(f\"Theta is {theta:e}, its sine is {sin_theta:e}, and their difference is {theta - sin_theta:f}.\") This produces Theta is 1.000000e-02, its sine is 9.999833e-03, and their difference is 0.000000. If you include :f (for \"floating-point\") inside the curly-braces and after the variable or expression, python will display the number in decimal notation regardless of its size. If you include :e (for \"exponential\") instead, python will display the number in scientific notation. ( e means \"exponential\".) Or, if you use :g (for \"general\"), python will choose between the two formats based on the number's size. Although :g is very similar to using no specifier at all, the results can be slightly different: diff = theta - sin_theta print(f\"The difference can be shown as {diff}, {diff:f}, {diff:e},or {diff:g}.\") produces The difference can be shown as 1.6666583333574403e-07, 0.000000, 1.666658e-07,or 1.66666e-07. Examine carefully, especially the number of digits shownf","title":"Recipe D: Controlling Number Format"},{"location":"recipes/core/calculation/print/#recipe-e-controlling-precision","text":"Format specifiers also let you control the number of digits displayed in the number. When using the f or e specifiers, you can specify the number of digits past the decimal point to show. (With the f specifier, the number of digits before the decimal point is whatever it is. With the e specifier, the exponent is chosen so that there's always one digit before the decimal point.) When using g , on the other hand, you can specify the number of significant figures (not decimal digits) to show for whichever format python chooses (floating-point or exponential). Warning : the way that python counts significant figures for floating-point numbers is not always the way physicists count them, so beware! (I've) x = 0.123456789 y = x * 1e-6 z = 0.01 print(f\"x is {x:.4f}, {x:.4e}, and {x:.4g}.\") print(f\"y is {y:.4f}, {y:.4e}, and {y:.4g}.\") print(f\"z is {z:.4f}, {z:.4e}, and {z:.4g}.\") # See what `.4g` does here! produces x is 0.1235, 1.2346e-01, and 0.1235. y is 0.0000, 1.2346e-07, and 1.235e-07. z is 0.0100, 1.0000e-02, and 0.01.","title":"Recipe E: Controlling Precision"},{"location":"recipes/core/calculation/print/#recipe-f-controlling-precision-programmatically","text":"This is a cute trick that you probably won't need often, but when you do, is super-handy to know: You can use a variable to specify the number of digits displayed by the f , e , and g formats. Just wrap the variable in its own set of curly braces {...} , inside the normal curly-braces around the value to be displayed. some_value, sigfigs = 22.0 / 7.15e5, 3 print(f\"The value obtained is {some_value:.{sigfigs}g}.\") produces The value obtained is 3.08e-05.","title":"Recipe F: Controlling Precision Programmatically"},{"location":"recipes/core/calculation/print/#recipe-g-percentages","text":"A common way to display numbers between 0 and 1, when they represent the relative amount of something, is as a percentage. If you were doing this by hand, you'd multiply the number by 100 and then stick a \"%\" sign at the end. Python can do that for you! All you have to do is to use % as the format specifier instead of f . A number before the % indicates how many decimal digits to display, just as with f . For example: print(f\"One-sixth is about {1/6:.3%}.\") will produce One-sixth is about 16.667%.","title":"Recipe G: Percentages"},{"location":"recipes/core/calculation/print/#recipe-h-commas-for-big-numbers","text":"For human readability, grouping the digits of big numbers with commas is common. Here's how to make python do this: big_number = 1234567.89 print(f\"A big number: {big_number:,}!\") produces A big number: 1,234,567.89! (By the way, you can separate long numeric literals in python code for readability too, but you have to use underscores instead of commas. The numbers 1234567 and 1_234_567 mean exactly the same thing, but it's easier to see from the second thats the value is a bit over one million.)","title":"Recipe H: Commas for Big Numbers"},{"location":"recipes/core/calculation/print/#recipe-i-other-formatting-capabilities","text":"f-strings have WAY more functionality available, including things like left-padding the output with spaces to fill up a particular total width (in characters), which can be useful for making vertical columns of values line up. For a deeper dive, see: For a wordy introduction, the Real Python tutorial How to Format Floats Within F-Strings in Python . For a \"cheat sheet\" summary of how to do different things, Python Morsels' Python f-string tips & cheat sheets . Here's a neat little trick I personally use a lot when debugging more complicated code: Self-documenting expressions . (This recipe has no \"An Example\" section because the recipe bits are basically all examples.)","title":"Recipe I: Other Formatting Capabilities"},{"location":"recipes/core/calculation/scripts/","text":"Script a Calculation Problem to Solve I want to make a multi-step calculation easier to construct and debug, run multiple times, run again later, and/or have a permanent record of. Up until now, we've been using the IPython console as a kind of scientific calculator on steroids. This makes sense for quick one-off calculations. However, it has two major drawbacks: Repeating the same calculation with different given values is tedious and error-prone, and Constructing more complicated, multi-step calculations is awkward and error-prone, especially when repeated trying-fixing-trying again or debugging cycles are required. The solution: Write your lines of python code in a script file , using a text editor of some kind. Then, send the whole file to the python interpreter (from IPython or a terminal console) to execute. The interpreter will still work through your code one line at a time, just as if you'd entered them into an IPython session console. The biggest difference is that you won't see the results of bare python expressions. If you want your script to give you some results, you'll need to use the print() statement. Recipe, Part 1: Create the Script File Python scripts are just sequences of python commands, saved in a file with a .py extension. You can write and edit them in any text editor, but it's easiest to work in one that's meant for coding and provides useful functionality like auto-indentation and syntax coding. JupyterLab is a great choice for this. In JupyterLab , open the left-side File Browser (if not already open). In the File Browser, navigate to the folder where you want to save your script file. You can create folders and subfolders for this, if you wish, using the new-folder button at the top of the File Browser. If the Launcher is not open, open it by clicking the + button at the top of the File Browser or in the tab bar above the main panel. In the Launcher, click the \"Python File\" button down in the \"Other\" section. The Launcher should be replaced by a blank window with a tab that says \"untitled.py\". You can immediately give the file a more sensible name by saving it (cmd/ctrl-S or \"Save Python File\" from the JupyterLab File menu) and specifying a name. Give it a meaningful name, but don't use spaces or special characters other than the underscore, and make sure to keep the .py ending. You should see it show up in the File Browser. It's a good habit to immediately put a comment line (or several) at the top of the file, briefly stating what the script's purpose is. That could be as simple as something like # Calculations for PHY 325 HW 3 Problem 2 . In python code, any line beginning with a # (possibly preceded by empty space) is considered a \"comment\" for humans only, and is ignored by the python interpreter. You now have a python script! Admittedly, it doesn't do anything yet, so\u2026 Recipe, Part 2: Write the Script The short version: Just write python code in the file, as you would type it into an interactive python/ipython session. When you run the script, the lines in the file will be sent to the python interpreter one at a time, in the order they appear. If the very last non-empty line is an expression that would return a result (rather than, say, a variable assignment), that result will be shown as the \"result\" of the script. The longer version, showing good script organization habits: Begin the script with an informative comment , as described above. Think about explaining \"WTH is this script for?\" to anyone (including far-future you) that might look at it, as well as any assumptions that might not be obvious from the code. And, if this might be shared or distributed, include your name and a date and such. Next, import any needed modules , or functions from modules. Putting all the import statements at the top makes it easy for someone to see what your code's \"dependencies\" are. As you start writing bigger, more sophisticated programs with nonstandard third-party modules, this becomes increasingly important. Define variables for any physical or other \"standard\" constants , like the local or universal gravitational constants, the speed of light, etc. End the line with a comment that includes the units, like these: G = 6.67430e-11 # m**3 / (kg s**2) c = 2.99792458e8 # m/s Define variables for any situation-specific given values , also with explicit units in a comment. If the physical meaning of the variable is not obvious from its name, say what it is in the comment. m1 = 2.5 # kg, mass of upper block m2 = 2.5 # kg, mass of lower block mu_k = 0.3 # coefficient of kinetic friction between lower block and tabletop Note that you can use some extra space characters to make the comments align nicely. Calculate intermediate values and chunks of complicated expressions , storing them in variables and building up the calculation step by step. Again, include comments for anything not self-explanatory. I = (2/5) * M * R**2 # kg m**2, moment of inertia of the sphere A = 1 / r1 + 1 / r2 # denominator of net potential expression Use print() to display result(s) , using f-string format codes as you see fit. See the recipe Print Formatted Output for details. x_f, v_f, m.degrees(angle_f) (assuming your script already assigned values to the variables x_f , v_f , and angle_f ) Save your edits. It's probably wise to do this every so often as you work, just in case. Recipe, Part 3: Run the Script You can run the script directly from within an active IPython session, or from the system command line in a terminal. Method A: From IPython If you're in JupyterLab , you can easily open an IPython session with the correct working directory by right-clicking (or double-tapping or whatever) on the script file's title tab at the top of the editor, and selecting \"Create Console for Editor\". You should get a \"Select Kernel\" dialog. Choose \"Python 3 (ipykernel)\". Click \"Select\". A new pane should pop open, probably in the bottom half of the window. If you wish, you can grab the console by its tab and drag it to the right of the screen (to split vertically instead of horizontally), or right next to the script file's tab (to let you switch back and forth between the tabs, giving each a full window of space). This is a normal ipython session, so you can do the usual interactive python things there. And, you can run your python script (or any python script, really) by entering the magic command %run your_filename.py , replacing the your_filename bit with whatever you named your file. You should see the result of your script appear in the IPython console, exactly as if you'd typed the lines in, one at a time. (Except that you won't see the results of any expressions except the last in the script.) Any variables you've defined in the script are now defined in the IPython session, with whatever values the script assigned to them, so you can continue the calculation, or explore their values, or whatever you might want to do with them. Recipe, Part 4: Modify the Script If you discover an error, or you want to run it with different givens, or you're dissatisfied with what the script outputs, or you want to extend it \u2014 immediately, or days or months later \u2014 doing that is far easier than if you'd been working interactively in the console. Edit the script in the editor window in whatever way you wish. Save changes via the usual method (cmd/ctrl-S or \"Save Python File\" from the JupyterLab File menu). Run the script as in Recipe Part 3. Recipe, Part 5: Quitting When you're done (at least for a while): Close the IPython console by clicking the x in the tab. The pane should disappear. Open the \"Running Terminals and Kernels\" panel (in place of the File Browser panel) by clicking the \"square in circle\" button in the far left border of the JupyterLab window (which says \"Running Terminals and Kernels\" when you hover over it). **Kill the ipython kernel by clicking on the \"Shut Down All\" words to the right of the \"KERNELS\" section header in that panel. If you have other running kernels that you don't want to kill, you can instead open the KERNELS section by clicking on the word KERNELS, finding the line with your script's filename and an alphanumeric code like (1c7e3b30) following it, mousing over it. and clicking the \"X\" that appears to its right. It's easy to forget to kill the kernel, since there's no visual reminder that its running once you've closed the pane. Nothing terrible will happen if you forget, but it will hang around and take up memory on the server and generally cruft things up, so please try to remember. Recipe, Part 6: Resuming If, some time later, you wish to re-run and perhaps modify or extend your script, no problems! Locate the script in the File Browser and reopen it by double-clicking on it. Edit as you wish. Launch an IPython console for it, as described above in Recipe Part 3 (method A or B). Run, modify, and rerun it as you did in Recipe Parts 3 and 4. When done, quit as in Recipe Part 5. An Example Whew! That took a lot longer to describe than it actually takes to do. Let's look at an example. We'll revisit the physics calculation from our earlier recipe Use Python Functions , showing how the same calculation might be laid out in a script. I'll focus on the contents of the script, letting you walk through the procedural steps around it. For convenience, here's the problem again: Problem: An unpowered projectile is launched from the ground with an initial speed of 20 m/s at an angle of 50\u00b0 above the horizontal. What are its speed and direction when it's height above the ground is 10 m? Solution: Elementary kinematics allows one to derive expressions for the horizontal and vertical component of the projectile's velocity at any height \\(h\\) (not greater than its maximum height, of course): \\[v_x(h) = v_{0,x} \\qquad v_y(h) = \\sqrt{v_{0,y}^2 - 2gh}\\] where \\(v_{0,x}\\) and \\(v_{0,y}\\) are the components of the projectile's initial velocity, \\(g\\) is the acceleration due to gravity, and \\(h\\) is the height above the ground. If \\(\\theta_0\\) represents the velocity's initial angle above horizontal, we can decompose the initial velocity vector into: \\[v_{0,x} = v_0 \\cos(\\theta_0) \\qquad v_{0,y} = v_0 \\sin(\\theta_0)\\] We can use the expressions above to determine the components of the initial velocity vector, and then the velocity components at the given height. Once we know those, we can calculate the requested values by applying trig to find the magnitude and direction of the velocity vector at that height: \\[v(h) = \\sqrt{v_x(h)^2 + v_y(h)^2} \\qquad \\theta(h) = \\arctan\\left(\\frac{v_y(h)}{v_x(h)}\\right)\\] The script: A python script to do the numeric calculations for this might \u2014 if well-organized and commented \u2014 look something like this: # ------------------------------------------------------------------- # PHY 291 HW-2 Problem 3 -- Calculations # ------------------------------------------------------------------- # Imports from math import radians, degrees, sin, cos, sqrt, atan2 # Define constants g = 9.806 # N/kg -- local gravitational constant # Define givens h = 10 # m -- height for which we want velocity v0 = 20 # m/s -- initial speed q0 = radians(50) # degrees (converted) -- initial direction # Calculate initial velocity components v0x = v0 * cos(q0) v0y = v0 * sin(q0) # Calculate velocity components at height `h` vx = v0x vy = sqrt(v0y**2 - 2 * g * h) # Calculate magnitude and direction v = sqrt(vx**2 + vy**2) q = atan2(vy, vx) # Report out the result print(f\"At a height of {h} m, the final velocity is {v:.2f} m/s\") print(f\"at an angle of {degrees(q):.2f} degrees above horizontal.\") # ------------------------------------------------------------------- Let's assume we named the file hw02-p3.py . Executing %run hw02-p3.py in an IPython console would produce the following output: At a height of 10 m, the final velocity is 14.28 m/s at an angle of 25.80 degrees above horizontal. Should we want to know the velocity at a different height, we could edit the script to change h = 10 to a different number, and then re-run the script. Easy peasy. A few comments: You might think including all those section comments like \"# Calculate magnitude and direction\" is overkill and a waste of time, but it's actually helpful if you do it right: Write out the sequence of section comments first , like a kind of \"outline\" or \"recipe\" to follow. Then, fill in the code for each section. You can skip the import section at first, adding bits to it as you're writing other sections and realize the functions you'll need to import. I chose to import specific math module functions by name here, but there are enough that using the import math as m route would be reasonable too. I didn't use the comma trick to define related variables (like vx and vy ) on one line, but you could. Note that I did NOT \"hard-code\" any of the given values into the calculations or the final print statements. For example, I used f-string variable insertion to include the height value, rather than just typing At a height of 10 m . This way, I only have to edit one number to change the whole calculation and output to use a different height. Had I hard-coded a result, I introduce the risk of forgetting to change it in all places \u2014 a very VERY common coding error.","title":"Script a Calculation"},{"location":"recipes/core/calculation/scripts/#script-a-calculation","text":"","title":"Script a Calculation"},{"location":"recipes/core/calculation/scripts/#problem-to-solve","text":"I want to make a multi-step calculation easier to construct and debug, run multiple times, run again later, and/or have a permanent record of. Up until now, we've been using the IPython console as a kind of scientific calculator on steroids. This makes sense for quick one-off calculations. However, it has two major drawbacks: Repeating the same calculation with different given values is tedious and error-prone, and Constructing more complicated, multi-step calculations is awkward and error-prone, especially when repeated trying-fixing-trying again or debugging cycles are required. The solution: Write your lines of python code in a script file , using a text editor of some kind. Then, send the whole file to the python interpreter (from IPython or a terminal console) to execute. The interpreter will still work through your code one line at a time, just as if you'd entered them into an IPython session console. The biggest difference is that you won't see the results of bare python expressions. If you want your script to give you some results, you'll need to use the print() statement.","title":"Problem to Solve"},{"location":"recipes/core/calculation/scripts/#recipe-part-1-create-the-script-file","text":"Python scripts are just sequences of python commands, saved in a file with a .py extension. You can write and edit them in any text editor, but it's easiest to work in one that's meant for coding and provides useful functionality like auto-indentation and syntax coding. JupyterLab is a great choice for this. In JupyterLab , open the left-side File Browser (if not already open). In the File Browser, navigate to the folder where you want to save your script file. You can create folders and subfolders for this, if you wish, using the new-folder button at the top of the File Browser. If the Launcher is not open, open it by clicking the + button at the top of the File Browser or in the tab bar above the main panel. In the Launcher, click the \"Python File\" button down in the \"Other\" section. The Launcher should be replaced by a blank window with a tab that says \"untitled.py\". You can immediately give the file a more sensible name by saving it (cmd/ctrl-S or \"Save Python File\" from the JupyterLab File menu) and specifying a name. Give it a meaningful name, but don't use spaces or special characters other than the underscore, and make sure to keep the .py ending. You should see it show up in the File Browser. It's a good habit to immediately put a comment line (or several) at the top of the file, briefly stating what the script's purpose is. That could be as simple as something like # Calculations for PHY 325 HW 3 Problem 2 . In python code, any line beginning with a # (possibly preceded by empty space) is considered a \"comment\" for humans only, and is ignored by the python interpreter. You now have a python script! Admittedly, it doesn't do anything yet, so\u2026","title":"Recipe, Part 1: Create the Script File"},{"location":"recipes/core/calculation/scripts/#recipe-part-2-write-the-script","text":"The short version: Just write python code in the file, as you would type it into an interactive python/ipython session. When you run the script, the lines in the file will be sent to the python interpreter one at a time, in the order they appear. If the very last non-empty line is an expression that would return a result (rather than, say, a variable assignment), that result will be shown as the \"result\" of the script. The longer version, showing good script organization habits: Begin the script with an informative comment , as described above. Think about explaining \"WTH is this script for?\" to anyone (including far-future you) that might look at it, as well as any assumptions that might not be obvious from the code. And, if this might be shared or distributed, include your name and a date and such. Next, import any needed modules , or functions from modules. Putting all the import statements at the top makes it easy for someone to see what your code's \"dependencies\" are. As you start writing bigger, more sophisticated programs with nonstandard third-party modules, this becomes increasingly important. Define variables for any physical or other \"standard\" constants , like the local or universal gravitational constants, the speed of light, etc. End the line with a comment that includes the units, like these: G = 6.67430e-11 # m**3 / (kg s**2) c = 2.99792458e8 # m/s Define variables for any situation-specific given values , also with explicit units in a comment. If the physical meaning of the variable is not obvious from its name, say what it is in the comment. m1 = 2.5 # kg, mass of upper block m2 = 2.5 # kg, mass of lower block mu_k = 0.3 # coefficient of kinetic friction between lower block and tabletop Note that you can use some extra space characters to make the comments align nicely. Calculate intermediate values and chunks of complicated expressions , storing them in variables and building up the calculation step by step. Again, include comments for anything not self-explanatory. I = (2/5) * M * R**2 # kg m**2, moment of inertia of the sphere A = 1 / r1 + 1 / r2 # denominator of net potential expression Use print() to display result(s) , using f-string format codes as you see fit. See the recipe Print Formatted Output for details. x_f, v_f, m.degrees(angle_f) (assuming your script already assigned values to the variables x_f , v_f , and angle_f ) Save your edits. It's probably wise to do this every so often as you work, just in case.","title":"Recipe, Part 2: Write the Script"},{"location":"recipes/core/calculation/scripts/#recipe-part-3-run-the-script","text":"You can run the script directly from within an active IPython session, or from the system command line in a terminal.","title":"Recipe, Part 3: Run the Script"},{"location":"recipes/core/calculation/scripts/#method-a-from-ipython","text":"If you're in JupyterLab , you can easily open an IPython session with the correct working directory by right-clicking (or double-tapping or whatever) on the script file's title tab at the top of the editor, and selecting \"Create Console for Editor\". You should get a \"Select Kernel\" dialog. Choose \"Python 3 (ipykernel)\". Click \"Select\". A new pane should pop open, probably in the bottom half of the window. If you wish, you can grab the console by its tab and drag it to the right of the screen (to split vertically instead of horizontally), or right next to the script file's tab (to let you switch back and forth between the tabs, giving each a full window of space). This is a normal ipython session, so you can do the usual interactive python things there. And, you can run your python script (or any python script, really) by entering the magic command %run your_filename.py , replacing the your_filename bit with whatever you named your file. You should see the result of your script appear in the IPython console, exactly as if you'd typed the lines in, one at a time. (Except that you won't see the results of any expressions except the last in the script.) Any variables you've defined in the script are now defined in the IPython session, with whatever values the script assigned to them, so you can continue the calculation, or explore their values, or whatever you might want to do with them.","title":"Method A: From IPython"},{"location":"recipes/core/calculation/scripts/#recipe-part-4-modify-the-script","text":"If you discover an error, or you want to run it with different givens, or you're dissatisfied with what the script outputs, or you want to extend it \u2014 immediately, or days or months later \u2014 doing that is far easier than if you'd been working interactively in the console. Edit the script in the editor window in whatever way you wish. Save changes via the usual method (cmd/ctrl-S or \"Save Python File\" from the JupyterLab File menu). Run the script as in Recipe Part 3.","title":"Recipe, Part 4: Modify the Script"},{"location":"recipes/core/calculation/scripts/#recipe-part-5-quitting","text":"When you're done (at least for a while): Close the IPython console by clicking the x in the tab. The pane should disappear. Open the \"Running Terminals and Kernels\" panel (in place of the File Browser panel) by clicking the \"square in circle\" button in the far left border of the JupyterLab window (which says \"Running Terminals and Kernels\" when you hover over it). **Kill the ipython kernel by clicking on the \"Shut Down All\" words to the right of the \"KERNELS\" section header in that panel. If you have other running kernels that you don't want to kill, you can instead open the KERNELS section by clicking on the word KERNELS, finding the line with your script's filename and an alphanumeric code like (1c7e3b30) following it, mousing over it. and clicking the \"X\" that appears to its right. It's easy to forget to kill the kernel, since there's no visual reminder that its running once you've closed the pane. Nothing terrible will happen if you forget, but it will hang around and take up memory on the server and generally cruft things up, so please try to remember.","title":"Recipe, Part 5: Quitting"},{"location":"recipes/core/calculation/scripts/#recipe-part-6-resuming","text":"If, some time later, you wish to re-run and perhaps modify or extend your script, no problems! Locate the script in the File Browser and reopen it by double-clicking on it. Edit as you wish. Launch an IPython console for it, as described above in Recipe Part 3 (method A or B). Run, modify, and rerun it as you did in Recipe Parts 3 and 4. When done, quit as in Recipe Part 5.","title":"Recipe, Part 6: Resuming"},{"location":"recipes/core/calculation/scripts/#an-example","text":"Whew! That took a lot longer to describe than it actually takes to do. Let's look at an example. We'll revisit the physics calculation from our earlier recipe Use Python Functions , showing how the same calculation might be laid out in a script. I'll focus on the contents of the script, letting you walk through the procedural steps around it. For convenience, here's the problem again: Problem: An unpowered projectile is launched from the ground with an initial speed of 20 m/s at an angle of 50\u00b0 above the horizontal. What are its speed and direction when it's height above the ground is 10 m? Solution: Elementary kinematics allows one to derive expressions for the horizontal and vertical component of the projectile's velocity at any height \\(h\\) (not greater than its maximum height, of course): \\[v_x(h) = v_{0,x} \\qquad v_y(h) = \\sqrt{v_{0,y}^2 - 2gh}\\] where \\(v_{0,x}\\) and \\(v_{0,y}\\) are the components of the projectile's initial velocity, \\(g\\) is the acceleration due to gravity, and \\(h\\) is the height above the ground. If \\(\\theta_0\\) represents the velocity's initial angle above horizontal, we can decompose the initial velocity vector into: \\[v_{0,x} = v_0 \\cos(\\theta_0) \\qquad v_{0,y} = v_0 \\sin(\\theta_0)\\] We can use the expressions above to determine the components of the initial velocity vector, and then the velocity components at the given height. Once we know those, we can calculate the requested values by applying trig to find the magnitude and direction of the velocity vector at that height: \\[v(h) = \\sqrt{v_x(h)^2 + v_y(h)^2} \\qquad \\theta(h) = \\arctan\\left(\\frac{v_y(h)}{v_x(h)}\\right)\\] The script: A python script to do the numeric calculations for this might \u2014 if well-organized and commented \u2014 look something like this: # ------------------------------------------------------------------- # PHY 291 HW-2 Problem 3 -- Calculations # ------------------------------------------------------------------- # Imports from math import radians, degrees, sin, cos, sqrt, atan2 # Define constants g = 9.806 # N/kg -- local gravitational constant # Define givens h = 10 # m -- height for which we want velocity v0 = 20 # m/s -- initial speed q0 = radians(50) # degrees (converted) -- initial direction # Calculate initial velocity components v0x = v0 * cos(q0) v0y = v0 * sin(q0) # Calculate velocity components at height `h` vx = v0x vy = sqrt(v0y**2 - 2 * g * h) # Calculate magnitude and direction v = sqrt(vx**2 + vy**2) q = atan2(vy, vx) # Report out the result print(f\"At a height of {h} m, the final velocity is {v:.2f} m/s\") print(f\"at an angle of {degrees(q):.2f} degrees above horizontal.\") # ------------------------------------------------------------------- Let's assume we named the file hw02-p3.py . Executing %run hw02-p3.py in an IPython console would produce the following output: At a height of 10 m, the final velocity is 14.28 m/s at an angle of 25.80 degrees above horizontal. Should we want to know the velocity at a different height, we could edit the script to change h = 10 to a different number, and then re-run the script. Easy peasy. A few comments: You might think including all those section comments like \"# Calculate magnitude and direction\" is overkill and a waste of time, but it's actually helpful if you do it right: Write out the sequence of section comments first , like a kind of \"outline\" or \"recipe\" to follow. Then, fill in the code for each section. You can skip the import section at first, adding bits to it as you're writing other sections and realize the functions you'll need to import. I chose to import specific math module functions by name here, but there are enough that using the import math as m route would be reasonable too. I didn't use the comma trick to define related variables (like vx and vy ) on one line, but you could. Note that I did NOT \"hard-code\" any of the given values into the calculations or the final print statements. For example, I used f-string variable insertion to include the height value, rather than just typing At a height of 10 m . This way, I only have to edit one number to change the whole calculation and output to use a different height. Had I hard-coded a result, I introduce the risk of forgetting to change it in all places \u2014 a very VERY common coding error.","title":"An Example"},{"location":"recipes/core/calculation/use-functions/","text":"Use Python Functions Problem to Solve I want to use predefined mathematical (or other) functions, like sine or absolute-value, in my calculation. Introduction Python has a truly incredible arsenal of ready-to-use functions available to you. A few are built into core python, many many more are available through python's \"standard library modules\", and a truly humongous number are available through a vast ecosystem of third-party add-on modules that you can download and install as needed. I think it's fair to say that before you spend time and effort figuring out how to do a coding task, it's worth stopping and asking yourself: \"Does this seem like the kind of thing that people might commonly want to do, or is it really idiosyncratic to my situation?\" If the former, there's probably a function already in existence for it. Depending on how hard the task is, and how critical your code's need for efficiency is, finding that function may or may not be the worth the time. The question is worth entertaining, though, and getting familiar with the range of functionality available to you is definitely worthwhile. In this recipe, we'll focus predominantly on mathematically-oriented functions, but the same process applies to string (text) manipulation, rearranging collections of things, serving up web pages, and so on. Recipe for Built-In Functions (This barely deserves the name \"recipe\".) If you need functionality provided by core python functions, just use them, like this: function_name() for a function that takes no arguments, or function_name(argument_value_1, argument_value_2, ...) for a function that takes one or more arguments. To get the absolute value of the number stored in variable x , use abs(x) . To calculate the seventh power of x , pow(x, 7) and x**7 are equivalent. To round a floating-point number a to its nearest integer, use round(a) . To round a floating-point number a to n decimal places, use round(a, n) . That's about it for mathematically-oriented functions, unless you want to check whether a particular variable is storing an integer, floating-point, or complex number: >>> a, b, c = 3, 3.0, 3+0j >>> type(a), type(b), type(c) (<class 'int'>, <class 'float'>, <class 'complex'>) Or, you can (sometimes) forcibly change a variable to a different numeric type: >>> int(b) 3 >>> type(int(b)) <class 'int'> >>> s = \"3.14\" >>> round(s) Traceback (most recent call last): File \"<python-input-15>\", line 1, in <module> round(s) ~~~~~^^^ TypeError: type str doesn't define __round__ method >>> round(float(s)) 3 >>> float(c) Traceback (most recent call last): File \"<python-input-17>\", line 1, in <module> float(c) ~~~~~^^^ TypeError: float() argument must be a string or a real number, not 'complex' See here if you want a thorough explanation of the core python functions available. (That's far beyond what this course requires.) Recipe for Standard Library Functions, Version A: Selective Import To get a sense of the \"modules\" available in the python \"standard library\" \u2014 which come as part of a standard python installation, and therefore are always available to you \u2014 take a quick browse through the python module index , and drill down into any specific modules that catch your interest. At the very least, browse through the math module ; you'll be using that A LOT. It's necessary to \"import\" a module, or specific pieces of a module, before using them. In general, if you'll only be using a few of the functions in a module, it's best to import just those functions. Here's the generic recipe: from [module_name] import [comma-separated list of function names] You can then use the functions you've imported exactly as if they were built-in functions. Here's a (very contrived) example: >>> from math import radians, degrees, sin, acos, sqrt >>> angle = radians(76.543) >>> degrees( acos( sqrt( 1 - sin(angle)**2 ) ) ) 76.54299999999999 Recipe for Standard Library Functions, Version B: Import the Module If you'll be using many functions from one module \u2014 or if you'll be doing a fair amount of exploratory calculation and you don't really know which you'll be using and don't want to bother importing each function separately as you realize you need it \u2014 you can just import the whole module. Here's an example: >>> import math >>> math.sin(math.radians(30)) 0.49999999999999994 The general recipe is just import module_name , after which you must refer to the bits of the module with a prefix of module_name.function_name(...) . Yes, that can get a bit tedious. You can make it a bit more compact by giving the module a shorthand name as you import it, using the import module_name as nickname syntax: >>> import math as m >>> m.sin(m.radians(30)) 0.49999999999999994 Just be careful that you don't accidentally define a variable m as well, or one will \"shadow\" the other: >>> import math as m >>> m = 33 >>> m.sin(0) Traceback (most recent call last): File \"<python-input-33>\", line 1, in <module> m.sin(0) ^^^^^ AttributeError: 'int' object has no attribute 'sin' Recipe for Standard Library Functions, Version C: Import Everything From the Module If you really don't want to be bothered typing a prefix on every imported function, and just want everything in a module available as if it were all built-in or as if you'd listed EVERYTHING on an from module_name import ... line, you can, via the wildcard symbol * that means \"everything\": >>> from math import * >>> angle = radians(76.543) >>> sqrt( sin(angle)**2 + cos(angle)**2 ) 1.0 WARNING: Everything in the module \u2014 which could include functions, constants, sub-modules, objects, and who-knows-what else \u2014 will get dumped into your namespace. That creates A LOT of potential for name collisions with your own variables, especially since you may not know all the names that were imported. For example, in physics, the Greek letters \"alpha\" and \"tau\" are frequently used to represent angular acceleration and torque, respectively. Imagine that you're doing a rotational motion calculation, and the expression you've derived for an angular acceleration is \\(\\alpha = \\tau / I\\) where \\(I = m \\left[d \\ \\sin(30^\\circ)\\right]^2\\) with given values are \\(\\tau = 3.2 \\times 10^5\\) , \\(m = 1500\\) , and \\(d = 18\\) (all in SI units). If you do this: >>> m, d, tau = 1.5e3, 18, 3.2e5 >>> from math import * >>> I = m * (d * sin(radians(30)))**2 >>> tau / I 5.171345931835052e-05 \u2026you'll be dead wrong. Compare the final result with this: >>> m, d, tau = 1.5e3, 18, 3.2e5 >>> import math >>> I = m * (d * math.sin(math.radians(30)))**2 >>> tau / I 2.633744855967079 Challenge: Can you figure out why? An Example Problem: An unpowered projectile is launched from the ground with an initial speed of 20 m/s at an angle of 50\u00b0 above the horizontal. What are its speed and direction when it's height above the ground is 10 m? Solution: Elementary kinematics allows one to derive expressions for the horizontal and vertical component of the projectile's velocity at any height \\(h\\) (not greater than its maximum height, of course): \\[v_x(h) = v_{0,x} \\qquad v_y(h) = \\sqrt{v_{0,y}^2 - 2gh}\\] where \\(v_{0,x}\\) and \\(v_{0,y}\\) are the components of the projectile's initial velocity, \\(g\\) is the acceleration due to gravity, and \\(h\\) is the height above the ground. If \\(\\theta_0\\) represents the velocity's initial angle above horizontal, we can decompose the initial velocity vector into: \\[v_{0,x} = v_0 \\cos(\\theta_0) \\qquad v_{0,y} = v_0 \\sin(\\theta_0)\\] We can use the expressions above to determine the components of the initial velocity vector, and then the velocity components at the given height. Once we know those, we can calculate the requested values by applying trig to find the magnitude and direction of the velocity vector at that height: \\[v(h) = \\sqrt{v_x(h)^2 + v_y(h)^2} \\qquad \\theta(h) = \\arctan\\left(\\frac{v_y(h)}{v_x(h)}\\right)\\] In [1]: import math as m In [2]: v0, q0 = 20, m.radians(50) In [3]: v0x, v0y = v0 * m.cos(q0), v0 * m.sin(q0) In [4]: v0x, v0y Out[4]: (12.855752193730787, 15.32088886237956) In [5]: g = 9.806 In [6]: h = 10 In [7]: vx, vy = v0x, m.sqrt(v0y**2 - 2 * g * h) In [8]: vx, vy Out[8]: (12.855752193730787, 6.213665225403286) In [9]: v = m.sqrt(vx**2 + vy**2) In [10]: q = m.atan2(vy, vx) In [11]: v, m.degrees(q) Out[11]: (14.278655398881227, 25.79621315114633) Notes: I make liberal use of the \"comma trick\" to define two related variables on one line. You don't have to. Since you can't really use Greek letters in code, I've developed a habit of using q or Q in place of \\(\\theta\\) , w in place of \\(\\omega\\) , and ph in place of \\(\\phi\\) . Because I do this regularly, my code is still readable, at least to me. Writing out the names like theta isn't a bad idea either. Nor is using descriptive names like initial_angle or angular_freq . Python's trig functions all work in radians , but we often use degrees for human interpretability, so converting back and forth is a way of life. Get used to this! A good practice is to make sure all angle variables in your code ALWAYS contain values in radians. If given degrees, don't even store that value; immediately use math.radians() to convert to radians and store that in a variable, as I did in line 2. If asked to report a result in degrees, calculate it in radians and use math.degrees() as you display it. If you really want to store a value in degrees in a variable, give it a name like theta_deg to remind yourself that it's in degrees. In line 4, I peeked at the values of the initial velocity components to make sure they seemed plausible. If I'd screwed up something, perhaps by forgetting to convert degrees to radians, I might have noticed it here. In line 10, I used the math module's atan2() function instead of the atan() function. It shouldn't really matter in this situation, but you should know about how they differ. Go read about them in the math module documentation. TLDR: atan2 is smarter about figuring out the right quadrant. atan can't tell between the first and third quadrants, or between the second and fourth.","title":"Use Python Functions"},{"location":"recipes/core/calculation/use-functions/#use-python-functions","text":"","title":"Use Python Functions"},{"location":"recipes/core/calculation/use-functions/#problem-to-solve","text":"I want to use predefined mathematical (or other) functions, like sine or absolute-value, in my calculation.","title":"Problem to Solve"},{"location":"recipes/core/calculation/use-functions/#introduction","text":"Python has a truly incredible arsenal of ready-to-use functions available to you. A few are built into core python, many many more are available through python's \"standard library modules\", and a truly humongous number are available through a vast ecosystem of third-party add-on modules that you can download and install as needed. I think it's fair to say that before you spend time and effort figuring out how to do a coding task, it's worth stopping and asking yourself: \"Does this seem like the kind of thing that people might commonly want to do, or is it really idiosyncratic to my situation?\" If the former, there's probably a function already in existence for it. Depending on how hard the task is, and how critical your code's need for efficiency is, finding that function may or may not be the worth the time. The question is worth entertaining, though, and getting familiar with the range of functionality available to you is definitely worthwhile. In this recipe, we'll focus predominantly on mathematically-oriented functions, but the same process applies to string (text) manipulation, rearranging collections of things, serving up web pages, and so on.","title":"Introduction"},{"location":"recipes/core/calculation/use-functions/#recipe-for-built-in-functions","text":"(This barely deserves the name \"recipe\".) If you need functionality provided by core python functions, just use them, like this: function_name() for a function that takes no arguments, or function_name(argument_value_1, argument_value_2, ...) for a function that takes one or more arguments. To get the absolute value of the number stored in variable x , use abs(x) . To calculate the seventh power of x , pow(x, 7) and x**7 are equivalent. To round a floating-point number a to its nearest integer, use round(a) . To round a floating-point number a to n decimal places, use round(a, n) . That's about it for mathematically-oriented functions, unless you want to check whether a particular variable is storing an integer, floating-point, or complex number: >>> a, b, c = 3, 3.0, 3+0j >>> type(a), type(b), type(c) (<class 'int'>, <class 'float'>, <class 'complex'>) Or, you can (sometimes) forcibly change a variable to a different numeric type: >>> int(b) 3 >>> type(int(b)) <class 'int'> >>> s = \"3.14\" >>> round(s) Traceback (most recent call last): File \"<python-input-15>\", line 1, in <module> round(s) ~~~~~^^^ TypeError: type str doesn't define __round__ method >>> round(float(s)) 3 >>> float(c) Traceback (most recent call last): File \"<python-input-17>\", line 1, in <module> float(c) ~~~~~^^^ TypeError: float() argument must be a string or a real number, not 'complex' See here if you want a thorough explanation of the core python functions available. (That's far beyond what this course requires.)","title":"Recipe for Built-In Functions"},{"location":"recipes/core/calculation/use-functions/#recipe-for-standard-library-functions-version-a-selective-import","text":"To get a sense of the \"modules\" available in the python \"standard library\" \u2014 which come as part of a standard python installation, and therefore are always available to you \u2014 take a quick browse through the python module index , and drill down into any specific modules that catch your interest. At the very least, browse through the math module ; you'll be using that A LOT. It's necessary to \"import\" a module, or specific pieces of a module, before using them. In general, if you'll only be using a few of the functions in a module, it's best to import just those functions. Here's the generic recipe: from [module_name] import [comma-separated list of function names] You can then use the functions you've imported exactly as if they were built-in functions. Here's a (very contrived) example: >>> from math import radians, degrees, sin, acos, sqrt >>> angle = radians(76.543) >>> degrees( acos( sqrt( 1 - sin(angle)**2 ) ) ) 76.54299999999999","title":"Recipe for Standard Library Functions, Version A: Selective Import"},{"location":"recipes/core/calculation/use-functions/#recipe-for-standard-library-functions-version-b-import-the-module","text":"If you'll be using many functions from one module \u2014 or if you'll be doing a fair amount of exploratory calculation and you don't really know which you'll be using and don't want to bother importing each function separately as you realize you need it \u2014 you can just import the whole module. Here's an example: >>> import math >>> math.sin(math.radians(30)) 0.49999999999999994 The general recipe is just import module_name , after which you must refer to the bits of the module with a prefix of module_name.function_name(...) . Yes, that can get a bit tedious. You can make it a bit more compact by giving the module a shorthand name as you import it, using the import module_name as nickname syntax: >>> import math as m >>> m.sin(m.radians(30)) 0.49999999999999994 Just be careful that you don't accidentally define a variable m as well, or one will \"shadow\" the other: >>> import math as m >>> m = 33 >>> m.sin(0) Traceback (most recent call last): File \"<python-input-33>\", line 1, in <module> m.sin(0) ^^^^^ AttributeError: 'int' object has no attribute 'sin'","title":"Recipe for Standard Library Functions, Version B: Import the Module"},{"location":"recipes/core/calculation/use-functions/#recipe-for-standard-library-functions-version-c-import-everything-from-the-module","text":"If you really don't want to be bothered typing a prefix on every imported function, and just want everything in a module available as if it were all built-in or as if you'd listed EVERYTHING on an from module_name import ... line, you can, via the wildcard symbol * that means \"everything\": >>> from math import * >>> angle = radians(76.543) >>> sqrt( sin(angle)**2 + cos(angle)**2 ) 1.0 WARNING: Everything in the module \u2014 which could include functions, constants, sub-modules, objects, and who-knows-what else \u2014 will get dumped into your namespace. That creates A LOT of potential for name collisions with your own variables, especially since you may not know all the names that were imported. For example, in physics, the Greek letters \"alpha\" and \"tau\" are frequently used to represent angular acceleration and torque, respectively. Imagine that you're doing a rotational motion calculation, and the expression you've derived for an angular acceleration is \\(\\alpha = \\tau / I\\) where \\(I = m \\left[d \\ \\sin(30^\\circ)\\right]^2\\) with given values are \\(\\tau = 3.2 \\times 10^5\\) , \\(m = 1500\\) , and \\(d = 18\\) (all in SI units). If you do this: >>> m, d, tau = 1.5e3, 18, 3.2e5 >>> from math import * >>> I = m * (d * sin(radians(30)))**2 >>> tau / I 5.171345931835052e-05 \u2026you'll be dead wrong. Compare the final result with this: >>> m, d, tau = 1.5e3, 18, 3.2e5 >>> import math >>> I = m * (d * math.sin(math.radians(30)))**2 >>> tau / I 2.633744855967079 Challenge: Can you figure out why?","title":"Recipe for Standard Library Functions, Version C: Import Everything From the Module"},{"location":"recipes/core/calculation/use-functions/#an-example","text":"Problem: An unpowered projectile is launched from the ground with an initial speed of 20 m/s at an angle of 50\u00b0 above the horizontal. What are its speed and direction when it's height above the ground is 10 m? Solution: Elementary kinematics allows one to derive expressions for the horizontal and vertical component of the projectile's velocity at any height \\(h\\) (not greater than its maximum height, of course): \\[v_x(h) = v_{0,x} \\qquad v_y(h) = \\sqrt{v_{0,y}^2 - 2gh}\\] where \\(v_{0,x}\\) and \\(v_{0,y}\\) are the components of the projectile's initial velocity, \\(g\\) is the acceleration due to gravity, and \\(h\\) is the height above the ground. If \\(\\theta_0\\) represents the velocity's initial angle above horizontal, we can decompose the initial velocity vector into: \\[v_{0,x} = v_0 \\cos(\\theta_0) \\qquad v_{0,y} = v_0 \\sin(\\theta_0)\\] We can use the expressions above to determine the components of the initial velocity vector, and then the velocity components at the given height. Once we know those, we can calculate the requested values by applying trig to find the magnitude and direction of the velocity vector at that height: \\[v(h) = \\sqrt{v_x(h)^2 + v_y(h)^2} \\qquad \\theta(h) = \\arctan\\left(\\frac{v_y(h)}{v_x(h)}\\right)\\] In [1]: import math as m In [2]: v0, q0 = 20, m.radians(50) In [3]: v0x, v0y = v0 * m.cos(q0), v0 * m.sin(q0) In [4]: v0x, v0y Out[4]: (12.855752193730787, 15.32088886237956) In [5]: g = 9.806 In [6]: h = 10 In [7]: vx, vy = v0x, m.sqrt(v0y**2 - 2 * g * h) In [8]: vx, vy Out[8]: (12.855752193730787, 6.213665225403286) In [9]: v = m.sqrt(vx**2 + vy**2) In [10]: q = m.atan2(vy, vx) In [11]: v, m.degrees(q) Out[11]: (14.278655398881227, 25.79621315114633)","title":"An Example"},{"location":"recipes/core/calculation/use-functions/#notes","text":"I make liberal use of the \"comma trick\" to define two related variables on one line. You don't have to. Since you can't really use Greek letters in code, I've developed a habit of using q or Q in place of \\(\\theta\\) , w in place of \\(\\omega\\) , and ph in place of \\(\\phi\\) . Because I do this regularly, my code is still readable, at least to me. Writing out the names like theta isn't a bad idea either. Nor is using descriptive names like initial_angle or angular_freq . Python's trig functions all work in radians , but we often use degrees for human interpretability, so converting back and forth is a way of life. Get used to this! A good practice is to make sure all angle variables in your code ALWAYS contain values in radians. If given degrees, don't even store that value; immediately use math.radians() to convert to radians and store that in a variable, as I did in line 2. If asked to report a result in degrees, calculate it in radians and use math.degrees() as you display it. If you really want to store a value in degrees in a variable, give it a name like theta_deg to remind yourself that it's in degrees. In line 4, I peeked at the values of the initial velocity components to make sure they seemed plausible. If I'd screwed up something, perhaps by forgetting to convert degrees to radians, I might have noticed it here. In line 10, I used the math module's atan2() function instead of the atan() function. It shouldn't really matter in this situation, but you should know about how they differ. Go read about them in the math module documentation. TLDR: atan2 is smarter about figuring out the right quadrant. atan can't tell between the first and third quadrants, or between the second and fourth.","title":"Notes:"},{"location":"recipes/core/calculation/user-input/","text":"Ask for User Input Problem to Solve I want to be able to run my script (or let someone else run it) with various given values, without having to edit the script each time. Editing and re-running a script isn't hard if you already have the script open in your editor. However, it's possible to run a script without opening it in an editor; one way is to simply execute python my_script.py in a terminal, assuming the script file is in the current working directory. (On some systems, you may have to execute python3 my_script.py instead.) In such a case, it's convenient to let the script ask the user for values when it runs. Recipe Python has a built-in input() function that asks the user for input. You can use this to get given values at run-time, but you'll need to do a bit of extra work to get numerical values and protect against incorrect entries. Here's the generic recipe: # Ask user for a value: variable_name = input(\"Prompt string: \") # Convert from a string to a float: # (Use `int` for an integer or `complex` for a complex number.) variable_name = float(variable_name) # Do any necessary safety-checking, such as: assert variable_name >= 0, \"Value must be non-negative.\" You can compactify this, if you want: variable_name = float(input(\"Prompt string: \")) assert variable_name >= 0, \"Value must be non-negative.\" Notes: Change variable_name to the name you want to use for the value you're getting from the user: m , v0 , or whatever. Change Prompt string to an appropriate cue to the user. Be explicit about units, if appropriate, so you don't get a mass in grams when the code is expecting kilograms, or an angle in radians when it expects degrees. Example: m1 = float(input(\"Mass 1 (in kg): )) The float(\u2026) or int(\u2026) or complex(\u2026) is necessary because the input(\u2026) function returns the user's input as a string. Your code must coerce it into the desired type. If the user enters something that's not directly interpretable as the desired type, python will raise a scary error. We'll learn how to handle this gracefully later. If the input is 2.5 kg , float(\u2026) will fail. If the input is 3.2 or even 3.0 , int(\u2026) will fail. complex(\u2026) is picky: 3-2j is fine, but 3 - 2j will fail because of the spaces around the minus sign. \ud83e\udd37\u200d\u2642\ufe0f assert is a useful python keyword. Here's what it does: If the logical statement following it is true, the line does nothing and the script continues to the next line. If the logical statement is false, python raises an error and aborts the script, displaying a scary and cryptic error message to the user. The comma and string after it are optional. If you provide them, the string will be displayed to the user as part of the error message. You can (and should) use this to tell the user specifically what they did wrong. It's not hard to write a better version of this recipe that handles invalid input more gracefully \u2014 for example, letting the user try repeatedly until they get it right, and showing a friendly message instead of a scary python error dump when they get it wrong. However, that requires python features we haven't reached yet. So for now, this recipe will suffice. If you want to ask for more than one value, just repeat this recipe more than once in your script, asking the user for each value in turn. An Example Let's write a simple little utility script that calculates a vector's \\(x\\) and \\(y\\) components from its magnitude and direction. # Imports: from math import sin, cos, radians # Ask for the magnitude: mag = input(\"Vector's magnitude (without units): \") mag = float(mag) assert mag >= 0, \"The magnitude must be non-negative!\" # Ask for the direction: angle = input(\"Vector's direction (in degrees CCW from +x axis): \") angle = float(angle) # Calculate components: x = mag * cos(radians(angle)) y = mag * sin(radians(angle)) # Report out: print(f\"=> The vector's components are ({x:.3g}, {y:.3g}).\") Self-explanatory, no?","title":"Ask for User Input"},{"location":"recipes/core/calculation/user-input/#ask-for-user-input","text":"","title":"Ask for User Input"},{"location":"recipes/core/calculation/user-input/#problem-to-solve","text":"I want to be able to run my script (or let someone else run it) with various given values, without having to edit the script each time. Editing and re-running a script isn't hard if you already have the script open in your editor. However, it's possible to run a script without opening it in an editor; one way is to simply execute python my_script.py in a terminal, assuming the script file is in the current working directory. (On some systems, you may have to execute python3 my_script.py instead.) In such a case, it's convenient to let the script ask the user for values when it runs.","title":"Problem to Solve"},{"location":"recipes/core/calculation/user-input/#recipe","text":"Python has a built-in input() function that asks the user for input. You can use this to get given values at run-time, but you'll need to do a bit of extra work to get numerical values and protect against incorrect entries. Here's the generic recipe: # Ask user for a value: variable_name = input(\"Prompt string: \") # Convert from a string to a float: # (Use `int` for an integer or `complex` for a complex number.) variable_name = float(variable_name) # Do any necessary safety-checking, such as: assert variable_name >= 0, \"Value must be non-negative.\" You can compactify this, if you want: variable_name = float(input(\"Prompt string: \")) assert variable_name >= 0, \"Value must be non-negative.\" Notes: Change variable_name to the name you want to use for the value you're getting from the user: m , v0 , or whatever. Change Prompt string to an appropriate cue to the user. Be explicit about units, if appropriate, so you don't get a mass in grams when the code is expecting kilograms, or an angle in radians when it expects degrees. Example: m1 = float(input(\"Mass 1 (in kg): )) The float(\u2026) or int(\u2026) or complex(\u2026) is necessary because the input(\u2026) function returns the user's input as a string. Your code must coerce it into the desired type. If the user enters something that's not directly interpretable as the desired type, python will raise a scary error. We'll learn how to handle this gracefully later. If the input is 2.5 kg , float(\u2026) will fail. If the input is 3.2 or even 3.0 , int(\u2026) will fail. complex(\u2026) is picky: 3-2j is fine, but 3 - 2j will fail because of the spaces around the minus sign. \ud83e\udd37\u200d\u2642\ufe0f assert is a useful python keyword. Here's what it does: If the logical statement following it is true, the line does nothing and the script continues to the next line. If the logical statement is false, python raises an error and aborts the script, displaying a scary and cryptic error message to the user. The comma and string after it are optional. If you provide them, the string will be displayed to the user as part of the error message. You can (and should) use this to tell the user specifically what they did wrong. It's not hard to write a better version of this recipe that handles invalid input more gracefully \u2014 for example, letting the user try repeatedly until they get it right, and showing a friendly message instead of a scary python error dump when they get it wrong. However, that requires python features we haven't reached yet. So for now, this recipe will suffice. If you want to ask for more than one value, just repeat this recipe more than once in your script, asking the user for each value in turn.","title":"Recipe"},{"location":"recipes/core/calculation/user-input/#an-example","text":"Let's write a simple little utility script that calculates a vector's \\(x\\) and \\(y\\) components from its magnitude and direction. # Imports: from math import sin, cos, radians # Ask for the magnitude: mag = input(\"Vector's magnitude (without units): \") mag = float(mag) assert mag >= 0, \"The magnitude must be non-negative!\" # Ask for the direction: angle = input(\"Vector's direction (in degrees CCW from +x axis): \") angle = float(angle) # Calculate components: x = mag * cos(radians(angle)) y = mag * sin(radians(angle)) # Report out: print(f\"=> The vector's components are ({x:.3g}, {y:.3g}).\") Self-explanatory, no?","title":"An Example"},{"location":"recipes/core/collections/","text":"Collection Recipes Collections are data types that act as containers for zero or more other values. Python has four fundamental collection types: tuples , lists , sets , and dictionaries (often called \"dicts\"). Knowing their respective merits and features, knowing how to work with them, and choosing the best one for the job at hand will make your coding life faster and easier. For a high-level overview of collection types in general, see: LaunchSchool: Introduction to Collections This section is not really about specific \"recipes\". Instead, it's a quick overview of these collection types and how to do commonly-needed things to/with them. Group Related Values Into Tuples : I want to collect a few values together into a group that I can treat as one \"thing\", and that won\u2019t need to change. Manage Sequences of Values with Lists : I want to build, modify, retrieve elements from, and iterate over a sequence of values. Identify Unique & Shared Elements with Sets : I want to keep track of a collection of unique values and perhaps compare the values present in different such collections. Organize Labeled Collections with Dictionaries : I want to collect related values together, with the ability to access the elements by some meaningful label rather than by a numeric index. Iterate Pythonically : I want to accomplish various iteration-related tasks while keeping my code simple and easy.","title":"(Recipe List)"},{"location":"recipes/core/collections/#collection-recipes","text":"Collections are data types that act as containers for zero or more other values. Python has four fundamental collection types: tuples , lists , sets , and dictionaries (often called \"dicts\"). Knowing their respective merits and features, knowing how to work with them, and choosing the best one for the job at hand will make your coding life faster and easier. For a high-level overview of collection types in general, see: LaunchSchool: Introduction to Collections This section is not really about specific \"recipes\". Instead, it's a quick overview of these collection types and how to do commonly-needed things to/with them. Group Related Values Into Tuples : I want to collect a few values together into a group that I can treat as one \"thing\", and that won\u2019t need to change. Manage Sequences of Values with Lists : I want to build, modify, retrieve elements from, and iterate over a sequence of values. Identify Unique & Shared Elements with Sets : I want to keep track of a collection of unique values and perhaps compare the values present in different such collections. Organize Labeled Collections with Dictionaries : I want to collect related values together, with the ability to access the elements by some meaningful label rather than by a numeric index. Iterate Pythonically : I want to accomplish various iteration-related tasks while keeping my code simple and easy.","title":"Collection Recipes"},{"location":"recipes/core/collections/dicts/","text":"Organize Labeled Collections with Dictionaries Problem to Solve I want to collect related values together, with the ability to access the elements by some meaningful label rather than by a numeric index. Dictionaries (\"dicts\") are a core workhorse of the python language. Much of python itself is built using dictionaries, which means they are very full-featured and optimized. Like tuples, lists, and sets, dictionaries are a collection of other values. The key difference is that they are key-value pairs: Each value you stick into a dictionary is associated with a key that you can use to retrieve it later. List or tuple: Access an element by its index, for example mylist[3] . Dictionary: Access an element by its key, for example mydict['mass'] . Some online introductions: W3 Schools: Python Dictionaries Geeks for Geeks: Dictionaries in Python A Few Recipes The thing that makes dictionaries more complicated to work with than other kinds of collection is the fact that they contain both keys and values. building a dictionary one key-value pair at a time dict1 = {} # an empty dictionary dict1['mass'] = 9.11e-31 # add a key-value pair dict1['charge'] = -1.6e-19 # add another key-value pair dict1['spin'] = 1/2 # add another key-value pair print(dict1) # yields {'mass': 9.11e-31, 'charge': -1.6e-19, 'spin': 0.5} (This is often something you'll do with a loop, adding one item to the dictionary per iteration.) building a dictionary from multiple key-value pairs at once dict1 = { 'mass': 9.11e-31, 'charge': -1.6e-19, 'spin': 1/2 } # a dictionary with 3 key-value pairs print(dict1) # yields {'mass': 9.11e-31, 'charge': -1.6e-19, 'spin': 0.5} extracting the set of keys key_set = set(dict1.keys()) # the set of keys in dict1 print(key_set) # yields {'mass', 'charge', 'spin'} extracting the keys to a list key_list = list(dict1.keys()) # the keys in a list print(key_list) # yields ['mass', 'charge', 'spin'] extracting the values (without keys) to a list value_list = list(dict1.values()) # the values in a list print(value_list) # yields [9.11e-31, -1.6e-19, 0.5] average_value = mean(value_list) # the average of the values max_value = max(value_list) # the maximum value iterating over the keys for key in dict1: print(key) # yields 'mass', 'charge', 'spin' iterating over the values for value in dict1.values(): print(value) # yields 9.11e-31, -1.6e-19, 0.5 iterating over the key-value pairs for key, value in dict1.items(): print(f\"{key} = {value}\") # yields \"mass = 9.11e-31\", \"charge = -1.6e-19\", \"spin = 0.5\" checking if a key is in the dictionary if 'mass' in dict1: print(\"`mass` is in the dictionary\") else: print(\"`mass` is NOT in the dictionary\") finding the key corresponding to the maximum or minimum value max_key = max(dict1, key=dict1.get) # the key corresponding to the maximum value max_val = dict1[max_key] # the maximum value min_key = min(dict1, key=dict1.get) # the key corresponding to the minimum value min_val = dict1[min_key] # the minimum value getting a list of the keys sorted according to their values (in ascending order) sorted_keys = sorted(dict1, key=dict1.get) # the keys sorted by their values You can then extract the associated values via dict1[key] for whatever key(s) you want. To get the keys in descending order of their values, include the optional reverse=True argument to the sorted() function. Dictionaries have many more features and utility methods, so make sure to read through the references linked above.","title":"Organize Labeled Collections with Dictionaries"},{"location":"recipes/core/collections/dicts/#organize-labeled-collections-with-dictionaries","text":"","title":"Organize Labeled Collections with Dictionaries"},{"location":"recipes/core/collections/dicts/#problem-to-solve","text":"I want to collect related values together, with the ability to access the elements by some meaningful label rather than by a numeric index. Dictionaries (\"dicts\") are a core workhorse of the python language. Much of python itself is built using dictionaries, which means they are very full-featured and optimized. Like tuples, lists, and sets, dictionaries are a collection of other values. The key difference is that they are key-value pairs: Each value you stick into a dictionary is associated with a key that you can use to retrieve it later. List or tuple: Access an element by its index, for example mylist[3] . Dictionary: Access an element by its key, for example mydict['mass'] . Some online introductions: W3 Schools: Python Dictionaries Geeks for Geeks: Dictionaries in Python","title":"Problem to Solve"},{"location":"recipes/core/collections/dicts/#a-few-recipes","text":"The thing that makes dictionaries more complicated to work with than other kinds of collection is the fact that they contain both keys and values.","title":"A Few Recipes"},{"location":"recipes/core/collections/dicts/#building-a-dictionary-one-key-value-pair-at-a-time","text":"dict1 = {} # an empty dictionary dict1['mass'] = 9.11e-31 # add a key-value pair dict1['charge'] = -1.6e-19 # add another key-value pair dict1['spin'] = 1/2 # add another key-value pair print(dict1) # yields {'mass': 9.11e-31, 'charge': -1.6e-19, 'spin': 0.5} (This is often something you'll do with a loop, adding one item to the dictionary per iteration.)","title":"building a dictionary one key-value pair at a time"},{"location":"recipes/core/collections/dicts/#building-a-dictionary-from-multiple-key-value-pairs-at-once","text":"dict1 = { 'mass': 9.11e-31, 'charge': -1.6e-19, 'spin': 1/2 } # a dictionary with 3 key-value pairs print(dict1) # yields {'mass': 9.11e-31, 'charge': -1.6e-19, 'spin': 0.5}","title":"building a dictionary from multiple key-value pairs at once"},{"location":"recipes/core/collections/dicts/#extracting-the-set-of-keys","text":"key_set = set(dict1.keys()) # the set of keys in dict1 print(key_set) # yields {'mass', 'charge', 'spin'}","title":"extracting the set of keys"},{"location":"recipes/core/collections/dicts/#extracting-the-keys-to-a-list","text":"key_list = list(dict1.keys()) # the keys in a list print(key_list) # yields ['mass', 'charge', 'spin']","title":"extracting the keys to a list"},{"location":"recipes/core/collections/dicts/#extracting-the-values-without-keys-to-a-list","text":"value_list = list(dict1.values()) # the values in a list print(value_list) # yields [9.11e-31, -1.6e-19, 0.5] average_value = mean(value_list) # the average of the values max_value = max(value_list) # the maximum value","title":"extracting the values (without keys) to a list"},{"location":"recipes/core/collections/dicts/#iterating-over-the-keys","text":"for key in dict1: print(key) # yields 'mass', 'charge', 'spin'","title":"iterating over the keys"},{"location":"recipes/core/collections/dicts/#iterating-over-the-values","text":"for value in dict1.values(): print(value) # yields 9.11e-31, -1.6e-19, 0.5","title":"iterating over the values"},{"location":"recipes/core/collections/dicts/#iterating-over-the-key-value-pairs","text":"for key, value in dict1.items(): print(f\"{key} = {value}\") # yields \"mass = 9.11e-31\", \"charge = -1.6e-19\", \"spin = 0.5\"","title":"iterating over the key-value pairs"},{"location":"recipes/core/collections/dicts/#checking-if-a-key-is-in-the-dictionary","text":"if 'mass' in dict1: print(\"`mass` is in the dictionary\") else: print(\"`mass` is NOT in the dictionary\")","title":"checking if a key is in the dictionary"},{"location":"recipes/core/collections/dicts/#finding-the-key-corresponding-to-the-maximum-or-minimum-value","text":"max_key = max(dict1, key=dict1.get) # the key corresponding to the maximum value max_val = dict1[max_key] # the maximum value min_key = min(dict1, key=dict1.get) # the key corresponding to the minimum value min_val = dict1[min_key] # the minimum value","title":"finding the key corresponding to the maximum or minimum value"},{"location":"recipes/core/collections/dicts/#getting-a-list-of-the-keys-sorted-according-to-their-values-in-ascending-order","text":"sorted_keys = sorted(dict1, key=dict1.get) # the keys sorted by their values You can then extract the associated values via dict1[key] for whatever key(s) you want. To get the keys in descending order of their values, include the optional reverse=True argument to the sorted() function. Dictionaries have many more features and utility methods, so make sure to read through the references linked above.","title":"getting a list of the keys sorted according to their values (in ascending order)"},{"location":"recipes/core/collections/iterate-pythonically/","text":"Iterate Pythonically Problem to Solve I want to accomplish various iteration-related tasks while keeping my code simple and easy. When iterating over the elements in a collection, it's easy to fall back on counter-based iteration like one would use in an old-fashioned language such as fortran, C, or java. Don't do that! Python has a different conceptualization of \"iteration\", and it's more powerful, convenient, and compact. Some situations do require the use of a counter variable and index-based collection access, but they're fairly rare. It's also worth remembering that many tasks that require iteration in lower-level languages can be done with a single function or method call in python. For example, to find the sum of the elements in a list, you can do sum(some_list) instead of adding them up one at a time via iteration. What follows is a few example recipes to illustrate the \"pythonic way\" to iterate over collections. A Few Recipes do something with every element of a tuple, list, or set for element in some_list_set_or_collection: # do something with element iterate over a sequence's elements in reverse order for element in reversed(some_sequence): # do something with element keep a counter variable while iterating Sometimes you do need to count the iterations as you iterate through a sequences. That does not mean you should reach for for i in range(...) and access the elements by index! Python provides the enumerate() function specifically for this: for i, element in enumerate(some_sequence): print(f\"Element number {i} is {element}.\") iterating over corresponding items of two (or more) sequences list_of_sums =[] for element1, element2 in zip(sequence1, sequence2): list_of_sums.append(element1 + element2) iterating over corresponding items of two (or more) sequences while keeping a counter for i, (x, y) in enumerate(zip(x_values, x_values)): print(f\"The coordinates of point {i} are ({x}, {y}).\") iterating over all combinations of elements from two sequences The old-school way: # Not very pythonic: for x in x_values: for y in y_values: print(f\"The coordinates of point ({x}, {y}).\") The pythonic way: from itertools import product for x, y in product(x_values, y_values): print(f\"The coordinates of point ({x}, {y}).\") It's only the same number of lines the first time you use it; after that, the import statement doesn't need to be repeated. And in general, the less nested your code is, the easier it is to comprehend. iterating over a sequence in multi-element chunks from itertools import batched for tuple_of_n_successive_elements in batched(some_sequence, n): # do something with each successive set of `n` elements Bonus Skill: Comprehensions For tasks that require a short, simple iterative loop to produce a new list, set, or dict, python provides a special syntax called a comprehension . Comprehensions are a compact way to express the same thing you would do with a loop, but in a single line of code. They are often more readable than the equivalent loop, and they can be faster too. Geeks for Geeks: List Comprehension in Python OpenStax Intro to Python Programming: List Comprehensions calculate values of a new list from corresponding elements of an old list old_list = [1.2, 3.4, 7.9, 12.4] # just an arbitrary example squares_of_old = [x**2 for x in old_list] roots_of_old = [math.sqrt(x) for x in old_list] roots_of_all = [math.sqrt(n) for n in range(1, 100)] filter a list to keep only some elements data = [random.uniform(-1, 1) for _ in range(10)] # just fake data positive_data = [x for x in data if x > 0] divisible_by_7 = [x for x in range(1, 100) if x % 7 == 0] calculate values of a new list from only some values in an old list data_sqrts_1 = [math.sqrt(x) for x in data if x > 0] # omit negative values data_sqrts_2 = [math.sqrt(x) if x > 0 else 0 for x in data] # replace negative values with 0 Comprehensions can also make sets, dictionaries, and a special kind of object called a generator , just by changing the syntax slightly. combine a keywords list and a values list into a dictionary keys = ['mass', 'charge', 'spin'] values = [9.11e-31, -1.6e-19, 1/2] dict1 = {key: val for key, val in zip(keys, values)} Note the curly-braces. List comprehensions use square brackets; set comprehensions use curly braces; and dict comprehensions use curly braces with a colon between the key and value.","title":"Iterate Pythonically"},{"location":"recipes/core/collections/iterate-pythonically/#iterate-pythonically","text":"","title":"Iterate Pythonically"},{"location":"recipes/core/collections/iterate-pythonically/#problem-to-solve","text":"I want to accomplish various iteration-related tasks while keeping my code simple and easy. When iterating over the elements in a collection, it's easy to fall back on counter-based iteration like one would use in an old-fashioned language such as fortran, C, or java. Don't do that! Python has a different conceptualization of \"iteration\", and it's more powerful, convenient, and compact. Some situations do require the use of a counter variable and index-based collection access, but they're fairly rare. It's also worth remembering that many tasks that require iteration in lower-level languages can be done with a single function or method call in python. For example, to find the sum of the elements in a list, you can do sum(some_list) instead of adding them up one at a time via iteration. What follows is a few example recipes to illustrate the \"pythonic way\" to iterate over collections.","title":"Problem to Solve"},{"location":"recipes/core/collections/iterate-pythonically/#a-few-recipes","text":"","title":"A Few Recipes"},{"location":"recipes/core/collections/iterate-pythonically/#do-something-with-every-element-of-a-tuple-list-or-set","text":"for element in some_list_set_or_collection: # do something with element","title":"do something with every element of a tuple, list, or set"},{"location":"recipes/core/collections/iterate-pythonically/#iterate-over-a-sequences-elements-in-reverse-order","text":"for element in reversed(some_sequence): # do something with element","title":"iterate over a sequence's elements in reverse order"},{"location":"recipes/core/collections/iterate-pythonically/#keep-a-counter-variable-while-iterating","text":"Sometimes you do need to count the iterations as you iterate through a sequences. That does not mean you should reach for for i in range(...) and access the elements by index! Python provides the enumerate() function specifically for this: for i, element in enumerate(some_sequence): print(f\"Element number {i} is {element}.\")","title":"keep a counter variable while iterating"},{"location":"recipes/core/collections/iterate-pythonically/#iterating-over-corresponding-items-of-two-or-more-sequences","text":"list_of_sums =[] for element1, element2 in zip(sequence1, sequence2): list_of_sums.append(element1 + element2)","title":"iterating over corresponding items of two (or more) sequences"},{"location":"recipes/core/collections/iterate-pythonically/#iterating-over-corresponding-items-of-two-or-more-sequences-while-keeping-a-counter","text":"for i, (x, y) in enumerate(zip(x_values, x_values)): print(f\"The coordinates of point {i} are ({x}, {y}).\")","title":"iterating over corresponding items of two (or more) sequences while keeping a counter"},{"location":"recipes/core/collections/iterate-pythonically/#iterating-over-all-combinations-of-elements-from-two-sequences","text":"The old-school way: # Not very pythonic: for x in x_values: for y in y_values: print(f\"The coordinates of point ({x}, {y}).\") The pythonic way: from itertools import product for x, y in product(x_values, y_values): print(f\"The coordinates of point ({x}, {y}).\") It's only the same number of lines the first time you use it; after that, the import statement doesn't need to be repeated. And in general, the less nested your code is, the easier it is to comprehend.","title":"iterating over all combinations of elements from two sequences"},{"location":"recipes/core/collections/iterate-pythonically/#iterating-over-a-sequence-in-multi-element-chunks","text":"from itertools import batched for tuple_of_n_successive_elements in batched(some_sequence, n): # do something with each successive set of `n` elements","title":"iterating over a sequence in multi-element chunks"},{"location":"recipes/core/collections/iterate-pythonically/#bonus-skill-comprehensions","text":"For tasks that require a short, simple iterative loop to produce a new list, set, or dict, python provides a special syntax called a comprehension . Comprehensions are a compact way to express the same thing you would do with a loop, but in a single line of code. They are often more readable than the equivalent loop, and they can be faster too. Geeks for Geeks: List Comprehension in Python OpenStax Intro to Python Programming: List Comprehensions","title":"Bonus Skill: Comprehensions"},{"location":"recipes/core/collections/iterate-pythonically/#calculate-values-of-a-new-list-from-corresponding-elements-of-an-old-list","text":"old_list = [1.2, 3.4, 7.9, 12.4] # just an arbitrary example squares_of_old = [x**2 for x in old_list] roots_of_old = [math.sqrt(x) for x in old_list] roots_of_all = [math.sqrt(n) for n in range(1, 100)]","title":"calculate values of a new list from corresponding elements of an old list"},{"location":"recipes/core/collections/iterate-pythonically/#filter-a-list-to-keep-only-some-elements","text":"data = [random.uniform(-1, 1) for _ in range(10)] # just fake data positive_data = [x for x in data if x > 0] divisible_by_7 = [x for x in range(1, 100) if x % 7 == 0]","title":"filter a list to keep only some elements"},{"location":"recipes/core/collections/iterate-pythonically/#calculate-values-of-a-new-list-from-only-some-values-in-an-old-list","text":"data_sqrts_1 = [math.sqrt(x) for x in data if x > 0] # omit negative values data_sqrts_2 = [math.sqrt(x) if x > 0 else 0 for x in data] # replace negative values with 0 Comprehensions can also make sets, dictionaries, and a special kind of object called a generator , just by changing the syntax slightly.","title":"calculate values of a new list from only some values in an old list"},{"location":"recipes/core/collections/iterate-pythonically/#combine-a-keywords-list-and-a-values-list-into-a-dictionary","text":"keys = ['mass', 'charge', 'spin'] values = [9.11e-31, -1.6e-19, 1/2] dict1 = {key: val for key, val in zip(keys, values)} Note the curly-braces. List comprehensions use square brackets; set comprehensions use curly braces; and dict comprehensions use curly braces with a colon between the key and value.","title":"combine a keywords list and a values list into a dictionary"},{"location":"recipes/core/collections/lists/","text":"Manage Sequences of Values with Lists Problem to Solve I want to build, modify, retrieve elements from, and iterate over a sequence of values. A list is basically just like a tuple, except that it can be modified in all kinds of ways after it has been created: Lists are mutable . You can add elements, remove elements, change the value of existing elements, and so on. You can do almost anything with a list that you can do with a tuple, so I won't repeat those recipes here. (Exception: The fact that tuples are immutable makes them hashable , which means that they can be used as keys in dictionaries and as elements of sets. That is occasionally useful.) Again, I'll point you to some online introductions: W3 Schools: Python Lists Geeks for Geeks: Python Lists A Few Recipes change the value of an existing list element list1 = [1, 2, 3, 4, 5] # a list of integers list1[2] = 99 # change the value at index 2 print(list1) # yields [1, 2, 99, 4, 5] append an element to a list list1 = [1, 2, 3, 4, 5] # a list of integers list1.append(6) # add 6 to the end of the list print(list1) # yields [1, 2, 3, 4, 5, 6] append multiple elements to a list list1 = [1, 2, 3, 4, 5] # a list of integers list1.extend([6, 7, 8]) # add 6, 7, and 8 to the end of the list print(list1) # yields [1, 2, 3, 4, 5, 6, 7, 8] Note that append() can only add one element at a time; to add multiple elements at once, use extend() . insert an element at a specific index list1 = [1, 2, 3, 4, 5] # a list of integers list1.insert(2, 99) # insert 99 at index 2 print(list1) # yields [1, 2, 99, 3, 4, 5] remove a specific value from a list list1 = [1, 2, 3, 4, 5] # a list of integers list1.remove(3) # remove the first occurrence of 3 print(list1) # yields [1, 2, 4, 5] remove an element at a specific index list1 = [1, 2, 3, 4, 5] # a list of integers list1.pop(2) # remove the element at index 2 print(list1) # yields [1, 2, 4, 5] The pop() method returns the value of the element its removing, so you can do something like this: list1 = [1, 2, 3, 4, 5] # a list of integers i = 2 print(f\"Removed {list1.pop(i)} from position {i} position in the list\") print(list1) # yields [1, 2, 4, 5] remove the last element from a list list1 = [1, 2, 3, 4, 5] # a list of integers list1.pop() # pop() with no argument means \"the last element\" print(list1) # yields [1, 2, 3, 4] remove all elements from a list list1 = [1, 2, 3, 4, 5] # a list of integers list1.clear() # remove all elements print(list1) # yields [] sort a list list1 = [5, 2, 4, 3, 1] # a list of integers list1.sort() # sort the list in place print(list1) # yields [1, 2, 3, 4, 5] sort a list in reverse order list1 = [5, 2, 4, 3, 1] # a list of integers list1.sort(reverse=True) # sort the list in place, in reverse order print(list1) # yields [5, 4, 3, 2, 1] build a list iteratively This is a very common idiom in computational physics: list1 = [] # an empty list for i in range(5): list1.append(i**2) # add the square of i to the list print(list1) # yields [0, 1, 4, 9, 16] create a list from a string list1 = list(\"abc\") # a list of characters print(list1) # yields ['a', 'b', 'c'] create a list from a range object list1 = list(range(5)) # a list of integers print(list1) # yields [0, 1, 2, 3, 4]","title":"Manage Sequences of Values with Lists"},{"location":"recipes/core/collections/lists/#manage-sequences-of-values-with-lists","text":"","title":"Manage Sequences of Values with Lists"},{"location":"recipes/core/collections/lists/#problem-to-solve","text":"I want to build, modify, retrieve elements from, and iterate over a sequence of values. A list is basically just like a tuple, except that it can be modified in all kinds of ways after it has been created: Lists are mutable . You can add elements, remove elements, change the value of existing elements, and so on. You can do almost anything with a list that you can do with a tuple, so I won't repeat those recipes here. (Exception: The fact that tuples are immutable makes them hashable , which means that they can be used as keys in dictionaries and as elements of sets. That is occasionally useful.) Again, I'll point you to some online introductions: W3 Schools: Python Lists Geeks for Geeks: Python Lists","title":"Problem to Solve"},{"location":"recipes/core/collections/lists/#a-few-recipes","text":"","title":"A Few Recipes"},{"location":"recipes/core/collections/lists/#change-the-value-of-an-existing-list-element","text":"list1 = [1, 2, 3, 4, 5] # a list of integers list1[2] = 99 # change the value at index 2 print(list1) # yields [1, 2, 99, 4, 5]","title":"change the value of an existing list element"},{"location":"recipes/core/collections/lists/#append-an-element-to-a-list","text":"list1 = [1, 2, 3, 4, 5] # a list of integers list1.append(6) # add 6 to the end of the list print(list1) # yields [1, 2, 3, 4, 5, 6]","title":"append an element to a list"},{"location":"recipes/core/collections/lists/#append-multiple-elements-to-a-list","text":"list1 = [1, 2, 3, 4, 5] # a list of integers list1.extend([6, 7, 8]) # add 6, 7, and 8 to the end of the list print(list1) # yields [1, 2, 3, 4, 5, 6, 7, 8] Note that append() can only add one element at a time; to add multiple elements at once, use extend() .","title":"append multiple elements to a list"},{"location":"recipes/core/collections/lists/#insert-an-element-at-a-specific-index","text":"list1 = [1, 2, 3, 4, 5] # a list of integers list1.insert(2, 99) # insert 99 at index 2 print(list1) # yields [1, 2, 99, 3, 4, 5]","title":"insert an element at a specific index"},{"location":"recipes/core/collections/lists/#remove-a-specific-value-from-a-list","text":"list1 = [1, 2, 3, 4, 5] # a list of integers list1.remove(3) # remove the first occurrence of 3 print(list1) # yields [1, 2, 4, 5]","title":"remove a specific value from a list"},{"location":"recipes/core/collections/lists/#remove-an-element-at-a-specific-index","text":"list1 = [1, 2, 3, 4, 5] # a list of integers list1.pop(2) # remove the element at index 2 print(list1) # yields [1, 2, 4, 5] The pop() method returns the value of the element its removing, so you can do something like this: list1 = [1, 2, 3, 4, 5] # a list of integers i = 2 print(f\"Removed {list1.pop(i)} from position {i} position in the list\") print(list1) # yields [1, 2, 4, 5]","title":"remove an element at a specific index"},{"location":"recipes/core/collections/lists/#remove-the-last-element-from-a-list","text":"list1 = [1, 2, 3, 4, 5] # a list of integers list1.pop() # pop() with no argument means \"the last element\" print(list1) # yields [1, 2, 3, 4]","title":"remove the last element from a list"},{"location":"recipes/core/collections/lists/#remove-all-elements-from-a-list","text":"list1 = [1, 2, 3, 4, 5] # a list of integers list1.clear() # remove all elements print(list1) # yields []","title":"remove all elements from a list"},{"location":"recipes/core/collections/lists/#sort-a-list","text":"list1 = [5, 2, 4, 3, 1] # a list of integers list1.sort() # sort the list in place print(list1) # yields [1, 2, 3, 4, 5]","title":"sort a list"},{"location":"recipes/core/collections/lists/#sort-a-list-in-reverse-order","text":"list1 = [5, 2, 4, 3, 1] # a list of integers list1.sort(reverse=True) # sort the list in place, in reverse order print(list1) # yields [5, 4, 3, 2, 1]","title":"sort a list in reverse order"},{"location":"recipes/core/collections/lists/#build-a-list-iteratively","text":"This is a very common idiom in computational physics: list1 = [] # an empty list for i in range(5): list1.append(i**2) # add the square of i to the list print(list1) # yields [0, 1, 4, 9, 16]","title":"build a list iteratively"},{"location":"recipes/core/collections/lists/#create-a-list-from-a-string","text":"list1 = list(\"abc\") # a list of characters print(list1) # yields ['a', 'b', 'c']","title":"create a list from a string"},{"location":"recipes/core/collections/lists/#create-a-list-from-a-range-object","text":"list1 = list(range(5)) # a list of integers print(list1) # yields [0, 1, 2, 3, 4]","title":"create a list from a range object"},{"location":"recipes/core/collections/sets/","text":"Identify Unique & Shared Elements with Sets Problem to Solve I want to keep track of a collection of unique values and perhaps compare the values present in different such collections. A python set is a collection of elements whose properties are analogous to the mathematical concept of a set. The key differences between a set and a list are: A set is a collection of unique elements, so it cannot contain duplicates. A set is unordered, so the order of elements is not guaranteed, and you cannot access its elements by index. A set is mutable, but it cannot contain mutable elements (e.g., lists or dictionaries). Set objects support several operations that are specific to set logic (union, intersection, etc.) Some online introductions: W3 Schools: Python Sets Geeks for Geeks: Python Sets A Few Recipes determining the number of elements in a set set1 = {1, 2, 3, 4, 5} # a set of integers len(set1) # yields 5 finding the intersection of two sets set1 = {1, 2, 3, 4, 5} # a set of integers set2 = {3, 4, 5, 6, 7} # another set of integers set3 = set1.intersection(set2) # the intersection of set1 and set2 print(set3) # yields {3, 4, 5} finding the union of two sets set1 = {1, 2, 3, 4, 5} # a set of integers set2 = {3, 4, 5, 6, 7} # another set of integers set3 = set1.union(set2) # the union of set1 and set2 print(set3) # yields {1, 2, 3, 4, 5, 6, 7} finding the elements in one set that aren't also in a second set set1 = {1, 2, 3, 4, 5} # a set of integers set2 = {3, 4, 5, 6, 7} # another set of integers set3 = set1.difference(set2) # the difference of set1 and set2 print(set3) # yields {1, 2} finding the elements in either set that aren't in both sets set1 = {1, 2, 3, 4, 5} # a set of integers set2 = {3, 4, 5, 6, 7} # another set of integers set3 = set1.symmetric_difference(set2) # the symmetric difference of set1 and set2 print(set3) # yields {1, 2, 6, 7} removing duplicate elements from a list This is a useful trick! list1 = [1, 4, 3, 4, 2, 1, 5, 1, 6, 4] # a list of integers list2 = list(set(list1)) # convert the list to a set and back to a list print(list2) # yields [1, 2, 3, 4, 5, 6] -- order is not guaranteed!","title":"Identify Unique &amp; Shared Elements with Sets"},{"location":"recipes/core/collections/sets/#identify-unique-shared-elements-with-sets","text":"","title":"Identify Unique &amp; Shared Elements with Sets"},{"location":"recipes/core/collections/sets/#problem-to-solve","text":"I want to keep track of a collection of unique values and perhaps compare the values present in different such collections. A python set is a collection of elements whose properties are analogous to the mathematical concept of a set. The key differences between a set and a list are: A set is a collection of unique elements, so it cannot contain duplicates. A set is unordered, so the order of elements is not guaranteed, and you cannot access its elements by index. A set is mutable, but it cannot contain mutable elements (e.g., lists or dictionaries). Set objects support several operations that are specific to set logic (union, intersection, etc.) Some online introductions: W3 Schools: Python Sets Geeks for Geeks: Python Sets","title":"Problem to Solve"},{"location":"recipes/core/collections/sets/#a-few-recipes","text":"","title":"A Few Recipes"},{"location":"recipes/core/collections/sets/#determining-the-number-of-elements-in-a-set","text":"set1 = {1, 2, 3, 4, 5} # a set of integers len(set1) # yields 5","title":"determining the number of elements in a set"},{"location":"recipes/core/collections/sets/#finding-the-intersection-of-two-sets","text":"set1 = {1, 2, 3, 4, 5} # a set of integers set2 = {3, 4, 5, 6, 7} # another set of integers set3 = set1.intersection(set2) # the intersection of set1 and set2 print(set3) # yields {3, 4, 5}","title":"finding the intersection of two sets"},{"location":"recipes/core/collections/sets/#finding-the-union-of-two-sets","text":"set1 = {1, 2, 3, 4, 5} # a set of integers set2 = {3, 4, 5, 6, 7} # another set of integers set3 = set1.union(set2) # the union of set1 and set2 print(set3) # yields {1, 2, 3, 4, 5, 6, 7}","title":"finding the union of two sets"},{"location":"recipes/core/collections/sets/#finding-the-elements-in-one-set-that-arent-also-in-a-second-set","text":"set1 = {1, 2, 3, 4, 5} # a set of integers set2 = {3, 4, 5, 6, 7} # another set of integers set3 = set1.difference(set2) # the difference of set1 and set2 print(set3) # yields {1, 2}","title":"finding the elements in one set that aren't also in a second set"},{"location":"recipes/core/collections/sets/#finding-the-elements-in-either-set-that-arent-in-both-sets","text":"set1 = {1, 2, 3, 4, 5} # a set of integers set2 = {3, 4, 5, 6, 7} # another set of integers set3 = set1.symmetric_difference(set2) # the symmetric difference of set1 and set2 print(set3) # yields {1, 2, 6, 7}","title":"finding the elements in either set that aren't in both sets"},{"location":"recipes/core/collections/sets/#removing-duplicate-elements-from-a-list","text":"This is a useful trick! list1 = [1, 4, 3, 4, 2, 1, 5, 1, 6, 4] # a list of integers list2 = list(set(list1)) # convert the list to a set and back to a list print(list2) # yields [1, 2, 3, 4, 5, 6] -- order is not guaranteed!","title":"removing duplicate elements from a list"},{"location":"recipes/core/collections/tuples/","text":"Group Related Values Into Tuples Problem to Solve I want to collect a few values together into a group that I can treat as one \"thing\", and that won\u2019t need to change. In python, a tuple is an ordered collection of items. Unlike a list a tuple cannot be modified after it has been created: we say that tuples are immutable . Rather than reinvent the wheel, I'll direct you to some on line introductions to tuples: W3 Schools: Python Tuples Geeks for Geeks: Tuples in Python A Few Recipes In all of these, we'll use the variable names t , t1 , t2 , etc. to refer to tuples. create a tuple explicitly t1 = (1, 2, 3, 4, 5) # a tuple of 5 integers (a \"five-tuple\") t2 = 1, 2, 3, 4, 5 # parentheses can be omitted IF the result is unambiguous t3 = ('electron', 'muon', 'tau') # a three-tuple of strings t4 = ((1, 2), (11, 12), (21, 22)) # a 3-tuple of 2-tuples t5 = (22/7, math.pi, math.sqrt(2)) # elements can be the result of expressions create a tuple from a different collection type list1 = [1, 2, 3, 4, 5] # a list of integers t1 = tuple(list1) # from a list t2 = tuple('abc') # from a string: yields ('a', 'b', 'c') t3 = tuple(range(5)) # from a range object: yields (0, 1, 2, 3, 4) create an empty or one-element tuple t1 = () # an empty tuple t2 = tuple() # another empty tuple t3 = (3-2j,) # a one-element tuple (note the comma) t4 = tuple([22/7]) # another one-element tuple determine the length of a tuple t1 = (3, -2, 14, 7, 0) # a 5-tuple len(t1) # yields 5 access individual elements of a tuple t1 = (3, -2, 14, 7, 0) # a 5-tuple t1[0] # yields 3 t1[1] # yields -2 t1[-1] # yields 0 (the last element) t1[-2] # yields 7 (the second-to-last element) change the value of a tuple \u2014 NOPE! t1 = (5, 12, 13) # a 3-tuple t1[1] = -12 # TypeError: tuples are immutable! t1 = (t1[0], -12, t1[2]) # must create a new tuple with the new value(s) concatenate two tuples t1 = (1, 2, 3) # a 3-tuple t2 = (4, 5, 6) # another 3-tuple t3 = t1 + t2 # yields (1, 2, 3, 4, 5, 6) create a repeating tuple If you, for some reason, want to create a tuple with the same value repeated multiple times, you can do it like this: t1 = (1, 2, 3) # a 3-tuple t2 = t1 * 3 # yields (1, 2, 3, 1, 2, 3, 1, 2, 3) The original tuple that gets repeated could have only one element, or two, or 17 as you wish. nest tuples t1 = (1, 2, 3) # a 3-tuple t2 = (4, 5, 6) # another 3-tuple t3 = (t1, t2) # a 2-tuple of 3-tuples t4 = ((1, 2), (11, 12), (21, 22)) # a 3-tuple of 2-tuples access elements of a tuple one at a time for one_value in t1: print(one_value) # or do anything else with the value","title":"Group Related Values Into Tuples"},{"location":"recipes/core/collections/tuples/#group-related-values-into-tuples","text":"","title":"Group Related Values Into Tuples"},{"location":"recipes/core/collections/tuples/#problem-to-solve","text":"I want to collect a few values together into a group that I can treat as one \"thing\", and that won\u2019t need to change. In python, a tuple is an ordered collection of items. Unlike a list a tuple cannot be modified after it has been created: we say that tuples are immutable . Rather than reinvent the wheel, I'll direct you to some on line introductions to tuples: W3 Schools: Python Tuples Geeks for Geeks: Tuples in Python","title":"Problem to Solve"},{"location":"recipes/core/collections/tuples/#a-few-recipes","text":"In all of these, we'll use the variable names t , t1 , t2 , etc. to refer to tuples.","title":"A Few Recipes"},{"location":"recipes/core/collections/tuples/#create-a-tuple-explicitly","text":"t1 = (1, 2, 3, 4, 5) # a tuple of 5 integers (a \"five-tuple\") t2 = 1, 2, 3, 4, 5 # parentheses can be omitted IF the result is unambiguous t3 = ('electron', 'muon', 'tau') # a three-tuple of strings t4 = ((1, 2), (11, 12), (21, 22)) # a 3-tuple of 2-tuples t5 = (22/7, math.pi, math.sqrt(2)) # elements can be the result of expressions","title":"create a tuple explicitly"},{"location":"recipes/core/collections/tuples/#create-a-tuple-from-a-different-collection-type","text":"list1 = [1, 2, 3, 4, 5] # a list of integers t1 = tuple(list1) # from a list t2 = tuple('abc') # from a string: yields ('a', 'b', 'c') t3 = tuple(range(5)) # from a range object: yields (0, 1, 2, 3, 4)","title":"create a tuple from a different collection type"},{"location":"recipes/core/collections/tuples/#create-an-empty-or-one-element-tuple","text":"t1 = () # an empty tuple t2 = tuple() # another empty tuple t3 = (3-2j,) # a one-element tuple (note the comma) t4 = tuple([22/7]) # another one-element tuple","title":"create an empty or one-element tuple"},{"location":"recipes/core/collections/tuples/#determine-the-length-of-a-tuple","text":"t1 = (3, -2, 14, 7, 0) # a 5-tuple len(t1) # yields 5","title":"determine the length of a tuple"},{"location":"recipes/core/collections/tuples/#access-individual-elements-of-a-tuple","text":"t1 = (3, -2, 14, 7, 0) # a 5-tuple t1[0] # yields 3 t1[1] # yields -2 t1[-1] # yields 0 (the last element) t1[-2] # yields 7 (the second-to-last element)","title":"access individual elements of a tuple"},{"location":"recipes/core/collections/tuples/#change-the-value-of-a-tuple-nope","text":"t1 = (5, 12, 13) # a 3-tuple t1[1] = -12 # TypeError: tuples are immutable! t1 = (t1[0], -12, t1[2]) # must create a new tuple with the new value(s)","title":"change the value of a tuple \u2014 NOPE!"},{"location":"recipes/core/collections/tuples/#concatenate-two-tuples","text":"t1 = (1, 2, 3) # a 3-tuple t2 = (4, 5, 6) # another 3-tuple t3 = t1 + t2 # yields (1, 2, 3, 4, 5, 6)","title":"concatenate two tuples"},{"location":"recipes/core/collections/tuples/#create-a-repeating-tuple","text":"If you, for some reason, want to create a tuple with the same value repeated multiple times, you can do it like this: t1 = (1, 2, 3) # a 3-tuple t2 = t1 * 3 # yields (1, 2, 3, 1, 2, 3, 1, 2, 3) The original tuple that gets repeated could have only one element, or two, or 17 as you wish.","title":"create a repeating tuple"},{"location":"recipes/core/collections/tuples/#nest-tuples","text":"t1 = (1, 2, 3) # a 3-tuple t2 = (4, 5, 6) # another 3-tuple t3 = (t1, t2) # a 2-tuple of 3-tuples t4 = ((1, 2), (11, 12), (21, 22)) # a 3-tuple of 2-tuples","title":"nest tuples"},{"location":"recipes/core/collections/tuples/#access-elements-of-a-tuple-one-at-a-time","text":"for one_value in t1: print(one_value) # or do anything else with the value","title":"access elements of a tuple one at a time"},{"location":"recipes/core/functions/","text":"Function Recipes Recipes for writing and using your own functions: Write Your Own Function : I want to easily reuse a particular calculation multiple times, with different givens. Make Arguments Optional : I want my code to decide what to do based on the circumstances. Execute Conditionally : I want my code to decide what to do based on the circumstances. Safety-Check Arguments : I want to make my function robust against incorrect or unexpected arguments. Factor Out Subfunctions : I want to break a complicated calculation into pieces to keep it manageable. Use Global Variables (Sparingly!) : I need to get values deep into a function or subfunction, and passing them via arguments is tedious. Run or Import From a Script : I want to write a script that I can run, and I also want to use functions it defines in the console or other scripts.","title":"(Recipe List)"},{"location":"recipes/core/functions/#function-recipes","text":"Recipes for writing and using your own functions: Write Your Own Function : I want to easily reuse a particular calculation multiple times, with different givens. Make Arguments Optional : I want my code to decide what to do based on the circumstances. Execute Conditionally : I want my code to decide what to do based on the circumstances. Safety-Check Arguments : I want to make my function robust against incorrect or unexpected arguments. Factor Out Subfunctions : I want to break a complicated calculation into pieces to keep it manageable. Use Global Variables (Sparingly!) : I need to get values deep into a function or subfunction, and passing them via arguments is tedious. Run or Import From a Script : I want to write a script that I can run, and I also want to use functions it defines in the console or other scripts.","title":"Function Recipes"},{"location":"recipes/core/functions/conditionals/","text":"Execute Code Conditionally Problem to Solve I want my code to decide what to do based on the circumstances. Recipe This recipe isn't specifically about writing functions \u2014 the topic of this level \u2014 but I'm including it here because it's very common for functions to include conditional logic. Execute or Not, Depending Let's say you've got a chunk of code (maybe one line, maybe several) that your program should execute under certain circumstances, but skip over under others. The solution is to wrap that chunk in an if block: if boolean_expression: # Code to execute if condition is True. # Can be multiple lines # Code to execute regardless... Replace boolean_expression with any expression that evaluates to either True or False . That could be: - a boolean variable whose value was set to True or False earlier in the program; - a comparison using one of python's comparison operators , like x < y , r >= 1 , or s == \"hello\" ; - a call to a function that returns a boolean value, such as isinstance(x, int) or email_address.endswith(\".com\") ; or - a combination of the above, using the logical operators and , or , and not . (By the way, a convenient shorthand for if x > a and x < b: is if a < x < b: .) Indentation is what distinguishes the body of the if block \u2014 the lines that will execute or not depending on the value of boolean_expression \u2014 from subsequent code that will execute either way. (The blank line I inserted just to improve human readability; the python interpreter doesn't care.) A warning about a common error: If you define a variable for the first time inside an if block, later code can't safely assume that variable will have been defined. You could get an error like NameError: name 'xxx' is not defined that doesn't show up until the first time your code is run with conditions that make boolean_expression evaluate to False . One common solution is to define the variable before the if statement, giving it some appropriate default value (which depends on the circumstances): zero, or an empty string, or whatever. Then, the code inside the if block can change the value of the variable if necessary, and later code can safely assume the variable has been defined. Execute One Chunk Or Another An alternate case is that you might want your code to execute one chunk of code if some condition holds, and a different chunk if it doesn't. That's what the optional else clause of the if statement is for: if boolean_expression: # Code to execute if condition is True. # Can be multiple lines else: # Code to execute if condition is False. # Can be multiple lines, too. # Code to execute regardless... Because one block or the other will necessarily execute, you can safely define a variable inside this if construct as long as you define it in both branches. Execute One Of Several Chunks You can also choose between more than two possible chunks of code to execute, but you'll need more than one boolean expression to do so. Here's a three-chunk version: if boolean_expression_1: # Code to execute if condition 1 is True. elif boolean_expression_2: # Code to execute if condition 1 is False and condition 2 is True. else: # Code to execute if both condition 1 and condition 2 are False. Note that if boolean_expression_1 evaluates to True , the value of boolean_expression_2 is totally irrelevant. You can have arbitrarily many elif clauses, but only one else clause, and the else clause must come last. If you have more than one elif clause, the interpreter will evaluate them in order, from top to bottom, and execute the first block of code whose condition is True . if boolean_expression_1: # Code to execute if condition 1 is True. elif boolean_expression_2: # Code to execute if condition 1 is False and condition 2 is True. elif boolean_expression_3: # Code to execute if conditions 1 and 2 are False and condition 3 is True. else: # Code to execute if all conditions are False. Consider Two Criteria Simultaneously If your code needs to take different actions depending upon both of two conditions, you've got a couple of possible approaches. The most complex case is one where you have four different possible outcomes, depending on whether each of the two conditions is True or False . Here's one approach: if boolean_expression_1 and boolean_expression_2: # Code to execute if both conditions are True. elif boolean_expression_1: # Code to execute if condition 1 is True and condition 2 is False. elif boolean_expression_2: # Code to execute if condition 1 is False and condition 2 is True. else: # Code to execute if both conditions are False. Here's a different approach, using nested if statements: if boolean_expression_1: if boolean_expression_2: # Code to execute if both conditions are True. else: # Code to execute if condition 1 is True and condition 2 is False. else: if boolean_expression_2: # Code to execute if condition 1 is False and condition 2 is True. else: # Code to execute if both conditions are False. I think the first is easier to read, but YMMV. On the other hand, the second approach lets you use a different second criterion depending on the value of the first: if boolean_expression_1: if boolean_expression_2a: # Code to execute if conditions 1 and 2a are True. else: # Code to execute if condition 1 is True and condition 2a is False. else: if boolean_expression_2b: # Code to execute if condition 1 is False and condition 2b is True. else: # Code to execute if both conditions are False. Be very careful about any kind of complex, nested conditional logic. It's very easy to write code that you think will act the way you want, but that behaves differently under some rare circumstances that fall through a hole in your logic. Even screwing up the indentation of an else can change your code's behavior. Try hard to find the simplest, \"flattest\", most linear solution you can. Examples Here's a simple example of an if block in action. (I've hard-coded the parameters V_0 and L to keep the example uncluttered.) def V(x): \"\"\" Represents the potential energy function V(x) of a quantum particle in a finite square well of depth `V_0` and width `L` centered on the origin. \"\"\" V_0 = 13.2 # eV: the L = 1.0e-9 # meters if abs(x) < L/2: V = -V_0 else: V = 0 return V (Imagine what a plot of V(x) vs. x would look like.) Of course, one can simplify this code by taking advantage of the fact that encountering a return statement immediately exits the function: def V(x): \"\"\" Represents the potential energy function V(x) of a quantum particle in a finite square well of depth `V0` and width `L` centered on the origin.= \"\"\" V_0 = 13.2 # eV: the L = 1.0e-9 # meters if abs(x) < L/2: return -V_0 return 0 Here's a function that describes velocity vs. time for a vehicle that sits at rest until \\(t = 0\\) , then accelerates at \\(2.5\\text{ m/s}^2\\) for ten seconds, and then coasts at constant speed for 15 seconds, and then slows down at \\(-1.0\\text{ m/s}^2\\) until it comes to a stop: def vehicle_velocity(t): \"\"\" Describes velocity vs. time, v(t), for a vehicle that sits at rest until $t = 0$, then accelerates at $2.5\\text{ m/s}^2$ for ten seconds, and then coasts at constant speed for 15 seconds, and then slows down at $-1.0\\text{ m/s}^2$ until it comes to a stop. Parameters: - t (float): a time in seconds. Returns: the velocity in m/s. \"\"\" if 0 <= t <= 10: # During acceleration phase: v = 0 + (2.5 m/s^2) * t return 2.5 * t elif 10 < t <= 25: # During coasting phase: constant velocity from the end of # the acceleration phase, vd = 2.5 m/s^2 * 10 s = 25 m/s return 25.0 elif 25 < t <= 40: # During deceleration phase: v = 25 m/s - (1.0 m/s^2) * (t - 25) return 25.0 - 1.0 * (t - 25) else: # t < 0 or t > 40 return 0.0 Bonus Tidbit: The Ternary Operator You can totally ignore this if you want, but for the curious: python has a \"ternary operator\" that can implement a simple if/else construct in one line. It only works when each clause is a single expression, and where the construct's objective is to return one of two values (rather than, say, doing something else like printing). Here's the template: variable_to_set = value_if_true if boolean_expression else value_if_false Here's the first example above, the potential energy function, rewritten with a single line of body code using construct: def V(x, V_0=13.2, L=1.0e09): \"\"\" Represents the potential energy function V(x) of a quantum particle in a finite square well of depth `V0` and width `L` centered on the origin. \"\"\" return -V_0 if abs(x) < L/2 else 0 Don't overuse it! Code readability can suffer. It's best when the first value is usually the value chosen, but sometimes the second is needed under rare circumstances.","title":"Execute Code Conditionally"},{"location":"recipes/core/functions/conditionals/#execute-code-conditionally","text":"","title":"Execute Code Conditionally"},{"location":"recipes/core/functions/conditionals/#problem-to-solve","text":"I want my code to decide what to do based on the circumstances.","title":"Problem to Solve"},{"location":"recipes/core/functions/conditionals/#recipe","text":"This recipe isn't specifically about writing functions \u2014 the topic of this level \u2014 but I'm including it here because it's very common for functions to include conditional logic.","title":"Recipe"},{"location":"recipes/core/functions/conditionals/#execute-or-not-depending","text":"Let's say you've got a chunk of code (maybe one line, maybe several) that your program should execute under certain circumstances, but skip over under others. The solution is to wrap that chunk in an if block: if boolean_expression: # Code to execute if condition is True. # Can be multiple lines # Code to execute regardless... Replace boolean_expression with any expression that evaluates to either True or False . That could be: - a boolean variable whose value was set to True or False earlier in the program; - a comparison using one of python's comparison operators , like x < y , r >= 1 , or s == \"hello\" ; - a call to a function that returns a boolean value, such as isinstance(x, int) or email_address.endswith(\".com\") ; or - a combination of the above, using the logical operators and , or , and not . (By the way, a convenient shorthand for if x > a and x < b: is if a < x < b: .) Indentation is what distinguishes the body of the if block \u2014 the lines that will execute or not depending on the value of boolean_expression \u2014 from subsequent code that will execute either way. (The blank line I inserted just to improve human readability; the python interpreter doesn't care.) A warning about a common error: If you define a variable for the first time inside an if block, later code can't safely assume that variable will have been defined. You could get an error like NameError: name 'xxx' is not defined that doesn't show up until the first time your code is run with conditions that make boolean_expression evaluate to False . One common solution is to define the variable before the if statement, giving it some appropriate default value (which depends on the circumstances): zero, or an empty string, or whatever. Then, the code inside the if block can change the value of the variable if necessary, and later code can safely assume the variable has been defined.","title":"Execute or Not, Depending"},{"location":"recipes/core/functions/conditionals/#execute-one-chunk-or-another","text":"An alternate case is that you might want your code to execute one chunk of code if some condition holds, and a different chunk if it doesn't. That's what the optional else clause of the if statement is for: if boolean_expression: # Code to execute if condition is True. # Can be multiple lines else: # Code to execute if condition is False. # Can be multiple lines, too. # Code to execute regardless... Because one block or the other will necessarily execute, you can safely define a variable inside this if construct as long as you define it in both branches.","title":"Execute One Chunk Or Another"},{"location":"recipes/core/functions/conditionals/#execute-one-of-several-chunks","text":"You can also choose between more than two possible chunks of code to execute, but you'll need more than one boolean expression to do so. Here's a three-chunk version: if boolean_expression_1: # Code to execute if condition 1 is True. elif boolean_expression_2: # Code to execute if condition 1 is False and condition 2 is True. else: # Code to execute if both condition 1 and condition 2 are False. Note that if boolean_expression_1 evaluates to True , the value of boolean_expression_2 is totally irrelevant. You can have arbitrarily many elif clauses, but only one else clause, and the else clause must come last. If you have more than one elif clause, the interpreter will evaluate them in order, from top to bottom, and execute the first block of code whose condition is True . if boolean_expression_1: # Code to execute if condition 1 is True. elif boolean_expression_2: # Code to execute if condition 1 is False and condition 2 is True. elif boolean_expression_3: # Code to execute if conditions 1 and 2 are False and condition 3 is True. else: # Code to execute if all conditions are False.","title":"Execute One Of Several Chunks"},{"location":"recipes/core/functions/conditionals/#consider-two-criteria-simultaneously","text":"If your code needs to take different actions depending upon both of two conditions, you've got a couple of possible approaches. The most complex case is one where you have four different possible outcomes, depending on whether each of the two conditions is True or False . Here's one approach: if boolean_expression_1 and boolean_expression_2: # Code to execute if both conditions are True. elif boolean_expression_1: # Code to execute if condition 1 is True and condition 2 is False. elif boolean_expression_2: # Code to execute if condition 1 is False and condition 2 is True. else: # Code to execute if both conditions are False. Here's a different approach, using nested if statements: if boolean_expression_1: if boolean_expression_2: # Code to execute if both conditions are True. else: # Code to execute if condition 1 is True and condition 2 is False. else: if boolean_expression_2: # Code to execute if condition 1 is False and condition 2 is True. else: # Code to execute if both conditions are False. I think the first is easier to read, but YMMV. On the other hand, the second approach lets you use a different second criterion depending on the value of the first: if boolean_expression_1: if boolean_expression_2a: # Code to execute if conditions 1 and 2a are True. else: # Code to execute if condition 1 is True and condition 2a is False. else: if boolean_expression_2b: # Code to execute if condition 1 is False and condition 2b is True. else: # Code to execute if both conditions are False. Be very careful about any kind of complex, nested conditional logic. It's very easy to write code that you think will act the way you want, but that behaves differently under some rare circumstances that fall through a hole in your logic. Even screwing up the indentation of an else can change your code's behavior. Try hard to find the simplest, \"flattest\", most linear solution you can.","title":"Consider Two Criteria Simultaneously"},{"location":"recipes/core/functions/conditionals/#examples","text":"Here's a simple example of an if block in action. (I've hard-coded the parameters V_0 and L to keep the example uncluttered.) def V(x): \"\"\" Represents the potential energy function V(x) of a quantum particle in a finite square well of depth `V_0` and width `L` centered on the origin. \"\"\" V_0 = 13.2 # eV: the L = 1.0e-9 # meters if abs(x) < L/2: V = -V_0 else: V = 0 return V (Imagine what a plot of V(x) vs. x would look like.) Of course, one can simplify this code by taking advantage of the fact that encountering a return statement immediately exits the function: def V(x): \"\"\" Represents the potential energy function V(x) of a quantum particle in a finite square well of depth `V0` and width `L` centered on the origin.= \"\"\" V_0 = 13.2 # eV: the L = 1.0e-9 # meters if abs(x) < L/2: return -V_0 return 0 Here's a function that describes velocity vs. time for a vehicle that sits at rest until \\(t = 0\\) , then accelerates at \\(2.5\\text{ m/s}^2\\) for ten seconds, and then coasts at constant speed for 15 seconds, and then slows down at \\(-1.0\\text{ m/s}^2\\) until it comes to a stop: def vehicle_velocity(t): \"\"\" Describes velocity vs. time, v(t), for a vehicle that sits at rest until $t = 0$, then accelerates at $2.5\\text{ m/s}^2$ for ten seconds, and then coasts at constant speed for 15 seconds, and then slows down at $-1.0\\text{ m/s}^2$ until it comes to a stop. Parameters: - t (float): a time in seconds. Returns: the velocity in m/s. \"\"\" if 0 <= t <= 10: # During acceleration phase: v = 0 + (2.5 m/s^2) * t return 2.5 * t elif 10 < t <= 25: # During coasting phase: constant velocity from the end of # the acceleration phase, vd = 2.5 m/s^2 * 10 s = 25 m/s return 25.0 elif 25 < t <= 40: # During deceleration phase: v = 25 m/s - (1.0 m/s^2) * (t - 25) return 25.0 - 1.0 * (t - 25) else: # t < 0 or t > 40 return 0.0","title":"Examples"},{"location":"recipes/core/functions/conditionals/#bonus-tidbit-the-ternary-operator","text":"You can totally ignore this if you want, but for the curious: python has a \"ternary operator\" that can implement a simple if/else construct in one line. It only works when each clause is a single expression, and where the construct's objective is to return one of two values (rather than, say, doing something else like printing). Here's the template: variable_to_set = value_if_true if boolean_expression else value_if_false Here's the first example above, the potential energy function, rewritten with a single line of body code using construct: def V(x, V_0=13.2, L=1.0e09): \"\"\" Represents the potential energy function V(x) of a quantum particle in a finite square well of depth `V0` and width `L` centered on the origin. \"\"\" return -V_0 if abs(x) < L/2 else 0 Don't overuse it! Code readability can suffer. It's best when the first value is usually the value chosen, but sometimes the second is needed under rare circumstances.","title":"Bonus Tidbit: The Ternary Operator"},{"location":"recipes/core/functions/factoring/","text":"Factor Out Subfunctions Problem to Solve I want to break a complicated calculation into pieces to keep it manageable. You will find, as you write more complicated code \u2014 multi-step calculations, multi-body physics simulations, etc. \u2014 that most of the work is done inside functions you define. For example, in a Visual Python simulation of interacting objects, you may have a function update_scene() whose job is to move all the 3D objects to new locations. That function will have to calculate all the interaction and constraint forces, determine the resulting accelerations of all the objects, determine how their velocities and positions change, and then give the commands to actually modify the scene. If you try to put all the code for this into the one function, it will become painfully long and hard to work with. The smart approach is to factor it into multiple small, mostly-independent calculations, and to put each one in its own function. Functionality that is factored out of one function and put into another is called a subfunction . Recipe Here's the general pattern: def subfunction_1(arg1, ...): \"\"\" Encapsulates one bit of functionality. \"\"\" result = ... # Calculate something using one or more lines of code return result def subfunction_2(arg1, arg2, ...): \"\"\" Encapsulates a different bit of functionality. \"\"\" other_result = ... # Calculate something using one or more lines of code return other_result def main_function(arg_A, arg_B, ...): \"\"\" Does something complicated. \"\"\" x = ... # Calculation z = subfunction_1(x, arg_B, ...) q = subfunction_2(z, ...) end_result = ... # Calculation return end_result Hopefully it's obvious that you can give the functions, arguments, and variables any names that reflect their actual purposes and meanings. It's entirely possible to call the same subfunction multiple times from the same main function, or even from different other functions. (A function can even call itself\u2026 That's called recursion , and can be a powerful technique, but be careful that it doesn't go on forever.) When should you factor code into a subfunction? That's a judgment call. When considering whether to factor a particular chunk of code into a subfunction, ask yourself: Is this chunk of code doing something with one purpose, which could be described as the purpose of the possible subfunction? Is this chunk of code connected to the surrounding code fairly loosely, so that all it would need are a few input arguments and a return value or two? Or does it use and/or change multiple variables from the code around it in ways that are hard to cleanly factor? Is it long enough to be worth factoring? Overall, would moving this bit out make the code easier or harder to understand and debug? Sometimes it's worth putting a single line of code into a subfunction, if the line is nontrivial and doing so improves code readability. The ability to give that chunk a descriptive name (it's function name) can, all by itself, significantly aid readability. BTW, one very significant advantage of factoring code into subfunctions is that you can test the subfunctions individually to make sure they work correctly. Finding a head-scratcher of a bug is much easier if you've narrowed it down to somewhere in a five-line function than if it's somewhere in a 40-line function. Example Let's say we need to calculate the total electrostatic potential energy stored in an arrangement of three charged point particles. Doing that requires summing the three pairwise potential energies, so calculating the potential energy of a pair is a sensible subfunction. Also, doing each pair calculation requires finding a distance, which could be done inline, but could also be factored out for clarity. from math import sqrt def distance(x1, y1, z1, x2, y2, z2): \"\"\" Returns the distance between two points in 3D. \"\"\" return sqrt((x1-x2)**2 + (y1-y2)**2 + (z1-z2)**2) def two_body_potential(q1, x1, y1, z1, q2, x2, y2, z2): \"\"\" Returns the potential energy of two point charges, in SI units. \"\"\" k = 8.9875517873681764e9 # N m\u00b2 C\u207b\u00b2 r = distance(x1, y1, z1, x2, y2, z2) return k * q1 * q2 / r def three_body potential(q1, x1, y1, z1, q2, x2, y2, z2, q3, x3, y3, z3): \"\"\" Returns the total potential energy of three point charges, in SI units. \"\"\" return (two_body_potential(q1, x1, y1, z1, q2, x2, y2, z2) + two_body_potential(q1, x1, y1, z1, q3, x3, y3, z3) + two_body_potential(q2, x2, y2, z2, q3, x3, y3, z3)) Side note: The most awkward part of all this is passing around four arguments for every particle. I wouldn't actually do this; instead, I'd pack them together into tuples or lists or \u2014 getting fancy \u2014 something called a named tuple . We'll be covering tuples and lists in Level A-05. After doing that, if you want to teach yourself about named tuples, be my guest!","title":"Factor Out Subfunctions"},{"location":"recipes/core/functions/factoring/#factor-out-subfunctions","text":"","title":"Factor Out Subfunctions"},{"location":"recipes/core/functions/factoring/#problem-to-solve","text":"I want to break a complicated calculation into pieces to keep it manageable. You will find, as you write more complicated code \u2014 multi-step calculations, multi-body physics simulations, etc. \u2014 that most of the work is done inside functions you define. For example, in a Visual Python simulation of interacting objects, you may have a function update_scene() whose job is to move all the 3D objects to new locations. That function will have to calculate all the interaction and constraint forces, determine the resulting accelerations of all the objects, determine how their velocities and positions change, and then give the commands to actually modify the scene. If you try to put all the code for this into the one function, it will become painfully long and hard to work with. The smart approach is to factor it into multiple small, mostly-independent calculations, and to put each one in its own function. Functionality that is factored out of one function and put into another is called a subfunction .","title":"Problem to Solve"},{"location":"recipes/core/functions/factoring/#recipe","text":"Here's the general pattern: def subfunction_1(arg1, ...): \"\"\" Encapsulates one bit of functionality. \"\"\" result = ... # Calculate something using one or more lines of code return result def subfunction_2(arg1, arg2, ...): \"\"\" Encapsulates a different bit of functionality. \"\"\" other_result = ... # Calculate something using one or more lines of code return other_result def main_function(arg_A, arg_B, ...): \"\"\" Does something complicated. \"\"\" x = ... # Calculation z = subfunction_1(x, arg_B, ...) q = subfunction_2(z, ...) end_result = ... # Calculation return end_result Hopefully it's obvious that you can give the functions, arguments, and variables any names that reflect their actual purposes and meanings. It's entirely possible to call the same subfunction multiple times from the same main function, or even from different other functions. (A function can even call itself\u2026 That's called recursion , and can be a powerful technique, but be careful that it doesn't go on forever.)","title":"Recipe"},{"location":"recipes/core/functions/factoring/#when-should-you-factor-code-into-a-subfunction","text":"That's a judgment call. When considering whether to factor a particular chunk of code into a subfunction, ask yourself: Is this chunk of code doing something with one purpose, which could be described as the purpose of the possible subfunction? Is this chunk of code connected to the surrounding code fairly loosely, so that all it would need are a few input arguments and a return value or two? Or does it use and/or change multiple variables from the code around it in ways that are hard to cleanly factor? Is it long enough to be worth factoring? Overall, would moving this bit out make the code easier or harder to understand and debug? Sometimes it's worth putting a single line of code into a subfunction, if the line is nontrivial and doing so improves code readability. The ability to give that chunk a descriptive name (it's function name) can, all by itself, significantly aid readability. BTW, one very significant advantage of factoring code into subfunctions is that you can test the subfunctions individually to make sure they work correctly. Finding a head-scratcher of a bug is much easier if you've narrowed it down to somewhere in a five-line function than if it's somewhere in a 40-line function.","title":"When should you factor code into a subfunction?"},{"location":"recipes/core/functions/factoring/#example","text":"Let's say we need to calculate the total electrostatic potential energy stored in an arrangement of three charged point particles. Doing that requires summing the three pairwise potential energies, so calculating the potential energy of a pair is a sensible subfunction. Also, doing each pair calculation requires finding a distance, which could be done inline, but could also be factored out for clarity. from math import sqrt def distance(x1, y1, z1, x2, y2, z2): \"\"\" Returns the distance between two points in 3D. \"\"\" return sqrt((x1-x2)**2 + (y1-y2)**2 + (z1-z2)**2) def two_body_potential(q1, x1, y1, z1, q2, x2, y2, z2): \"\"\" Returns the potential energy of two point charges, in SI units. \"\"\" k = 8.9875517873681764e9 # N m\u00b2 C\u207b\u00b2 r = distance(x1, y1, z1, x2, y2, z2) return k * q1 * q2 / r def three_body potential(q1, x1, y1, z1, q2, x2, y2, z2, q3, x3, y3, z3): \"\"\" Returns the total potential energy of three point charges, in SI units. \"\"\" return (two_body_potential(q1, x1, y1, z1, q2, x2, y2, z2) + two_body_potential(q1, x1, y1, z1, q3, x3, y3, z3) + two_body_potential(q2, x2, y2, z2, q3, x3, y3, z3)) Side note: The most awkward part of all this is passing around four arguments for every particle. I wouldn't actually do this; instead, I'd pack them together into tuples or lists or \u2014 getting fancy \u2014 something called a named tuple . We'll be covering tuples and lists in Level A-05. After doing that, if you want to teach yourself about named tuples, be my guest!","title":"Example"},{"location":"recipes/core/functions/globals/","text":"Use Global Variables (Sparingly!) Problem to Solve I need to get values deep into a function or subfunction, and passing them via arguments is tedious. Background Knowledge In general arguments and return values are the preferred methods of getting variable values into and out of functions. However, sometimes you'll define some variables at a very high level in your code that will need to be referenced in multiple places, including deep inside functions and subfunctions. Passing those variables from function to function to function through a succession of arguments can be tedious, and can clutter up code and make it harder for a human to quickly identify the arguments that are of particular significance for a specific function. In such situations, you can use global variables . Here are some definitions: Local variable : A variable that is defined inside a function, and is therefore accessible only to that function. Global variable : A variable that is defined outside of any function, and is therefore accessible to all functions. Python actually has one other category, which only occurs when a subfunction is defined (not just called) inside another function. I'll call this an internal subfunction . The type you saw in the previous recipe, where the subfunction definition occurs outside the function that calls it, is an external subfunction . Nonlocal variable : For an internal subfunction, a variable that is defined in the scope of an enclosing function. Remember this: Variables defined inside a function (\"local variables\") are only accessible within the function itself and any subfunctions also defined within that function. Variables defined outside of any function (\"global variables\") are accessible to all functions. Global variables, and variables local to an enclosing function, cannot be altered without using the global keyword to make it clear you're not trying to create a new local variable that happens to have the same name. To keep life simple, I recommend avoiding nested function definitions (\"internal subfunctions\") unless you've got a very specific reason to use one. If you want a more thorough tutorial on global variables, here's one. Why NOT to use global variables Use global variables sparingly. When you're trying to find a bug in your code or just convince yourself that your logic is right, tracing the flow of values into and back out of functions via arguments and return values is fairly straightforward. However, when global variables can be accessed from anywhere, the flow of information gets much more complicated and harder to follow. Bugs become more likely. Change global variables from within functions even more sparingly\u2026 preferably never . Why? Because it's extremely easy for one bit of your code to change a global function in a way that breaks some other bit of your code, and whether/how the breakage occurs can depend on the details of execution order, number of repetitions, etc. Beatty's rule of thumb: Use global variables to define constants that don't change and need to be accessed in multiple places. Avoid changing the values of global variables if you possibly can. Recipes Flavor A: Using a Global Variable # Define a global variable MY_GLOBAL = 42 def my_function(): \"\"\" Uses a global variable. \"\"\" return 2 * MY_GLOBAL - 1 BTW, a common coding convention is to put the names of variables that are intended to be constants \u2014 defined once and never changed \u2014 in all-caps, especially if they are globals. Flavor B: Changing a Global Variable If you want a function to change, not just read, the value of a global variable, you have to include an extra step. Without the global keyword, the function will define its own variable MY_GLOBAL in its own scope rather than use the global one. # Define a global variable MY_GLOBAL = 42 def my_function(a, b): \"\"\" Alters a global variable. \"\"\" global MY_GLOBAL MY_GLOBAL += 1 Flavor C: Inheriting Local Variables Here's the recipe for having an internal subfunction inherit variables from an enclosing function: def outer_function(arg1, arg2, arg3): \"\"\" Defines a local variable and an internal subfunction. \"\"\" inner_var_1 = ... # Define a local variable somehow def inner_function(argA): \"\"\" Uses one or more local variables from the enclosing function. \"\"\" a_result = ... # Calculate using arg1, arg2, arg3, and/or inner_var_1 as well as argA return a_result return inner_function(...) # Call the internal subfunction with any legitimate expression Again, I think the complexity of this approach is rarely worthwhile. Examples Generic Mix-n-Match Here's a generic example that showcases both internal and external subfunctions, with access to local, nonlocal, and global variables. (I can think of no good reason to structure code like this, but it's an illustration.) # Define a global variable: a_global_var = 1.0 def external_sub(): print(f\"external_sub: {a_global_var = }\") # Won't work: # print(f\"external_sub: {a_local_var = }\") def main(): def internal_sub(): print(f\"internal_sub: {a_global_var = }\") print(f\"internal_sub: {a_local_var = }\") # Define a local variable: a_local_var = 2.0 print(f\"main: {a_global_var = }\") print(f\"main: {a_local_var = }\") internal_sub() external_sub() main() Actual Physics Example For some obscure purpose related to electromagnetism, let's say you need to write a function that takes the charges and positions of three particles arranged along the x-axis, and calculates and returns two values: (a) the net force acting on particle #3, and the electrostatic potential energy it has because of the other two (i.e., the energy required to bring particle #3 in \"from infinity\"). Here's one good way to implement that: # Constants k = 8.9875517873681764e9 # N m\u00b2 C\u207b\u00b2 def F(qA, xA, qB, xB): \"\"\" Calculate the electrostatic force of repulsion on particle B due to particle A. \"\"\" return k * qA * qB * (xB - xA) / abs(xB - xA)**3 def U(qA, xA, qB, xB): \"\"\" Calculate the electrostatic potential energy between two particles. \"\"\" return k * qA * qB / abs(xB - xA) def force_and_energy_on_3(q1, x1, q2, x2, q3, x3): \"\"\" Calculate the net electrostatic force AND potential energy on/of particle 3 from 1 and 2. \"\"\" F_net = F(q1, x1, q3, x3) + F(q2, x2, q3, x3) U_net = U(q1, x1, q3, x3) + U(q2, x2, q3, x3) return F_net, U_net An alternative way to do this, reducing the passing of arguments somewhat, would be to use internal subfunctions: # Constants k = 8.9875517873681764e9 # N m\u00b2 C\u207b\u00b2 def force_and_energy_on_3(q1, x1, q2, x2, q3, x3): \"\"\" Calculate the net electrostatic force AND potential energy on/of particle 3 from 1 and 2. \"\"\" def F_from(q, x): \"\"\" Calculate the electrostatic force of repulsion on particle 3 (in inherited scope) due to a particle with charge `q` at location `x`. \"\"\" return k * q * q3 * (x - x3) / abs(x - x3)**3 def U_from(q, x): \"\"\" Calculate the electrostatic potential energy of particle 3 (in inherited scope) with a particle with charge `q` at location `x`. \"\"\" return k * q * q3 / abs(x - x3) F_net = F_from(q1, x1) + F_from(q2, x2) U_net = U_from(q1, x1) + U_from(q2, x2) return F_net, U_net Personally, I don't think the modest shortening of the argument lists is worth the additional cognitive load of having to figure out where the various variable values come from.","title":"Use Global Variables (Sparingly!)"},{"location":"recipes/core/functions/globals/#use-global-variables-sparingly","text":"","title":"Use Global Variables (Sparingly!)"},{"location":"recipes/core/functions/globals/#problem-to-solve","text":"I need to get values deep into a function or subfunction, and passing them via arguments is tedious.","title":"Problem to Solve"},{"location":"recipes/core/functions/globals/#background-knowledge","text":"In general arguments and return values are the preferred methods of getting variable values into and out of functions. However, sometimes you'll define some variables at a very high level in your code that will need to be referenced in multiple places, including deep inside functions and subfunctions. Passing those variables from function to function to function through a succession of arguments can be tedious, and can clutter up code and make it harder for a human to quickly identify the arguments that are of particular significance for a specific function. In such situations, you can use global variables . Here are some definitions: Local variable : A variable that is defined inside a function, and is therefore accessible only to that function. Global variable : A variable that is defined outside of any function, and is therefore accessible to all functions. Python actually has one other category, which only occurs when a subfunction is defined (not just called) inside another function. I'll call this an internal subfunction . The type you saw in the previous recipe, where the subfunction definition occurs outside the function that calls it, is an external subfunction . Nonlocal variable : For an internal subfunction, a variable that is defined in the scope of an enclosing function. Remember this: Variables defined inside a function (\"local variables\") are only accessible within the function itself and any subfunctions also defined within that function. Variables defined outside of any function (\"global variables\") are accessible to all functions. Global variables, and variables local to an enclosing function, cannot be altered without using the global keyword to make it clear you're not trying to create a new local variable that happens to have the same name. To keep life simple, I recommend avoiding nested function definitions (\"internal subfunctions\") unless you've got a very specific reason to use one. If you want a more thorough tutorial on global variables, here's one.","title":"Background Knowledge"},{"location":"recipes/core/functions/globals/#why-not-to-use-global-variables","text":"Use global variables sparingly. When you're trying to find a bug in your code or just convince yourself that your logic is right, tracing the flow of values into and back out of functions via arguments and return values is fairly straightforward. However, when global variables can be accessed from anywhere, the flow of information gets much more complicated and harder to follow. Bugs become more likely. Change global variables from within functions even more sparingly\u2026 preferably never . Why? Because it's extremely easy for one bit of your code to change a global function in a way that breaks some other bit of your code, and whether/how the breakage occurs can depend on the details of execution order, number of repetitions, etc. Beatty's rule of thumb: Use global variables to define constants that don't change and need to be accessed in multiple places. Avoid changing the values of global variables if you possibly can.","title":"Why NOT to use global variables"},{"location":"recipes/core/functions/globals/#recipes","text":"","title":"Recipes"},{"location":"recipes/core/functions/globals/#flavor-a-using-a-global-variable","text":"# Define a global variable MY_GLOBAL = 42 def my_function(): \"\"\" Uses a global variable. \"\"\" return 2 * MY_GLOBAL - 1 BTW, a common coding convention is to put the names of variables that are intended to be constants \u2014 defined once and never changed \u2014 in all-caps, especially if they are globals.","title":"Flavor A: Using a Global Variable"},{"location":"recipes/core/functions/globals/#flavor-b-changing-a-global-variable","text":"If you want a function to change, not just read, the value of a global variable, you have to include an extra step. Without the global keyword, the function will define its own variable MY_GLOBAL in its own scope rather than use the global one. # Define a global variable MY_GLOBAL = 42 def my_function(a, b): \"\"\" Alters a global variable. \"\"\" global MY_GLOBAL MY_GLOBAL += 1","title":"Flavor B: Changing a Global Variable"},{"location":"recipes/core/functions/globals/#flavor-c-inheriting-local-variables","text":"Here's the recipe for having an internal subfunction inherit variables from an enclosing function: def outer_function(arg1, arg2, arg3): \"\"\" Defines a local variable and an internal subfunction. \"\"\" inner_var_1 = ... # Define a local variable somehow def inner_function(argA): \"\"\" Uses one or more local variables from the enclosing function. \"\"\" a_result = ... # Calculate using arg1, arg2, arg3, and/or inner_var_1 as well as argA return a_result return inner_function(...) # Call the internal subfunction with any legitimate expression Again, I think the complexity of this approach is rarely worthwhile.","title":"Flavor C: Inheriting Local Variables"},{"location":"recipes/core/functions/globals/#examples","text":"","title":"Examples"},{"location":"recipes/core/functions/globals/#generic-mix-n-match","text":"Here's a generic example that showcases both internal and external subfunctions, with access to local, nonlocal, and global variables. (I can think of no good reason to structure code like this, but it's an illustration.) # Define a global variable: a_global_var = 1.0 def external_sub(): print(f\"external_sub: {a_global_var = }\") # Won't work: # print(f\"external_sub: {a_local_var = }\") def main(): def internal_sub(): print(f\"internal_sub: {a_global_var = }\") print(f\"internal_sub: {a_local_var = }\") # Define a local variable: a_local_var = 2.0 print(f\"main: {a_global_var = }\") print(f\"main: {a_local_var = }\") internal_sub() external_sub() main()","title":"Generic Mix-n-Match"},{"location":"recipes/core/functions/globals/#actual-physics-example","text":"For some obscure purpose related to electromagnetism, let's say you need to write a function that takes the charges and positions of three particles arranged along the x-axis, and calculates and returns two values: (a) the net force acting on particle #3, and the electrostatic potential energy it has because of the other two (i.e., the energy required to bring particle #3 in \"from infinity\"). Here's one good way to implement that: # Constants k = 8.9875517873681764e9 # N m\u00b2 C\u207b\u00b2 def F(qA, xA, qB, xB): \"\"\" Calculate the electrostatic force of repulsion on particle B due to particle A. \"\"\" return k * qA * qB * (xB - xA) / abs(xB - xA)**3 def U(qA, xA, qB, xB): \"\"\" Calculate the electrostatic potential energy between two particles. \"\"\" return k * qA * qB / abs(xB - xA) def force_and_energy_on_3(q1, x1, q2, x2, q3, x3): \"\"\" Calculate the net electrostatic force AND potential energy on/of particle 3 from 1 and 2. \"\"\" F_net = F(q1, x1, q3, x3) + F(q2, x2, q3, x3) U_net = U(q1, x1, q3, x3) + U(q2, x2, q3, x3) return F_net, U_net An alternative way to do this, reducing the passing of arguments somewhat, would be to use internal subfunctions: # Constants k = 8.9875517873681764e9 # N m\u00b2 C\u207b\u00b2 def force_and_energy_on_3(q1, x1, q2, x2, q3, x3): \"\"\" Calculate the net electrostatic force AND potential energy on/of particle 3 from 1 and 2. \"\"\" def F_from(q, x): \"\"\" Calculate the electrostatic force of repulsion on particle 3 (in inherited scope) due to a particle with charge `q` at location `x`. \"\"\" return k * q * q3 * (x - x3) / abs(x - x3)**3 def U_from(q, x): \"\"\" Calculate the electrostatic potential energy of particle 3 (in inherited scope) with a particle with charge `q` at location `x`. \"\"\" return k * q * q3 / abs(x - x3) F_net = F_from(q1, x1) + F_from(q2, x2) U_net = U_from(q1, x1) + U_from(q2, x2) return F_net, U_net Personally, I don't think the modest shortening of the argument lists is worth the additional cognitive load of having to figure out where the various variable values come from.","title":"Actual Physics Example"},{"location":"recipes/core/functions/optional-args/","text":"Make Arguments Optional Problem to Solve I want to write a function with an argument that the user can ignore unless they want to override the \"normal\" value with something else. Recipe Step 1: Define the Function With Default Values You can make any one of a function's arguments optional \u2014 meaning that calling code can either specify a value for it or omit it entirely \u2014 by supplying a default value in the function signature: def function_name(arg_1, arg_2=default_value_2): \"\"\" Template for a function that has one required and one optional argument. \"\"\" pass # Replace these two lines with actual code that does pass # something with arg_1 and arg_2. return result Replace default_value_2 with the specific value you want the function to use for the value of arg_2 if the calling code doesn't provide one. - You can specify a numeric literal, a string literal, a variable, or a more complicated python expression. - However, mind that the variable or expression will be evaluated only once, at the time the function definition is sent to the interpreter, and NOT every time the function is called. - A literal number, string, or boolean value is by far the most common kind of default value. Step 2: Call the Function With or Without the Optional Argument When calling a function with an optional argument, you can either provide a value for the optional argument or omit it. If you omit it, the function will use the default value specified in the function definition. Both of these function calls are valid: a = function_name(val_1, val_2) b = function_name(other_val_1) Elaboration: Mixing and Matching Multiple Optional Arguments If more than one argument is optional, and calling code provides fewer than the maximum number of values, which optional arguments get the passed values and which use default values? Any values provided by the calling code will be assigned to arguments from left to right according to the function signature, unless told otherwise by explicit argument names . Consider this function definition: def function_name(x=0, y=0): \"\"\" Template for a function that has two optional arguments. \"\"\" pass # Do something with x and y. return result The function can be called in any of these ways: out_1 = function_name() # Sets x to 0 and y to 0 out_2 = function_name(1) # Sets x to 1 and y to 0 out_3 = function_name(1, 2) # Sets x to 1 and y to 2 out_4 = function_name(y=2) # Sets x to 0 and y to 2 The following are also legitimate, but unnecessary. The first two might be worth writing for the sake of clarity; the third is simply confusing. out_5 = function_name(x=1) # Sets x to 1 and y to 0 out_6 = function_name(x=1, y=2) # Sets x to 1 and y to 2 out_7 = function_name(y=2, x=1) # Sets x to 1 and y to 2 Side note: It is possible to define a function that can accept any number of optional arguments, either with or without argument names in the calling code. However, that requires the use of collections that we have not yet looked at. Example import math def projectile_range(v0, theta, h=0, g=9.81): \"\"\" Calculate the range of a ballistic projectile without air resistance, launched from an arbitrary height above the ground. Parameters: - v0: The projectile's initial velocity (m/s) - theta: the projectile's launch angle above horizontal (degrees) - h: the launch height above the ground (m), defaults to zero - g: the local gravitational constant (m/s**2), defaults to Earth Returns: the horizontal distance the projectile travels, in meters, before hitting the ground. \"\"\" # Convert angle from degrees to radians. theta_rad = math.radians(theta) # Calculate range using the standard formula derived in intro physics. range_ = (v0 * math.cos(theta_rad) / g) * ( v0 * math.sin(theta_rad) + math.sqrt((v0 * math.sin(theta_rad))**2 + 2 * g * h) ) return range_ Note: This uses range_ instead of range for the name of the returned variable because range is the name of a built-in python function that we don't want to collide with. Appending an underscore is a common way of working around conflicts between desirable variable names and already-existing python names. Usage: v, theta, h = 85, 25, 10 print(\"On level ground and in the absence of air drag, the horizontal distance traveled\") print(f\"by a ballistic projectile fired with muzzle speed {v} m/s at an angle of {theta}\") print(f\"degrees above the horizontal is {projectile_range(v, theta):.2f} meters.\") print() print(f\"If the projectile is launched from a height of {h} meters above the ground,\") print(f\"the horizontal distance traveled is {projectile_range(v, theta, h):.2f} meters.\") print() g_moon = 1.625 # Moon's gravity is about 1/6th of Earth's. print(\"If launched on the moon from ground level, the distance traveled would be\") print(f\"{projectile_range(v, theta, g=g_moon):.2f} meters.\")","title":"Make Arguments Optional"},{"location":"recipes/core/functions/optional-args/#make-arguments-optional","text":"","title":"Make Arguments Optional"},{"location":"recipes/core/functions/optional-args/#problem-to-solve","text":"I want to write a function with an argument that the user can ignore unless they want to override the \"normal\" value with something else.","title":"Problem to Solve"},{"location":"recipes/core/functions/optional-args/#recipe","text":"","title":"Recipe"},{"location":"recipes/core/functions/optional-args/#step-1-define-the-function-with-default-values","text":"You can make any one of a function's arguments optional \u2014 meaning that calling code can either specify a value for it or omit it entirely \u2014 by supplying a default value in the function signature: def function_name(arg_1, arg_2=default_value_2): \"\"\" Template for a function that has one required and one optional argument. \"\"\" pass # Replace these two lines with actual code that does pass # something with arg_1 and arg_2. return result Replace default_value_2 with the specific value you want the function to use for the value of arg_2 if the calling code doesn't provide one. - You can specify a numeric literal, a string literal, a variable, or a more complicated python expression. - However, mind that the variable or expression will be evaluated only once, at the time the function definition is sent to the interpreter, and NOT every time the function is called. - A literal number, string, or boolean value is by far the most common kind of default value.","title":"Step 1: Define the Function With Default Values"},{"location":"recipes/core/functions/optional-args/#step-2-call-the-function-with-or-without-the-optional-argument","text":"When calling a function with an optional argument, you can either provide a value for the optional argument or omit it. If you omit it, the function will use the default value specified in the function definition. Both of these function calls are valid: a = function_name(val_1, val_2) b = function_name(other_val_1)","title":"Step 2: Call the Function With or Without the Optional Argument"},{"location":"recipes/core/functions/optional-args/#elaboration-mixing-and-matching-multiple-optional-arguments","text":"If more than one argument is optional, and calling code provides fewer than the maximum number of values, which optional arguments get the passed values and which use default values? Any values provided by the calling code will be assigned to arguments from left to right according to the function signature, unless told otherwise by explicit argument names . Consider this function definition: def function_name(x=0, y=0): \"\"\" Template for a function that has two optional arguments. \"\"\" pass # Do something with x and y. return result The function can be called in any of these ways: out_1 = function_name() # Sets x to 0 and y to 0 out_2 = function_name(1) # Sets x to 1 and y to 0 out_3 = function_name(1, 2) # Sets x to 1 and y to 2 out_4 = function_name(y=2) # Sets x to 0 and y to 2 The following are also legitimate, but unnecessary. The first two might be worth writing for the sake of clarity; the third is simply confusing. out_5 = function_name(x=1) # Sets x to 1 and y to 0 out_6 = function_name(x=1, y=2) # Sets x to 1 and y to 2 out_7 = function_name(y=2, x=1) # Sets x to 1 and y to 2 Side note: It is possible to define a function that can accept any number of optional arguments, either with or without argument names in the calling code. However, that requires the use of collections that we have not yet looked at.","title":"Elaboration: Mixing and Matching Multiple Optional Arguments"},{"location":"recipes/core/functions/optional-args/#example","text":"import math def projectile_range(v0, theta, h=0, g=9.81): \"\"\" Calculate the range of a ballistic projectile without air resistance, launched from an arbitrary height above the ground. Parameters: - v0: The projectile's initial velocity (m/s) - theta: the projectile's launch angle above horizontal (degrees) - h: the launch height above the ground (m), defaults to zero - g: the local gravitational constant (m/s**2), defaults to Earth Returns: the horizontal distance the projectile travels, in meters, before hitting the ground. \"\"\" # Convert angle from degrees to radians. theta_rad = math.radians(theta) # Calculate range using the standard formula derived in intro physics. range_ = (v0 * math.cos(theta_rad) / g) * ( v0 * math.sin(theta_rad) + math.sqrt((v0 * math.sin(theta_rad))**2 + 2 * g * h) ) return range_ Note: This uses range_ instead of range for the name of the returned variable because range is the name of a built-in python function that we don't want to collide with. Appending an underscore is a common way of working around conflicts between desirable variable names and already-existing python names. Usage: v, theta, h = 85, 25, 10 print(\"On level ground and in the absence of air drag, the horizontal distance traveled\") print(f\"by a ballistic projectile fired with muzzle speed {v} m/s at an angle of {theta}\") print(f\"degrees above the horizontal is {projectile_range(v, theta):.2f} meters.\") print() print(f\"If the projectile is launched from a height of {h} meters above the ground,\") print(f\"the horizontal distance traveled is {projectile_range(v, theta, h):.2f} meters.\") print() g_moon = 1.625 # Moon's gravity is about 1/6th of Earth's. print(\"If launched on the moon from ground level, the distance traveled would be\") print(f\"{projectile_range(v, theta, g=g_moon):.2f} meters.\")","title":"Example"},{"location":"recipes/core/functions/run-or-import/","text":"Run or Import From a Script Problem to Solve I want to write a script that I can run, and I also want to use functions it defines in the console or other scripts. Background Knowledge This is not an unusual situation. One case is that you developed some reasonably general functions while solving one particular problem with a python script, and now would like to \"borrow\" those functions for a different calculation. You could copy-paste them, but perhaps you'd like to be able to improve or debug them in just one place while using them in multiple places. Another, common case is that you write a python script specifically to define functions for other scripts to import, but you want to include some test or demonstration code in the script that will execute if you run the script directly rather than importing it. Python has a mechanism for this, though it looks rather arcane. The key thing to understand is that when a python script is run , the python interpreter defines a special variable named __name__ and sets it to the string \"__main__\" . However, when a script is imported , the interpreter sets __name__ to the name of the script doing the importing. The recipe takes advantagre of this to decide whether to run some code or not. Recipe # Start with code that should be executed regardless of whether the script is # run or imported. some_constant = ... # We can define constants available to scripts importing this one. def function_one(arg1, arg2): \"\"\" A function available to scripts importing this one. \"\"\" ... # Calculate stuff return ... # Return something def function_two(arg1): \"\"\" Another function available to scripts importing this one. \"\"\" return ... # Return something # Now, put the code to execute only if this script is run directly, but not when # it is imported. if __name__ == \"__main__\": # Code inside here will be executed only if the script is run, but not if it's # imported. It can (but doesn't necessarily have to) use the constants and # functions defined above. ... # Do something ... # Do something else Example Let's say that you often need to calculate the range of a projectile, given its muzzle speed, launch angle, and (optionally) elevation of the launch point above the ground. You'd like to be able to call this function from other scripts that might, for example, iteratively search for the maximum range, or plot the range as a function of launch angle, or whatever. You'd also like to be able to run this script, have it prompt you for the input parameters, and then print out the result (to three significant figures, of course). Here's how you could accomplish that: # file: projectile.py # Imports from math import radians, sin, cos, sqrt # Define constants: g = 9.81 # N/kg == m/s**2 # Define the range function def range(v0, theta, h=0.0): \"\"\" Returns the range of a projectile launched at speed v0 and angle theta. Optional argument h is the height of the launch point above the ground. SI units are presumed. \"\"\" theta_rad = radians(theta) v0x, v0y = v0 * cos(theta_rad), v0 * sin(theta_rad) t_flight = (v0y + sqrt(v0y**2 + 2 * g * h)) / g return v0x * t_flight # Provide the interactive interface if the script is run directly: if __name__ == \"__main__\": v0 = float(input(\"Enter the initial speed (m/s): \")) theta = float(input(\"Enter the launch angle (degrees above horizontal): \")) h = float(input(\"Enter the height of the launch point above the ground (m): \")) print(f\"Range: {range(v0, theta, h):.3g} m\") In addition to running this script and providing the initial conditions interactively, you could have another script (or you, from the console) call it programmatically: from projectile import range print(f\"Test calculation: range = {range(50, 30):.3g} m\") And guess what? You know those useful modules like math and cmath that you import, or import functions from? Now you can create your own libraries of useful functions! \ud83e\udd2f","title":"Run or Import From a Script"},{"location":"recipes/core/functions/run-or-import/#run-or-import-from-a-script","text":"","title":"Run or Import From a Script"},{"location":"recipes/core/functions/run-or-import/#problem-to-solve","text":"I want to write a script that I can run, and I also want to use functions it defines in the console or other scripts.","title":"Problem to Solve"},{"location":"recipes/core/functions/run-or-import/#background-knowledge","text":"This is not an unusual situation. One case is that you developed some reasonably general functions while solving one particular problem with a python script, and now would like to \"borrow\" those functions for a different calculation. You could copy-paste them, but perhaps you'd like to be able to improve or debug them in just one place while using them in multiple places. Another, common case is that you write a python script specifically to define functions for other scripts to import, but you want to include some test or demonstration code in the script that will execute if you run the script directly rather than importing it. Python has a mechanism for this, though it looks rather arcane. The key thing to understand is that when a python script is run , the python interpreter defines a special variable named __name__ and sets it to the string \"__main__\" . However, when a script is imported , the interpreter sets __name__ to the name of the script doing the importing. The recipe takes advantagre of this to decide whether to run some code or not.","title":"Background Knowledge"},{"location":"recipes/core/functions/run-or-import/#recipe","text":"# Start with code that should be executed regardless of whether the script is # run or imported. some_constant = ... # We can define constants available to scripts importing this one. def function_one(arg1, arg2): \"\"\" A function available to scripts importing this one. \"\"\" ... # Calculate stuff return ... # Return something def function_two(arg1): \"\"\" Another function available to scripts importing this one. \"\"\" return ... # Return something # Now, put the code to execute only if this script is run directly, but not when # it is imported. if __name__ == \"__main__\": # Code inside here will be executed only if the script is run, but not if it's # imported. It can (but doesn't necessarily have to) use the constants and # functions defined above. ... # Do something ... # Do something else","title":"Recipe"},{"location":"recipes/core/functions/run-or-import/#example","text":"Let's say that you often need to calculate the range of a projectile, given its muzzle speed, launch angle, and (optionally) elevation of the launch point above the ground. You'd like to be able to call this function from other scripts that might, for example, iteratively search for the maximum range, or plot the range as a function of launch angle, or whatever. You'd also like to be able to run this script, have it prompt you for the input parameters, and then print out the result (to three significant figures, of course). Here's how you could accomplish that: # file: projectile.py # Imports from math import radians, sin, cos, sqrt # Define constants: g = 9.81 # N/kg == m/s**2 # Define the range function def range(v0, theta, h=0.0): \"\"\" Returns the range of a projectile launched at speed v0 and angle theta. Optional argument h is the height of the launch point above the ground. SI units are presumed. \"\"\" theta_rad = radians(theta) v0x, v0y = v0 * cos(theta_rad), v0 * sin(theta_rad) t_flight = (v0y + sqrt(v0y**2 + 2 * g * h)) / g return v0x * t_flight # Provide the interactive interface if the script is run directly: if __name__ == \"__main__\": v0 = float(input(\"Enter the initial speed (m/s): \")) theta = float(input(\"Enter the launch angle (degrees above horizontal): \")) h = float(input(\"Enter the height of the launch point above the ground (m): \")) print(f\"Range: {range(v0, theta, h):.3g} m\") In addition to running this script and providing the initial conditions interactively, you could have another script (or you, from the console) call it programmatically: from projectile import range print(f\"Test calculation: range = {range(50, 30):.3g} m\") And guess what? You know those useful modules like math and cmath that you import, or import functions from? Now you can create your own libraries of useful functions! \ud83e\udd2f","title":"Example"},{"location":"recipes/core/functions/safety-check/","text":"Safety-Check Arguments Problem to Solve I want to make my function robust against incorrect or unexpected arguments. When you write quick, short-term-use functions for yourself, you probably don't need to worry about this. However, if you're writing functions as part of a larger project, and/or for others to use, and/or for you to use in the future, sparing a line or few of code to idiot-proof them against inappropriate arguments is wise. I showed you a foretaste of this back in Ask for User Input , but now (a) it's more important, and (b) we've got better tools to deal with it. Recipe A function must guard against two basic kinds of argument error: - being passed a value of an incorrect type (like a float when an integer is expected, or a list [coming soon] instead of a single value), and - being passed a value of the right type but an inappropriate value (like a negative value for a mass). Flavor A: Type Checking To check the type of an argument, you can explicitly test whether it's got the right type, like this: def demo_function(x): \"\"\" A function that requires `x` to be a float. \"\"\" if not isinstance(x, float): raise TypeError(\"x must be a float\") # Proceed with the function using `x`... Wait, what's with this raise TypeError(...) stuff?!? \ud83e\uddd0 That's the python way of triggering an error message to the user. raise says `An error has occurred, and unless the code that's called me can do something smart to handle it, the user had better be informed!' TypeError indicates the kind of error that's occurred. Python has many built-in error types for you to choose from and you can even define your own. The two you're most likely to need for now, however, are: TypeError : for when an object of inappropriate type is encountered. ValueError : for when an object of the right type but inappropriate value is encountered. \"x must be a a float\" is the message that will be displayed to the user. You can write whatever you like here, but it's good to be specific about what's wrong so the poor user (likely you) has some idea what to do about it. If you're okay with either an integer or floating-point value (since you can use an integer pretty much anywhere a float is expected), you can write: def demo_function(x): \"\"\" A function that requires `x` to be a float or int. \"\"\" if not isinstance(x, (float, int)): raise TypeError(\"x must be a float or int\") # Proceed with the function using `x`... Sometimes, checking an argument value's type this way is the right approach. However, very often we don't actually care what the type of the argument is, so long as we can use it for our purposes. For example, if we want a float, so what if we're given an integer? We can use that just fine anywhere a decimal number is needed! So, instead of checking the type, we just coerce it to an adequate type: def demo_function(x): \"\"\" A function that requires `x` to be interpretable as a float. \"\"\" x = float(x) # Proceed with the function using `x`... If the user (or other code) calls demo_function with any kind of value that can be turned into a float \u2014 such as a float, an integer, or a string representing a legitimate floating-point literal like \"3.2e4\" \u2014 it'll get turned into a float, and the function can happily proceed. OTOH, if the function receives something that can't be coerced into a float, python will raise a ValueError with a message like could not convert string to float: '2.5 m/s' . You don't need to bother with your own raise statement. By the way, there's a third approach: Don't bother to check or coerce the argument at all. Just use it, and let python raise an error when it reaches a point where the argument's type is problematic. Depending on the situation, this might be fine, or it might open the door to hard-to-interpret errors or hard-to-fix bugs. Use your judgment. In particular, if it's obvious that an incorrect argument type will quickly cause an error to occur, you're probably okay omitting the explicit check. However, if an incorrect type might cause unintended behavior rather than an error, explicitly checking becomes essential. Forward reference: A common situation when a wrong type won't raise an error is when code expects a list (which we'll get to soon), but is given a string instead. If x represents a list, x[3] produces the fourth element in the list. However, if x represents a string, x[3] produces the fourth character in the string \u2014 a totally different thing, and potentially very confusing, especially if the list is supposed to be a list of strings! Flavor B: Value Checking This is straightforward: Use an if statement to test the argument's value with the appropriate boolean expressions, and raise a ValueError if the test fails. def demo_function(x): \"\"\" A function that requires `x` to be a positive number. \"\"\" if x <= 0: raise ValueError(\"x must be positive!\") # Proceed with the function using `x`... If your restrictions on the argument's value are more complicated, you can combine boolean expressions with and , or , and not , and/or you can use a multi-clause if/elif/\u2026 construct. If you need to check multiple arguments, just put the checks one after another in the function body. If more than one is invalid, only the first will be caught, but that's usually enough for the user to make progress. By the way, a slightly shorter and quicker way to accomplish this is to use the assert statement introduced earlier. For example: def demo_function(x): \"\"\" A function that requires `x` to be a positive number. \"\"\" assert x > 0, \"x must be positive!\" # Proceed with the function using `x`... The only significant practical difference here is that the user sees AssertionError instead of ValueError . That probably doesn't matter if a human gets the message, but sometimes the calling code will be written to \"catch\" certain errors and respond automatically. Philosophically, however, programmers generally see assertions (using assert ) as safety-checks inside their code that should never raise an error unless something has gone wrong inside the program, whereas exceptions (using raise ) are for when the user or external code has done something wrong. For the purposes of this course, I'll try to be explicit when an assigment cares what type of exception gets raised; otherwise, do as you see fit. Examples Here's an example illustrating a common situation: a function requires an integer for something, such as the number of times to repeat something \u2014 a random choice, a time-step in a dynamical simulation, etc. The user might plausibly want to pass very large numbers: ten thousand, a million, five million, whatever. The problem is that python interprets scientific notation such as 1e4 , 1e6 , and 5e6 as floating-point values, not integers. If you don't check for this and do the following, your user will get annoyed: def average_of_N(N): \"\"\" Generates a random number by a call to `roll_die` (whose definition is not shown here), `N` times, and returns the average of all the values. \"\"\" sum = 0 for i in range(N): sum += roll_die() return sum / N (We haven't formally introduced for -loop iteration or the range function yet. I'm assuming you've seen enough python to be able to interpret it.) Here's an example of the problem: >>> average_of_N(10_000) 3.5042 >>> average_of_N(1e4) --------------------------------------------------------------------------- TypeError Traceback (most recent call last) Cell In[6], line 1 ----> 1 average_of_N(1e5) Cell In[1], line 7, in average_of_N(N) 2 \"\"\" Generates a random number by a call to `roll_die` (whose definition 3 is not shown here), `N` times, and returns the average of all the 4 values. 5 \"\"\" 6 sum = 0 ----> 7 for i in range(N): 8 sum += roll_die() 9 return sum / N TypeError: 'float' object cannot be interpreted as an integer The solution is simple, once you understand the problem: def average_of_N(N): \"\"\" Generates a random number by a call to `roll_die` (whose definition is not shown here), `N` times, and returns the average of all the values. \"\"\" N = int(N) sum = 0 for i in range(N): sum += roll_die() return sum / N Now, the function works as expected: >>> average_of_N(1e4) 3.4865 We still have a problem, however: >>> average_of_N(-1e4) -0.0 We didn't get an error, but we did get a nonsensical result. If that function call were being made by other code, and its value used in some larger calculation, we might never realize that the nonsensical value was causing the calculation to be incorrect. The problem, of course, it makes no sense to average something a negative number of times. We can fix this with a simple check: def average_of_N(N): \"\"\" Generates a random number by a call to `roll_die` (whose definition is not shown here), `N` times, and returns the average of all the values. \"\"\" N = int(N) assert N > 0, \"N must be positive!\" sum = 0 for i in range(N): sum += roll_die() return sum / N Now: >>> average_of_N(-1e4) --------------------------------------------------------------------------- AssertionError Traceback (most recent call last) Cell In[14], line 1 ----> 1 average_of_N(-1e4) Cell In[13], line 7, in average_of_N(N) 2 \"\"\" Generates a random number by a call to `roll_die` (whose definition 3 is not shown here), `N` times, and returns the average of all the 4 values. 5 \"\"\" 6 N = int(N) ----> 7 assert N > 0, \"N must be positive!\" 8 sum = 0 9 for i in range(N): AssertionError: N must be positive! Get the idea? It's not hard; it just takes a bit of discipline to stop and ask, while writing a function, \"What argument types or values are legitimate here? Will it break things or cause erroneous results if an invalid argument is provided? Maybe I better toss in a couple of lines of code just to be safe.\"","title":"Safety-Check Arguments"},{"location":"recipes/core/functions/safety-check/#safety-check-arguments","text":"","title":"Safety-Check Arguments"},{"location":"recipes/core/functions/safety-check/#problem-to-solve","text":"I want to make my function robust against incorrect or unexpected arguments. When you write quick, short-term-use functions for yourself, you probably don't need to worry about this. However, if you're writing functions as part of a larger project, and/or for others to use, and/or for you to use in the future, sparing a line or few of code to idiot-proof them against inappropriate arguments is wise. I showed you a foretaste of this back in Ask for User Input , but now (a) it's more important, and (b) we've got better tools to deal with it.","title":"Problem to Solve"},{"location":"recipes/core/functions/safety-check/#recipe","text":"A function must guard against two basic kinds of argument error: - being passed a value of an incorrect type (like a float when an integer is expected, or a list [coming soon] instead of a single value), and - being passed a value of the right type but an inappropriate value (like a negative value for a mass).","title":"Recipe"},{"location":"recipes/core/functions/safety-check/#flavor-a-type-checking","text":"To check the type of an argument, you can explicitly test whether it's got the right type, like this: def demo_function(x): \"\"\" A function that requires `x` to be a float. \"\"\" if not isinstance(x, float): raise TypeError(\"x must be a float\") # Proceed with the function using `x`... Wait, what's with this raise TypeError(...) stuff?!? \ud83e\uddd0 That's the python way of triggering an error message to the user. raise says `An error has occurred, and unless the code that's called me can do something smart to handle it, the user had better be informed!' TypeError indicates the kind of error that's occurred. Python has many built-in error types for you to choose from and you can even define your own. The two you're most likely to need for now, however, are: TypeError : for when an object of inappropriate type is encountered. ValueError : for when an object of the right type but inappropriate value is encountered. \"x must be a a float\" is the message that will be displayed to the user. You can write whatever you like here, but it's good to be specific about what's wrong so the poor user (likely you) has some idea what to do about it. If you're okay with either an integer or floating-point value (since you can use an integer pretty much anywhere a float is expected), you can write: def demo_function(x): \"\"\" A function that requires `x` to be a float or int. \"\"\" if not isinstance(x, (float, int)): raise TypeError(\"x must be a float or int\") # Proceed with the function using `x`... Sometimes, checking an argument value's type this way is the right approach. However, very often we don't actually care what the type of the argument is, so long as we can use it for our purposes. For example, if we want a float, so what if we're given an integer? We can use that just fine anywhere a decimal number is needed! So, instead of checking the type, we just coerce it to an adequate type: def demo_function(x): \"\"\" A function that requires `x` to be interpretable as a float. \"\"\" x = float(x) # Proceed with the function using `x`... If the user (or other code) calls demo_function with any kind of value that can be turned into a float \u2014 such as a float, an integer, or a string representing a legitimate floating-point literal like \"3.2e4\" \u2014 it'll get turned into a float, and the function can happily proceed. OTOH, if the function receives something that can't be coerced into a float, python will raise a ValueError with a message like could not convert string to float: '2.5 m/s' . You don't need to bother with your own raise statement. By the way, there's a third approach: Don't bother to check or coerce the argument at all. Just use it, and let python raise an error when it reaches a point where the argument's type is problematic. Depending on the situation, this might be fine, or it might open the door to hard-to-interpret errors or hard-to-fix bugs. Use your judgment. In particular, if it's obvious that an incorrect argument type will quickly cause an error to occur, you're probably okay omitting the explicit check. However, if an incorrect type might cause unintended behavior rather than an error, explicitly checking becomes essential. Forward reference: A common situation when a wrong type won't raise an error is when code expects a list (which we'll get to soon), but is given a string instead. If x represents a list, x[3] produces the fourth element in the list. However, if x represents a string, x[3] produces the fourth character in the string \u2014 a totally different thing, and potentially very confusing, especially if the list is supposed to be a list of strings!","title":"Flavor A: Type Checking"},{"location":"recipes/core/functions/safety-check/#flavor-b-value-checking","text":"This is straightforward: Use an if statement to test the argument's value with the appropriate boolean expressions, and raise a ValueError if the test fails. def demo_function(x): \"\"\" A function that requires `x` to be a positive number. \"\"\" if x <= 0: raise ValueError(\"x must be positive!\") # Proceed with the function using `x`... If your restrictions on the argument's value are more complicated, you can combine boolean expressions with and , or , and not , and/or you can use a multi-clause if/elif/\u2026 construct. If you need to check multiple arguments, just put the checks one after another in the function body. If more than one is invalid, only the first will be caught, but that's usually enough for the user to make progress. By the way, a slightly shorter and quicker way to accomplish this is to use the assert statement introduced earlier. For example: def demo_function(x): \"\"\" A function that requires `x` to be a positive number. \"\"\" assert x > 0, \"x must be positive!\" # Proceed with the function using `x`... The only significant practical difference here is that the user sees AssertionError instead of ValueError . That probably doesn't matter if a human gets the message, but sometimes the calling code will be written to \"catch\" certain errors and respond automatically. Philosophically, however, programmers generally see assertions (using assert ) as safety-checks inside their code that should never raise an error unless something has gone wrong inside the program, whereas exceptions (using raise ) are for when the user or external code has done something wrong. For the purposes of this course, I'll try to be explicit when an assigment cares what type of exception gets raised; otherwise, do as you see fit.","title":"Flavor B: Value Checking"},{"location":"recipes/core/functions/safety-check/#examples","text":"Here's an example illustrating a common situation: a function requires an integer for something, such as the number of times to repeat something \u2014 a random choice, a time-step in a dynamical simulation, etc. The user might plausibly want to pass very large numbers: ten thousand, a million, five million, whatever. The problem is that python interprets scientific notation such as 1e4 , 1e6 , and 5e6 as floating-point values, not integers. If you don't check for this and do the following, your user will get annoyed: def average_of_N(N): \"\"\" Generates a random number by a call to `roll_die` (whose definition is not shown here), `N` times, and returns the average of all the values. \"\"\" sum = 0 for i in range(N): sum += roll_die() return sum / N (We haven't formally introduced for -loop iteration or the range function yet. I'm assuming you've seen enough python to be able to interpret it.) Here's an example of the problem: >>> average_of_N(10_000) 3.5042 >>> average_of_N(1e4) --------------------------------------------------------------------------- TypeError Traceback (most recent call last) Cell In[6], line 1 ----> 1 average_of_N(1e5) Cell In[1], line 7, in average_of_N(N) 2 \"\"\" Generates a random number by a call to `roll_die` (whose definition 3 is not shown here), `N` times, and returns the average of all the 4 values. 5 \"\"\" 6 sum = 0 ----> 7 for i in range(N): 8 sum += roll_die() 9 return sum / N TypeError: 'float' object cannot be interpreted as an integer The solution is simple, once you understand the problem: def average_of_N(N): \"\"\" Generates a random number by a call to `roll_die` (whose definition is not shown here), `N` times, and returns the average of all the values. \"\"\" N = int(N) sum = 0 for i in range(N): sum += roll_die() return sum / N Now, the function works as expected: >>> average_of_N(1e4) 3.4865 We still have a problem, however: >>> average_of_N(-1e4) -0.0 We didn't get an error, but we did get a nonsensical result. If that function call were being made by other code, and its value used in some larger calculation, we might never realize that the nonsensical value was causing the calculation to be incorrect. The problem, of course, it makes no sense to average something a negative number of times. We can fix this with a simple check: def average_of_N(N): \"\"\" Generates a random number by a call to `roll_die` (whose definition is not shown here), `N` times, and returns the average of all the values. \"\"\" N = int(N) assert N > 0, \"N must be positive!\" sum = 0 for i in range(N): sum += roll_die() return sum / N Now: >>> average_of_N(-1e4) --------------------------------------------------------------------------- AssertionError Traceback (most recent call last) Cell In[14], line 1 ----> 1 average_of_N(-1e4) Cell In[13], line 7, in average_of_N(N) 2 \"\"\" Generates a random number by a call to `roll_die` (whose definition 3 is not shown here), `N` times, and returns the average of all the 4 values. 5 \"\"\" 6 N = int(N) ----> 7 assert N > 0, \"N must be positive!\" 8 sum = 0 9 for i in range(N): AssertionError: N must be positive! Get the idea? It's not hard; it just takes a bit of discipline to stop and ask, while writing a function, \"What argument types or values are legitimate here? Will it break things or cause erroneous results if an invalid argument is provided? Maybe I better toss in a couple of lines of code just to be safe.\"","title":"Examples"},{"location":"recipes/core/functions/writing-functions/","text":"Write Your Own Function Problem to Solve I want to easily reuse a particular calculation multiple times, with different givens. Introduction IMHO, the biggest challenge facing coders of any level, writing code for any kind of application, is managing the complexity of the task. In any program beyond the truly trivial (or larger software ecosystem!), there is simply more going on \u2014 more bits of functionality, more state information to track, more causal interconnections \u2014 than any human being can hold in their head. Without some powerful methodologies for managing the complexity, the task can be nearly impossible; and even if one completes a program that seems to work, it's really hard to be confident it's bug-free and reliable. Defining your own functions that wrap up well-defined chunks of functionality into reusable units is one of the most powerful tools programmers have devised to deal with this. The basic idea is that one takes a sub-task of manageable complexity and writes code to accomplish it, in a way that is as decoupled from the rest of the larger problem as possible. That chunk of code is packaged in such a way that other code can refer to it and use it as a single python expression \u2014 a \"function\". In that way, once the function has been written and tested, the programmer can forget about the complexity it encapsulates, and for cognitive load purposes it becomes a single \"thing\". Here's an example: How do you think the computer calculates, say, math.sin(0.143) when you put that into your program? Deep in the code for the math module is a function definition that instructs the computer to calculate a fairly complicated series approximation to the sine, with lots of logic to accurately and efficiently handle edge cases like very tiny angles. Do you really want to have to think about all of that every time you need to take the sine of something? Nope\u2026 Okay, enough philosophy. Let's get to the nuts-and-bolts. Recipe Step 1: Define The Function Before your code can use a function, it has to define a function. If you want do_thing(3) to mean something to the python interpreter when it encounters that expression, you first have to send code to the interpreter that tells it what that expression means. This is the template for a function definition : def function_name(arg_1, arg_2, \u2026): \"\"\" Here goes a descriptive comment telling a human reader what the function does, including what the various arguments will affect and what kind of value it will return. \"\"\" pass # REPLACE this with the code that will implement your function's pass # behavior, in as many or few lines as is required. return result_to_return # Other code that follows here is NOT part of the function. Notes: The first line, beginning with def , is called the function signature . It specifies everything that client code \u2014 code that uses this function \u2014 needs to know about how to call it. Replace function_name with a name for your function that communicates, fairly clearly, what the function's purpose is. In python, function names must follow the same rules as variable names: They must start with a letter, and consist only of letters, digits, and the underscore character. (Technically, the first character can be an underscore, but the python convention reserves this for special-purpose functions we don't need to get into here.) Python culture goes farther, recommending that function names begin with lowercase letters and use \"snake_case\", (an underscore between words) rather than \"camelCase\" (capital letter to start new words). Replace arg_1, arg_2, \u2026 with a comma-separated list of arguments that will be given specific values when the function is called (used, executed). The names you put here will become variables \"holding\" those values that the body of the function can refer to. The names you use here can be different than whatever variables \"outside the function\" might be used to hand value to the function. Code inside the function shouldn't care about the details of code outside the function, and vice-versa. A function can specify that it wants no arguments, or one, or two, or more\u2026 Or it can even be flexible in how many it requires (see below). The descriptive comment just below the function signature line is called the docstring . The docstring is optional, but it's worth writing. Someone else trying to figure out your code, or maybe even future you, will be very glad you took the time. It's really good habit to write this comment FIRST, before you start writing the actual code. That can help you clarify in your own mind what, precisely, the function should do. BTW, the triple-quotes bound a special kind of string literal that can span multiple lines. Other than the line breaks, it's just a normal string, like \"blah blah\" . In python, indentation matters! The only thing telling the python interpreter which subsequent lines belong to the function definition and which are part of some other, subsequent code is the fact that the body of the function is indented, and all by the same amount. Warning: multiple space characters may look like the same indentation as a tab character, but are not the same as far as the python interpreter is concerned. Fortunately, most modern code editors will proactively replace tabs with spaces for you, protecting you from this potentially infuriating source of mystery errors. The code in the function body is not evaluated when the function definition is sent to the interpreter! Rather, it is stashed, and is later executed when the function is called (used) by other code, using whatever argument values have been specified at that time. Replace result_to_return with an expression that will evaluate to the result you want your function to return to whatever code called it. You can replace result_to_return with the name of a variable that is defined and given a value in the function. Alternatively, you can replace it with an expression that will be evaluated when the value is to be returned. It's even possible for a function to have no body at all other than the return line, and still be useful if that return line contains a calculation. Some functions don't return anything, but have some desirable side effect such as writing data to a file or printing text to the screen. Those can either return None or have no return line at all. Step 2: Call the Function Once your code has defined a function, any code that is subsequently executed can call (use) it simply by giving its name, followed by parentheses containing a list of values to be passed to the function's arguments: some_variable = function_name(value_1, value_2, \u2026) different_function( function_name(other_value_1, other_value_2, \u2026) ) Note a critical difference: In python, function_name by itself is a reference to the function's code, whereas function_name(\u2026) causes the function to execute (whether or not the parentheses are empty). The presence of the parentheses are the trigger that says \"execute this\". Black-belt tidbit: In python, you can pass a function around as an object, just like you can with a variable, by using its name without parentheses. The function's body is its \"value\" in the way that a number or string is a regular variable's value. That means you can actually pass a function as an argument to another function, and that other function can execute the one it's been given without knowing what it actually does! This is called a callback , and is a very useful technique for \"decoupling\" different portions of a code. In essence, it lets you pass \"actions\" around in the same way that you pass \"values\" around. Elaboration: Return Multiple Values A recipe can easily return two or three (or, in principle, more) separate values via the \"comma trick\": def function_name(some_arg): \"\"\" Template for a function that returns two values \"\"\" pass # Calculate result_1 and result_2 in some way. return result_1, result_2 To catch them, calling code also uses the comma trick: thing_1, thing_2 = function_name(val_for_some_arg) Notes: Technically, the function only returning one \"value\", but that value is something called a tuple that packages multiple values together. The comma-separated list on the left-hand side of the calling code's assignment statement unpacks the tuple into separate variables. We'll look at tuples more closely in an upcoming level. There is, in principle, no limit to the number of values a function can return this way. However, if you're going to return more than two or three, you're probably better off wrapping them in one of python's collections , which are the focus of two upcoming levels. Similarly, if the function needs to be flexible about how many values to return, the comma trick won't suffice and you'll need a collection object. Some Examples These examples are pretty trivial, mostly because we haven't yet introduced the python structures (such as conditional logic and iteration) that get used in more complicated ones. Please take them in that spirit. No Arguments Functions that take no arguments are uncommon, but are occasionally convenient. For example: from random import randint def roll_3d6(): \"\"\" Simulate rolling three six-sided dice and return the sum. \"\"\" return randint(1, 6) + randint(1, 6) + randint(1, 6) One Argument from math import degrees def degrees_bounded(angle_in_rad): \"\"\" Convert the given angle in radians to degrees, within the range [0, 360). Angles 360\u02da or greater get mapped to the equivalent angle within the first revolution, and negative angles get mapped to the equivalent positive angle. \"\"\" return degres(angle) % 360 Two Arguments def kinetic_energy(m, v): \"\"\" Calculate the kinetic energy of an object with the given mass and velocity. \"\"\" return 0.5 * mass * velocity**2 Multiple Return Values def cartesian_to_polar(x, y): \"\"\" Converts the given 2D Cartesian coordinates to polar coordinates. Returns the polar coordinates as (r, theta) with theta in radians. \"\"\" r = math.sqrt(x**2 + y**2) theta = math.atan2(y, x) return r, theta Note: This function body could be rewritten as a one-liner, def cartesian_to_polar(x, y): \"\"\" Converts the given 2D Cartesian coordinates to polar coordinates. Returns the polar coordinates as (r, theta) with theta in radians. \"\"\" return math.sqrt(x**2 + y**2), math.atan2(y, x) but sacrificing readability for brevity is rarely worthwhile.","title":"Write Your Own Function"},{"location":"recipes/core/functions/writing-functions/#write-your-own-function","text":"","title":"Write Your Own Function"},{"location":"recipes/core/functions/writing-functions/#problem-to-solve","text":"I want to easily reuse a particular calculation multiple times, with different givens.","title":"Problem to Solve"},{"location":"recipes/core/functions/writing-functions/#introduction","text":"IMHO, the biggest challenge facing coders of any level, writing code for any kind of application, is managing the complexity of the task. In any program beyond the truly trivial (or larger software ecosystem!), there is simply more going on \u2014 more bits of functionality, more state information to track, more causal interconnections \u2014 than any human being can hold in their head. Without some powerful methodologies for managing the complexity, the task can be nearly impossible; and even if one completes a program that seems to work, it's really hard to be confident it's bug-free and reliable. Defining your own functions that wrap up well-defined chunks of functionality into reusable units is one of the most powerful tools programmers have devised to deal with this. The basic idea is that one takes a sub-task of manageable complexity and writes code to accomplish it, in a way that is as decoupled from the rest of the larger problem as possible. That chunk of code is packaged in such a way that other code can refer to it and use it as a single python expression \u2014 a \"function\". In that way, once the function has been written and tested, the programmer can forget about the complexity it encapsulates, and for cognitive load purposes it becomes a single \"thing\". Here's an example: How do you think the computer calculates, say, math.sin(0.143) when you put that into your program? Deep in the code for the math module is a function definition that instructs the computer to calculate a fairly complicated series approximation to the sine, with lots of logic to accurately and efficiently handle edge cases like very tiny angles. Do you really want to have to think about all of that every time you need to take the sine of something? Nope\u2026 Okay, enough philosophy. Let's get to the nuts-and-bolts.","title":"Introduction"},{"location":"recipes/core/functions/writing-functions/#recipe","text":"","title":"Recipe"},{"location":"recipes/core/functions/writing-functions/#step-1-define-the-function","text":"Before your code can use a function, it has to define a function. If you want do_thing(3) to mean something to the python interpreter when it encounters that expression, you first have to send code to the interpreter that tells it what that expression means. This is the template for a function definition : def function_name(arg_1, arg_2, \u2026): \"\"\" Here goes a descriptive comment telling a human reader what the function does, including what the various arguments will affect and what kind of value it will return. \"\"\" pass # REPLACE this with the code that will implement your function's pass # behavior, in as many or few lines as is required. return result_to_return # Other code that follows here is NOT part of the function. Notes: The first line, beginning with def , is called the function signature . It specifies everything that client code \u2014 code that uses this function \u2014 needs to know about how to call it. Replace function_name with a name for your function that communicates, fairly clearly, what the function's purpose is. In python, function names must follow the same rules as variable names: They must start with a letter, and consist only of letters, digits, and the underscore character. (Technically, the first character can be an underscore, but the python convention reserves this for special-purpose functions we don't need to get into here.) Python culture goes farther, recommending that function names begin with lowercase letters and use \"snake_case\", (an underscore between words) rather than \"camelCase\" (capital letter to start new words). Replace arg_1, arg_2, \u2026 with a comma-separated list of arguments that will be given specific values when the function is called (used, executed). The names you put here will become variables \"holding\" those values that the body of the function can refer to. The names you use here can be different than whatever variables \"outside the function\" might be used to hand value to the function. Code inside the function shouldn't care about the details of code outside the function, and vice-versa. A function can specify that it wants no arguments, or one, or two, or more\u2026 Or it can even be flexible in how many it requires (see below). The descriptive comment just below the function signature line is called the docstring . The docstring is optional, but it's worth writing. Someone else trying to figure out your code, or maybe even future you, will be very glad you took the time. It's really good habit to write this comment FIRST, before you start writing the actual code. That can help you clarify in your own mind what, precisely, the function should do. BTW, the triple-quotes bound a special kind of string literal that can span multiple lines. Other than the line breaks, it's just a normal string, like \"blah blah\" . In python, indentation matters! The only thing telling the python interpreter which subsequent lines belong to the function definition and which are part of some other, subsequent code is the fact that the body of the function is indented, and all by the same amount. Warning: multiple space characters may look like the same indentation as a tab character, but are not the same as far as the python interpreter is concerned. Fortunately, most modern code editors will proactively replace tabs with spaces for you, protecting you from this potentially infuriating source of mystery errors. The code in the function body is not evaluated when the function definition is sent to the interpreter! Rather, it is stashed, and is later executed when the function is called (used) by other code, using whatever argument values have been specified at that time. Replace result_to_return with an expression that will evaluate to the result you want your function to return to whatever code called it. You can replace result_to_return with the name of a variable that is defined and given a value in the function. Alternatively, you can replace it with an expression that will be evaluated when the value is to be returned. It's even possible for a function to have no body at all other than the return line, and still be useful if that return line contains a calculation. Some functions don't return anything, but have some desirable side effect such as writing data to a file or printing text to the screen. Those can either return None or have no return line at all.","title":"Step 1: Define The Function"},{"location":"recipes/core/functions/writing-functions/#step-2-call-the-function","text":"Once your code has defined a function, any code that is subsequently executed can call (use) it simply by giving its name, followed by parentheses containing a list of values to be passed to the function's arguments: some_variable = function_name(value_1, value_2, \u2026) different_function( function_name(other_value_1, other_value_2, \u2026) ) Note a critical difference: In python, function_name by itself is a reference to the function's code, whereas function_name(\u2026) causes the function to execute (whether or not the parentheses are empty). The presence of the parentheses are the trigger that says \"execute this\". Black-belt tidbit: In python, you can pass a function around as an object, just like you can with a variable, by using its name without parentheses. The function's body is its \"value\" in the way that a number or string is a regular variable's value. That means you can actually pass a function as an argument to another function, and that other function can execute the one it's been given without knowing what it actually does! This is called a callback , and is a very useful technique for \"decoupling\" different portions of a code. In essence, it lets you pass \"actions\" around in the same way that you pass \"values\" around.","title":"Step 2: Call the Function"},{"location":"recipes/core/functions/writing-functions/#elaboration-return-multiple-values","text":"A recipe can easily return two or three (or, in principle, more) separate values via the \"comma trick\": def function_name(some_arg): \"\"\" Template for a function that returns two values \"\"\" pass # Calculate result_1 and result_2 in some way. return result_1, result_2 To catch them, calling code also uses the comma trick: thing_1, thing_2 = function_name(val_for_some_arg) Notes: Technically, the function only returning one \"value\", but that value is something called a tuple that packages multiple values together. The comma-separated list on the left-hand side of the calling code's assignment statement unpacks the tuple into separate variables. We'll look at tuples more closely in an upcoming level. There is, in principle, no limit to the number of values a function can return this way. However, if you're going to return more than two or three, you're probably better off wrapping them in one of python's collections , which are the focus of two upcoming levels. Similarly, if the function needs to be flexible about how many values to return, the comma trick won't suffice and you'll need a collection object.","title":"Elaboration: Return Multiple Values"},{"location":"recipes/core/functions/writing-functions/#some-examples","text":"These examples are pretty trivial, mostly because we haven't yet introduced the python structures (such as conditional logic and iteration) that get used in more complicated ones. Please take them in that spirit.","title":"Some Examples"},{"location":"recipes/core/functions/writing-functions/#no-arguments","text":"Functions that take no arguments are uncommon, but are occasionally convenient. For example: from random import randint def roll_3d6(): \"\"\" Simulate rolling three six-sided dice and return the sum. \"\"\" return randint(1, 6) + randint(1, 6) + randint(1, 6)","title":"No Arguments"},{"location":"recipes/core/functions/writing-functions/#one-argument","text":"from math import degrees def degrees_bounded(angle_in_rad): \"\"\" Convert the given angle in radians to degrees, within the range [0, 360). Angles 360\u02da or greater get mapped to the equivalent angle within the first revolution, and negative angles get mapped to the equivalent positive angle. \"\"\" return degres(angle) % 360","title":"One Argument"},{"location":"recipes/core/functions/writing-functions/#two-arguments","text":"def kinetic_energy(m, v): \"\"\" Calculate the kinetic energy of an object with the given mass and velocity. \"\"\" return 0.5 * mass * velocity**2","title":"Two Arguments"},{"location":"recipes/core/functions/writing-functions/#multiple-return-values","text":"def cartesian_to_polar(x, y): \"\"\" Converts the given 2D Cartesian coordinates to polar coordinates. Returns the polar coordinates as (r, theta) with theta in radians. \"\"\" r = math.sqrt(x**2 + y**2) theta = math.atan2(y, x) return r, theta Note: This function body could be rewritten as a one-liner, def cartesian_to_polar(x, y): \"\"\" Converts the given 2D Cartesian coordinates to polar coordinates. Returns the polar coordinates as (r, theta) with theta in radians. \"\"\" return math.sqrt(x**2 + y**2), math.atan2(y, x) but sacrificing readability for brevity is rarely worthwhile.","title":"Multiple Return Values"},{"location":"recipes/core/iteration/","text":"Iteration Recipes Recipes for iterating over, looping through, and repeating stuff: Repeat Code a Specific Number of Times : I want to repeatedly execute a chunk of code, counting the repetitions. Repeat While or Until Something Is True : I want to repeatedly execute a chunk of code while or until some condition is true, however many times that may be. Stop Iteration Early : Sometimes my code needs to stop iterating before a loop has reached its normal end (of the range in for , boolean termination condition in while ). Flip a Coin or Roll a Die : My code needs to randomly pick or decide something. Determine Statistics of a Sequence : I want to determine some simple statistical measures (like frequency, mean, and standard deviation) of a set of measurements, events, or data, and I don't want to store all of the individual values in memory.","title":"(Recipe List)"},{"location":"recipes/core/iteration/#iteration-recipes","text":"Recipes for iterating over, looping through, and repeating stuff: Repeat Code a Specific Number of Times : I want to repeatedly execute a chunk of code, counting the repetitions. Repeat While or Until Something Is True : I want to repeatedly execute a chunk of code while or until some condition is true, however many times that may be. Stop Iteration Early : Sometimes my code needs to stop iterating before a loop has reached its normal end (of the range in for , boolean termination condition in while ). Flip a Coin or Roll a Die : My code needs to randomly pick or decide something. Determine Statistics of a Sequence : I want to determine some simple statistical measures (like frequency, mean, and standard deviation) of a set of measurements, events, or data, and I don't want to store all of the individual values in memory.","title":"Iteration Recipes"},{"location":"recipes/core/iteration/break/","text":"Stop Iteration Early Problem to Solve Sometimes my code needs to stop iterating before a loop has reached its normal end (of the range in for , boolean termination condition in while ). Recipe A: Early Termination of a 'for' Loop If you want a normal for loop (of any variant ), but need to stop the loop early if some logical condition <<logical_condition>> is met, you can use a break statement: for <<counter variable>> in range(<<usual range arguments>>): # Can do stuff here\u2026 if <<logical_condition>>: break # Can do more stuff here\u2026 example: repeating until some condition, with a repetition limit Here's a common use of this recipe: Let's say you're doing a calculation or simulation that involves repeating something until a logical condition is met. Examples: an approximation of a transcendental function that terminates when the change from one term to the next is below some threshold; or a simulation of a falling object that ends when it reaches the ground. Normally, you'd use a while loop to express this. However, what if you also wanted to impose a maximum number of repetitions so that the calculation couldn't take longer than you're willing to wait, or possibly even forever? The \"obvious\" approach might be to define a step-counter variable, increment it every time through the loop, and check it in the while loop's condition along with the normal condition, like this: t, t_max = 0, 1e6 x_max = 100 while (x < x_max and y > 0 and t < t_max): x, y = ... # Calculation that updates coordinates. t += 1 This involves some extra cruft, and gives the repetition limit \u2014 a \"by the way, just in case\" aspect of the code \u2014 on the same visual level of importance as the \"real\" physics or math. And it also gives no indication of why the loop ended. Here's a better way: t, t_max = 0, 1e6 x_max = 100 for t in range(int(t_max)): x, y = ... # Calculation that updates coordinates. if x >= x_max: print(\"Reached the far wall.\") break if y <= 0: print(\"Hit the ground.\") break Recipe B: Early Termination of a 'while' Loop The while loop can also be terminated early with a break statement, rather than \"normally\" when the condition on the while line ceases to be true. This might seem unnecessary, since any \"extra\" logical condition that can trigger a break can also be included in the while loop's condition with an and not ... . However, including a separate break statement might be preferable under a few circumstances: The \"extra\" logical condition is complex, and you want to keep the while loop's condition simple and readable. The \"extra\" logical condition is for an occasional case, and you don't want it to have the same visual importance as the \"normal\" condition. The natural place to check the \"extra\" condition and possibly terminate the loop is in the middle of the loop's body, rather than at the beginning or end. Here's the recipe: while <<normal condition>>: # Can do stuff here\u2026 if <<other condition>>: break # Can do more stuff here\u2026 The example following the next recipe illustrates this. Recipe C: Doing Something Only After Normal Loop Completion In some situations, you'll want your code to execute something after a loop has completed, but only if it ran to its normal completion rather than being terminated early by a break statement. Python has an easy (and rather unusual and syntactically confusing) way to do this. Just like an if block, a for or while block can be followed by an else block. However, the meaning is totally different: After an if block, an else block says \"do this bit if the if condition was false and the if block didn't execute. After a for or while block, an else block says \"do this bit if the loop ran to its normal completion and wasn't terminated by a break statement.\" Yeah, using the word \"else\" seems like a weird and non-intuitive choice. My guess is that someone decided to piggyback on the existing keyword, rather than having to introduce a new one like conclusion . (But, python has a keyword finally that could have been borrowed, so \ud83e\udd37\u200d\u2642\ufe0f.) Here's the recipe for a for loop: for <<counter variable>> in range(<<usual range arguments>>): # Can do stuff here\u2026 if <<logical_condition>>: break # Can do more stuff here\u2026 else: # Do this if the loop reached the end of the specified range, but not # if it was terminated by `<<logical_condition>>`. And for a while loop: while <<normal condition>>: # Can do stuff here\u2026 if <<other condition>>: break # Can do more stuff here\u2026 else: # Do this only if the loop stopped when `<<normal condition>>` became False, # not because `<<other condition>>` became True. Yes, you could accomplish this without the else , by using an if block after the loop that checks variable values to figure out which condition caused the loop to end. But why would you want to? That just forces you to include redundant logic, and introduces one more place for a bug to occur. example: guessing game Yeah, this one is a bit silly, but it shows the idea. import random def guess_the_number(max_value = 10): secret_number = random.randint(1, max_value) print(f\"I'm thinking of a number between 1 and {max_value} inclusive. Can you guess it?\") print(\"Enter `0` if you want to give up.\") guess = int(input(\" Your guess: \")) while guess != secret_number: guess = int(input(\" Nope! Try again: \")) if guess == 0: print(\"Too bad. \ud83d\ude22\") break else: print(\"You got it! \ud83c\udf89\") Recipe B: Early Termination of a 'while' Loop The while loop can also be terminated early with a break statement, rather than \"normally\" when the condition on the while line ceases to be true. This might seem unnecessary, since any \"extra\" logical condition that can trigger a break can also be included in the while loop's condition with an and not ... . However, including a separate break statement might be preferable under a few circumstances: The \"extra\" logical condition is complex, and you want to keep the while loop's condition simple and readable. The \"extra\" logical condition is for an occasional case, and you don't want it to have the same visual importance as the \"normal\" condition. The natural place to check the \"extra\" condition and possibly terminate the loop is in the middle of the loop's body, rather than at the beginning or end. Here's the recipe: while <<normal condition>>: # Can do stuff here\u2026 if <<other condition>>: break # Can do more stuff here\u2026 The example following the next recipe illustrates this. Recipe D: Skipping to the Next Iteration Occasionally, you'll come across a situation where a loop should skip over the remainder of one iteration and start the next one. You can accomplish this by putting the part that you might need to skip over into the body of an if block, but there's a cleaner way: the continue statement. It can be used in either a for or a while loop. for <<counter variable>> in range(<<usual range arguments>>): # Can do stuff here\u2026 if <<skip condition>>: continue # Put code here that should only run if the skip condition is False. while <condition to continue>>: # Can do stuff here\u2026 if <<skip condition>>: continue # Put code here that should only run if the skip condition is False. Without continue , this would look like: for <<counter variable>> in range(<<usual range arguments>>): # Can do stuff here\u2026 if not <<skip condition>>: # Put code here that should only run if the skip condition is False. What are the advantages of using continue ? Readability: The code very clearly says \"My intention is to skip ove the rest of the loop body if this condition is met.\" Flatness: It avoids nesting the rest of the code one level deeper. If that code is fairly complex, with its own conditional logic and loops and other nested bits, every level of nesting you can avoid is a win.","title":"Stop Iteration Early"},{"location":"recipes/core/iteration/break/#stop-iteration-early","text":"","title":"Stop Iteration Early"},{"location":"recipes/core/iteration/break/#problem-to-solve","text":"Sometimes my code needs to stop iterating before a loop has reached its normal end (of the range in for , boolean termination condition in while ).","title":"Problem to Solve"},{"location":"recipes/core/iteration/break/#recipe-a-early-termination-of-a-for-loop","text":"If you want a normal for loop (of any variant ), but need to stop the loop early if some logical condition <<logical_condition>> is met, you can use a break statement: for <<counter variable>> in range(<<usual range arguments>>): # Can do stuff here\u2026 if <<logical_condition>>: break # Can do more stuff here\u2026","title":"Recipe A: Early Termination of a 'for' Loop"},{"location":"recipes/core/iteration/break/#example-repeating-until-some-condition-with-a-repetition-limit","text":"Here's a common use of this recipe: Let's say you're doing a calculation or simulation that involves repeating something until a logical condition is met. Examples: an approximation of a transcendental function that terminates when the change from one term to the next is below some threshold; or a simulation of a falling object that ends when it reaches the ground. Normally, you'd use a while loop to express this. However, what if you also wanted to impose a maximum number of repetitions so that the calculation couldn't take longer than you're willing to wait, or possibly even forever? The \"obvious\" approach might be to define a step-counter variable, increment it every time through the loop, and check it in the while loop's condition along with the normal condition, like this: t, t_max = 0, 1e6 x_max = 100 while (x < x_max and y > 0 and t < t_max): x, y = ... # Calculation that updates coordinates. t += 1 This involves some extra cruft, and gives the repetition limit \u2014 a \"by the way, just in case\" aspect of the code \u2014 on the same visual level of importance as the \"real\" physics or math. And it also gives no indication of why the loop ended. Here's a better way: t, t_max = 0, 1e6 x_max = 100 for t in range(int(t_max)): x, y = ... # Calculation that updates coordinates. if x >= x_max: print(\"Reached the far wall.\") break if y <= 0: print(\"Hit the ground.\") break","title":"example: repeating until some condition, with a repetition limit"},{"location":"recipes/core/iteration/break/#recipe-b-early-termination-of-a-while-loop","text":"The while loop can also be terminated early with a break statement, rather than \"normally\" when the condition on the while line ceases to be true. This might seem unnecessary, since any \"extra\" logical condition that can trigger a break can also be included in the while loop's condition with an and not ... . However, including a separate break statement might be preferable under a few circumstances: The \"extra\" logical condition is complex, and you want to keep the while loop's condition simple and readable. The \"extra\" logical condition is for an occasional case, and you don't want it to have the same visual importance as the \"normal\" condition. The natural place to check the \"extra\" condition and possibly terminate the loop is in the middle of the loop's body, rather than at the beginning or end. Here's the recipe: while <<normal condition>>: # Can do stuff here\u2026 if <<other condition>>: break # Can do more stuff here\u2026 The example following the next recipe illustrates this.","title":"Recipe B: Early Termination of a 'while' Loop"},{"location":"recipes/core/iteration/break/#recipe-c-doing-something-only-after-normal-loop-completion","text":"In some situations, you'll want your code to execute something after a loop has completed, but only if it ran to its normal completion rather than being terminated early by a break statement. Python has an easy (and rather unusual and syntactically confusing) way to do this. Just like an if block, a for or while block can be followed by an else block. However, the meaning is totally different: After an if block, an else block says \"do this bit if the if condition was false and the if block didn't execute. After a for or while block, an else block says \"do this bit if the loop ran to its normal completion and wasn't terminated by a break statement.\" Yeah, using the word \"else\" seems like a weird and non-intuitive choice. My guess is that someone decided to piggyback on the existing keyword, rather than having to introduce a new one like conclusion . (But, python has a keyword finally that could have been borrowed, so \ud83e\udd37\u200d\u2642\ufe0f.) Here's the recipe for a for loop: for <<counter variable>> in range(<<usual range arguments>>): # Can do stuff here\u2026 if <<logical_condition>>: break # Can do more stuff here\u2026 else: # Do this if the loop reached the end of the specified range, but not # if it was terminated by `<<logical_condition>>`. And for a while loop: while <<normal condition>>: # Can do stuff here\u2026 if <<other condition>>: break # Can do more stuff here\u2026 else: # Do this only if the loop stopped when `<<normal condition>>` became False, # not because `<<other condition>>` became True. Yes, you could accomplish this without the else , by using an if block after the loop that checks variable values to figure out which condition caused the loop to end. But why would you want to? That just forces you to include redundant logic, and introduces one more place for a bug to occur.","title":"Recipe C: Doing Something Only After Normal Loop Completion"},{"location":"recipes/core/iteration/break/#example-guessing-game","text":"Yeah, this one is a bit silly, but it shows the idea. import random def guess_the_number(max_value = 10): secret_number = random.randint(1, max_value) print(f\"I'm thinking of a number between 1 and {max_value} inclusive. Can you guess it?\") print(\"Enter `0` if you want to give up.\") guess = int(input(\" Your guess: \")) while guess != secret_number: guess = int(input(\" Nope! Try again: \")) if guess == 0: print(\"Too bad. \ud83d\ude22\") break else: print(\"You got it! \ud83c\udf89\")","title":"example: guessing game"},{"location":"recipes/core/iteration/break/#recipe-b-early-termination-of-a-while-loop_1","text":"The while loop can also be terminated early with a break statement, rather than \"normally\" when the condition on the while line ceases to be true. This might seem unnecessary, since any \"extra\" logical condition that can trigger a break can also be included in the while loop's condition with an and not ... . However, including a separate break statement might be preferable under a few circumstances: The \"extra\" logical condition is complex, and you want to keep the while loop's condition simple and readable. The \"extra\" logical condition is for an occasional case, and you don't want it to have the same visual importance as the \"normal\" condition. The natural place to check the \"extra\" condition and possibly terminate the loop is in the middle of the loop's body, rather than at the beginning or end. Here's the recipe: while <<normal condition>>: # Can do stuff here\u2026 if <<other condition>>: break # Can do more stuff here\u2026 The example following the next recipe illustrates this.","title":"Recipe B: Early Termination of a 'while' Loop"},{"location":"recipes/core/iteration/break/#recipe-d-skipping-to-the-next-iteration","text":"Occasionally, you'll come across a situation where a loop should skip over the remainder of one iteration and start the next one. You can accomplish this by putting the part that you might need to skip over into the body of an if block, but there's a cleaner way: the continue statement. It can be used in either a for or a while loop. for <<counter variable>> in range(<<usual range arguments>>): # Can do stuff here\u2026 if <<skip condition>>: continue # Put code here that should only run if the skip condition is False. while <condition to continue>>: # Can do stuff here\u2026 if <<skip condition>>: continue # Put code here that should only run if the skip condition is False. Without continue , this would look like: for <<counter variable>> in range(<<usual range arguments>>): # Can do stuff here\u2026 if not <<skip condition>>: # Put code here that should only run if the skip condition is False. What are the advantages of using continue ? Readability: The code very clearly says \"My intention is to skip ove the rest of the loop body if this condition is met.\" Flatness: It avoids nesting the rest of the code one level deeper. If that code is fairly complex, with its own conditional logic and loops and other nested bits, every level of nesting you can avoid is a win.","title":"Recipe D: Skipping to the Next Iteration"},{"location":"recipes/core/iteration/for/","text":"Repeat Code a Specific Number of Times Problem to Solve I want to repeatedly execute a chunk of code, counting the repetitions. Background Knowledge two ways of iterating Python has two basic ways of iterating over (i.e., repeatedly executing) a chunk of code: Applying the code to every element of an ordered collection (\"iterable\") of things, or Executing the code over and over as long as some logical condition is true. This recipe focuses on the first. (We'll get to the other soon.) It's useful for situations like: I want to repeat something a specific number of times. I want to do something with every number from \\(A\\) to \\(B\\) . I want to do something with every element of a sequence of things. adjusting to python from from other languages If you come to python from another programming language, this will likely trip you up: Python's for loop does not work like the for loop in many other, older programming languages like C and Java . You can make it work like theirs' but you often shouldn't. Python's way is better . Here's the essential difference: In many languages, a for loop is a mechanism for iterating while incrementing a counter variable. In python, a for loop is a mechanism for iterating through the elements of an ordered collection of things. All languages have ways of achieving the same thing, and some (like JavaScript) have an equivalent .forEach method on arrays. It's usually clumsier than python's though. Some newer languages, like Julia , Swift , and Rust , have adopted python's approach to for . If you are not aware of this difference, you will try to make python behave like Java or C, and will end up with unnecessarily ugly, clumsy, un-pythonic code. Base Recipe: Counting From Zero If you want to count the iterations, perhaps so that you can use the iteration number in a calculation, here's the recipe: for i in range(N + 1): # Anything in here will be executed N times, with values of i successively # equal to 0, 1, 2, ..., N The name i is fairly traditional in programming to represent an iteration number. However, if the counter has meaning in your code, I suggest picking something more descriptive, such as row_num (for successive rows in a table), particle (for successive particles in a physics calculation), or power (for successive powers of a number). Pick something that will make the code easier to interpret. How does this recipe work? We haven't talked in detail about collections yet, but here's the basic idea: the built-in python function range(limit) produces a sequence of integers, beginning with 0 and ending with the last integer before limit . For example, range(5) produces the sequence 0, 1, 2, 3, 4 . Note that the value of the \"upper limit\" argument is not itself included in the sequence produced! Forgetting that range begins withy 0 (not 1) and ends with limit - 1 (not limit ) is a common source of bugs in python code. Remember it this way: 1. In python, we always count from 0 unless explicitly told otherwise. 2. range(N) produces a N-element count. 3. So, in python, N elements are counted 0 , 1 , 2 , ..., N-1 . Recipe Variant A: Just Repeating Some Number of Times If you want to repeat a chunk of code \\(N\\) times but don't need the code to know which iteration it's on, you can do exactly the same thing, and just ignore the counter variable i or whatever you've called it. However, python programmers have a convention for naming variables that are not intended to be used: the underscore character, _ . So, to repeat something \\(N\\) times without numbering the iterations, use this: for _ in range(N): # Code in here will be repeated N times. The use of _ immediately tells a reader not to worry about whether or how the counter index is being used, and that this is a simple \\(N\\) -times-through repetition. example Here's a function that creates a one-dimensional fractal by repetition. It begins with the simple pattern \u2588 \u2588 . Every iteration, it replaces all \u2588 characters with the initial pattern of \u2588 \u2588 , and replaces all space characters with a block of three spaces. Thus, in each iteration, the length of the string triples. Imagine that instead of growing the length of the string, you're \"zooming in\" and seeing that each apparently-full cell actually has a hole in it. This is the essence of a fractal : Self-similarity at different scales. def fractal_string(depth): \"\"\" Generates a string of `X` and ` ` characters with a fractal density structure. \"\"\" full_cell = '\u2588 \u2588' empty_cell = ' ' s = full_cell for _ in range(depth): s = s.replace(' ', '~') s = s.replace('\u2588', full_cell) s = s.replace('~', empty_cell) return s Copy-paste it into an IPython console (or script) and play with it! (It looks better if you go to a really small font size or zoom level, so that you can get more characters on one output line.) Note: I'm omitting the usual safety-checks on arguments so you can focus on the point of the recipe. In real code, I'd convert n_max to an integer and make sure both arguments had meaningful values. Recipe Variant B: Counting From One (or something else) The range function has an optional argument that lets you specify the starting value of the sequence. Note that it comes before the required endpoint argument: for n in range(first_val, stop_before): # Anything in here will be executed N times, with values of in successively # equal to first_val, first_val + 1, first_val + 2, ..., stop_before - 1 Again, take note: the sequence of values will include the first value but exclude the second value . As a result, the number of iterations will always be last_val - stop_before . example If a biased coin lands on \"heads\" with probability \\(p\\) , the probability of obtaining \\(N\\) heads in a row is \\(p^N\\) . Here's a function that displays the probability of increasingly long strings of heads: def heads_runs(p, n_max): \"\"\" Displays the probability of obtaining successively longer runs of \"heads\" with a biased coin whose probability of landing on \"heads\" in any given flip is `p`. `n_max` sets the longest run considered. \"\"\" for n in range(1, n_max + 1): print(f\"Probability of {n:2} heads in a row: {p**n:.2%}.\") Recipe Variant C: Counting by Steps The range function has a third optional argument that lets you specify the step size of the sequence. This can be used to count by twos, threes, or any other integer increment: for val in range(first_val, stop_before, step_size): # Anything in here will be executed repeatedly times with values of val # successively equal to first_val, first_val + step_size, # first_val + 2 * step_size, ..., What will the last value be? That depends on how many multiples of the step size fit in before reaching the stop_before value. Python will continue iterating until adding another value of step_size would reach or exceed stop_before , and will then cease. Recipe Variant D: Counting Down Counting downwards is as easy as specifying a negative step size, and choosing a larger starting value than the stopping value: for count in range(start_val, stop_before, -step_size): # Code here will execute repeatedly, with values of count starting at # start_val and decreasing by step_size each time, stopping just before # reaching or going past stop_before. example: countdown with changing interval Want to write code for NASA Mission Control? import time from IPython import get_ipython def countdown(starting_time): \"\"\" Counts down in real-time, announcing every ten seconds until ten seconds are left, and then every second. If the starting time is greater than 10 s, it is rounded up to the nearest multiple of 10 seconds. \"\"\" get_ipython().run_line_magic(\"clear\", \"\") if (starting_time > 10) and (starting_time % 10 != 0): starting_time += 10 - starting_time % 10 if starting_time >= 20: for t in range(starting_time, 10, -10): print(f\" Launch in T minus {t} seconds\") time.sleep(10) print(\" Launch in \", end=\"\") for t in range(min(10, starting_time), 0, -1): print(f\"{t}\u2026 \", end=\"\") time.sleep(1) print(\"\\n\ud83d\ude80\ud83d\ude80\ud83d\ude80 BLASTOFF!!! \ud83d\ude80\ud83d\ude80\ud83d\ude80\") Recipe Variant E: Counting by Non-Integer Steps Alas, the range() function only works with integers. If you need to count by non-integer steps, you have three options: Count by integers, but multiply the counter variable by some fractional step size when you use it. This works if you want to count by regular steps that can be easily obtained from an integer sequence. Use a while loop (coming in a recipe soon) and do all the initializing, incrementing, and endpoint-testing yourself. This is very flexible, but puts the work on you instead of on python, and can be more error-prone. Use features similar to range from the numpy library, which we'll cover in a future unit. This will generally be your best bet, once you've learned that skillset. example For those of you taking special relativity in PHY 321: What are the values of gamma for speeds of 0, 0.05c, 0.1c, ..., c? from math import sqrt def gamma(): \"\"\" Display the values of the Lorentz factor \"gamma\" for velocities from zero up to 1 (in SR units), showing every increment of 0.1. \"\"\" for d in range(0, 100, 5): v = d / 100 gamma = 1 / sqrt(1 - v**2) print(f\" v = {v:.2f} => gamma = {gamma:.5f}\") print(f\" v = {1:.2f} => gamma = infinite!\") Recipe Variant F: Doing Something Every N th Iteration Easy. To execute an extra bit of code every M iterations, use the modulo % operator: for i in range(1, N_reps + 1): # Code here executes every iteration. if i % M == 0: # Code here executes on the Mth, 2Mth, 3Mth, etc. iterations # (when i = M, 2M, 3M, etc.) # Code here also executes every iteration. If you want to count from zero, but still execute on the M th iteration, you'll need to adjust the test slightly to avoid triggering on the first iteration (since 0 % M is always 0): for i in range(N_reps): # Code here executes every iteration. if i % M == M - 1: # Code here executes on the Mth, 2Mth, 3Mth, etc. iterations # (when i = M-1, 2M-1, 3M-1, etc.) # Code here also executes every iteration. example: quick-and-dirty progress bar Here's a simple progress bar that updates every update_steps through a loop: print(\"Progress: 0\u2026 \", end=\"\") for n in range(1, int(1e6+1)): if n % update_steps == 0: print(f\"{n}\u2026 \", end=\"\") # Do whatever the loop is supposed to do here. print(\"done!\")","title":"Repeat Code a Specific Number of Times"},{"location":"recipes/core/iteration/for/#repeat-code-a-specific-number-of-times","text":"","title":"Repeat Code a Specific Number of Times"},{"location":"recipes/core/iteration/for/#problem-to-solve","text":"I want to repeatedly execute a chunk of code, counting the repetitions.","title":"Problem to Solve"},{"location":"recipes/core/iteration/for/#background-knowledge","text":"","title":"Background Knowledge"},{"location":"recipes/core/iteration/for/#two-ways-of-iterating","text":"Python has two basic ways of iterating over (i.e., repeatedly executing) a chunk of code: Applying the code to every element of an ordered collection (\"iterable\") of things, or Executing the code over and over as long as some logical condition is true. This recipe focuses on the first. (We'll get to the other soon.) It's useful for situations like: I want to repeat something a specific number of times. I want to do something with every number from \\(A\\) to \\(B\\) . I want to do something with every element of a sequence of things.","title":"two ways of iterating"},{"location":"recipes/core/iteration/for/#adjusting-to-python-from-from-other-languages","text":"If you come to python from another programming language, this will likely trip you up: Python's for loop does not work like the for loop in many other, older programming languages like C and Java . You can make it work like theirs' but you often shouldn't. Python's way is better . Here's the essential difference: In many languages, a for loop is a mechanism for iterating while incrementing a counter variable. In python, a for loop is a mechanism for iterating through the elements of an ordered collection of things. All languages have ways of achieving the same thing, and some (like JavaScript) have an equivalent .forEach method on arrays. It's usually clumsier than python's though. Some newer languages, like Julia , Swift , and Rust , have adopted python's approach to for . If you are not aware of this difference, you will try to make python behave like Java or C, and will end up with unnecessarily ugly, clumsy, un-pythonic code.","title":"adjusting to python from from other languages"},{"location":"recipes/core/iteration/for/#base-recipe-counting-from-zero","text":"If you want to count the iterations, perhaps so that you can use the iteration number in a calculation, here's the recipe: for i in range(N + 1): # Anything in here will be executed N times, with values of i successively # equal to 0, 1, 2, ..., N The name i is fairly traditional in programming to represent an iteration number. However, if the counter has meaning in your code, I suggest picking something more descriptive, such as row_num (for successive rows in a table), particle (for successive particles in a physics calculation), or power (for successive powers of a number). Pick something that will make the code easier to interpret. How does this recipe work? We haven't talked in detail about collections yet, but here's the basic idea: the built-in python function range(limit) produces a sequence of integers, beginning with 0 and ending with the last integer before limit . For example, range(5) produces the sequence 0, 1, 2, 3, 4 . Note that the value of the \"upper limit\" argument is not itself included in the sequence produced! Forgetting that range begins withy 0 (not 1) and ends with limit - 1 (not limit ) is a common source of bugs in python code. Remember it this way: 1. In python, we always count from 0 unless explicitly told otherwise. 2. range(N) produces a N-element count. 3. So, in python, N elements are counted 0 , 1 , 2 , ..., N-1 .","title":"Base Recipe: Counting From Zero"},{"location":"recipes/core/iteration/for/#recipe-variant-a-just-repeating-some-number-of-times","text":"If you want to repeat a chunk of code \\(N\\) times but don't need the code to know which iteration it's on, you can do exactly the same thing, and just ignore the counter variable i or whatever you've called it. However, python programmers have a convention for naming variables that are not intended to be used: the underscore character, _ . So, to repeat something \\(N\\) times without numbering the iterations, use this: for _ in range(N): # Code in here will be repeated N times. The use of _ immediately tells a reader not to worry about whether or how the counter index is being used, and that this is a simple \\(N\\) -times-through repetition.","title":"Recipe Variant A: Just Repeating Some Number of Times"},{"location":"recipes/core/iteration/for/#example","text":"Here's a function that creates a one-dimensional fractal by repetition. It begins with the simple pattern \u2588 \u2588 . Every iteration, it replaces all \u2588 characters with the initial pattern of \u2588 \u2588 , and replaces all space characters with a block of three spaces. Thus, in each iteration, the length of the string triples. Imagine that instead of growing the length of the string, you're \"zooming in\" and seeing that each apparently-full cell actually has a hole in it. This is the essence of a fractal : Self-similarity at different scales. def fractal_string(depth): \"\"\" Generates a string of `X` and ` ` characters with a fractal density structure. \"\"\" full_cell = '\u2588 \u2588' empty_cell = ' ' s = full_cell for _ in range(depth): s = s.replace(' ', '~') s = s.replace('\u2588', full_cell) s = s.replace('~', empty_cell) return s Copy-paste it into an IPython console (or script) and play with it! (It looks better if you go to a really small font size or zoom level, so that you can get more characters on one output line.) Note: I'm omitting the usual safety-checks on arguments so you can focus on the point of the recipe. In real code, I'd convert n_max to an integer and make sure both arguments had meaningful values.","title":"example"},{"location":"recipes/core/iteration/for/#recipe-variant-b-counting-from-one-or-something-else","text":"The range function has an optional argument that lets you specify the starting value of the sequence. Note that it comes before the required endpoint argument: for n in range(first_val, stop_before): # Anything in here will be executed N times, with values of in successively # equal to first_val, first_val + 1, first_val + 2, ..., stop_before - 1 Again, take note: the sequence of values will include the first value but exclude the second value . As a result, the number of iterations will always be last_val - stop_before .","title":"Recipe Variant B: Counting From One (or something else)"},{"location":"recipes/core/iteration/for/#example_1","text":"If a biased coin lands on \"heads\" with probability \\(p\\) , the probability of obtaining \\(N\\) heads in a row is \\(p^N\\) . Here's a function that displays the probability of increasingly long strings of heads: def heads_runs(p, n_max): \"\"\" Displays the probability of obtaining successively longer runs of \"heads\" with a biased coin whose probability of landing on \"heads\" in any given flip is `p`. `n_max` sets the longest run considered. \"\"\" for n in range(1, n_max + 1): print(f\"Probability of {n:2} heads in a row: {p**n:.2%}.\")","title":"example"},{"location":"recipes/core/iteration/for/#recipe-variant-c-counting-by-steps","text":"The range function has a third optional argument that lets you specify the step size of the sequence. This can be used to count by twos, threes, or any other integer increment: for val in range(first_val, stop_before, step_size): # Anything in here will be executed repeatedly times with values of val # successively equal to first_val, first_val + step_size, # first_val + 2 * step_size, ..., What will the last value be? That depends on how many multiples of the step size fit in before reaching the stop_before value. Python will continue iterating until adding another value of step_size would reach or exceed stop_before , and will then cease.","title":"Recipe Variant C: Counting by Steps"},{"location":"recipes/core/iteration/for/#recipe-variant-d-counting-down","text":"Counting downwards is as easy as specifying a negative step size, and choosing a larger starting value than the stopping value: for count in range(start_val, stop_before, -step_size): # Code here will execute repeatedly, with values of count starting at # start_val and decreasing by step_size each time, stopping just before # reaching or going past stop_before.","title":"Recipe Variant D: Counting Down"},{"location":"recipes/core/iteration/for/#example-countdown-with-changing-interval","text":"Want to write code for NASA Mission Control? import time from IPython import get_ipython def countdown(starting_time): \"\"\" Counts down in real-time, announcing every ten seconds until ten seconds are left, and then every second. If the starting time is greater than 10 s, it is rounded up to the nearest multiple of 10 seconds. \"\"\" get_ipython().run_line_magic(\"clear\", \"\") if (starting_time > 10) and (starting_time % 10 != 0): starting_time += 10 - starting_time % 10 if starting_time >= 20: for t in range(starting_time, 10, -10): print(f\" Launch in T minus {t} seconds\") time.sleep(10) print(\" Launch in \", end=\"\") for t in range(min(10, starting_time), 0, -1): print(f\"{t}\u2026 \", end=\"\") time.sleep(1) print(\"\\n\ud83d\ude80\ud83d\ude80\ud83d\ude80 BLASTOFF!!! \ud83d\ude80\ud83d\ude80\ud83d\ude80\")","title":"example: countdown with changing interval"},{"location":"recipes/core/iteration/for/#recipe-variant-e-counting-by-non-integer-steps","text":"Alas, the range() function only works with integers. If you need to count by non-integer steps, you have three options: Count by integers, but multiply the counter variable by some fractional step size when you use it. This works if you want to count by regular steps that can be easily obtained from an integer sequence. Use a while loop (coming in a recipe soon) and do all the initializing, incrementing, and endpoint-testing yourself. This is very flexible, but puts the work on you instead of on python, and can be more error-prone. Use features similar to range from the numpy library, which we'll cover in a future unit. This will generally be your best bet, once you've learned that skillset.","title":"Recipe Variant E: Counting by Non-Integer Steps"},{"location":"recipes/core/iteration/for/#example_2","text":"For those of you taking special relativity in PHY 321: What are the values of gamma for speeds of 0, 0.05c, 0.1c, ..., c? from math import sqrt def gamma(): \"\"\" Display the values of the Lorentz factor \"gamma\" for velocities from zero up to 1 (in SR units), showing every increment of 0.1. \"\"\" for d in range(0, 100, 5): v = d / 100 gamma = 1 / sqrt(1 - v**2) print(f\" v = {v:.2f} => gamma = {gamma:.5f}\") print(f\" v = {1:.2f} => gamma = infinite!\")","title":"example"},{"location":"recipes/core/iteration/for/#recipe-variant-f-doing-something-every-nth-iteration","text":"Easy. To execute an extra bit of code every M iterations, use the modulo % operator: for i in range(1, N_reps + 1): # Code here executes every iteration. if i % M == 0: # Code here executes on the Mth, 2Mth, 3Mth, etc. iterations # (when i = M, 2M, 3M, etc.) # Code here also executes every iteration. If you want to count from zero, but still execute on the M th iteration, you'll need to adjust the test slightly to avoid triggering on the first iteration (since 0 % M is always 0): for i in range(N_reps): # Code here executes every iteration. if i % M == M - 1: # Code here executes on the Mth, 2Mth, 3Mth, etc. iterations # (when i = M-1, 2M-1, 3M-1, etc.) # Code here also executes every iteration.","title":"Recipe Variant F: Doing Something Every Nth Iteration"},{"location":"recipes/core/iteration/for/#example-quick-and-dirty-progress-bar","text":"Here's a simple progress bar that updates every update_steps through a loop: print(\"Progress: 0\u2026 \", end=\"\") for n in range(1, int(1e6+1)): if n % update_steps == 0: print(f\"{n}\u2026 \", end=\"\") # Do whatever the loop is supposed to do here. print(\"done!\")","title":"example: quick-and-dirty progress bar"},{"location":"recipes/core/iteration/pick/","text":"Flip a Coin or Roll a Die Problem to Solve My code needs to randomly pick or decide something. Background Knowledge: Pseudorandomness Computers are deterministic rule-following machines, and can't do things truly randomly. However, we can make them follow a sufficiently complex set of rules that are sufficiently sensitive to initial conditions that the outcome, is, for all practcal purposes, random. This is called pseudorandomness . A deep dive into that is coming later in this course. For now, we just need a way to \"flip a coin\" (perhaps a biased one) or \"roll a die\" in order to write code that can make effectively-random decisions. Recipe: Flipping a (Biased) Coin Goal: Simulate the probabilistic outcome of flipping a coin that comes up \"heads\" with probability \\(p\\) and \"tails\" with probability \\(1-p\\) . (If \\(p = 0.5\\) , we say that the coin is \"fair\". If \\(p \\neq 0.5\\) , we say that the coin is \"biased\".) For the convenience of computer code, we'll represent \"heads\" as True and \"tails\" as False . Python's random module has several useful functions. One of them is random.random() , which returns a (pseudo)random floating-point number in the range \\([0, 1)\\) . (That notation means \"from 0 to 1, including zero but not including 1\".) We can use this to simulate a coin flip by returning True if the random number is less than \\(p\\) and False otherwise. import random def flip_coin(p=0.5): return random.random() < p Easy, no? It's barely even worth wrapping up in a function. example: sequential flips How many times in a row must I flip a fair coin to get 3 heads in a row? heads_in_a_row = 0 flips = 0 while heads_in_a_row < 3: if flip_coin(): heads_in_a_row += 1 else: heads_in_a_row = 0 flips += 1 print(flips) Recipe: Rolling a Die Goal: Simulate the probabilistic outcome of rolling a fair \\(N\\) -sided die. The random module also has a function random.randint(a, b) that returns a (pseudo)random integer in the range \\([a, b]\\) . We can use this to simulate a die roll by returning a random integer in the range \\([1, N]\\) . import random def roll_die(N=6): return random.randint(1, N) example: rolling two dice How many times in a row must I roll two fair dice to get a sum of 7? sum_is_seven = False rolls = 0 while not sum_is_seven: if roll_die() + roll_die() == 7: sum_is_seven = True rolls += 1 print(rolls)","title":"Flip a Coin or Roll a Die"},{"location":"recipes/core/iteration/pick/#flip-a-coin-or-roll-a-die","text":"","title":"Flip a Coin or Roll a Die"},{"location":"recipes/core/iteration/pick/#problem-to-solve","text":"My code needs to randomly pick or decide something.","title":"Problem to Solve"},{"location":"recipes/core/iteration/pick/#background-knowledge-pseudorandomness","text":"Computers are deterministic rule-following machines, and can't do things truly randomly. However, we can make them follow a sufficiently complex set of rules that are sufficiently sensitive to initial conditions that the outcome, is, for all practcal purposes, random. This is called pseudorandomness . A deep dive into that is coming later in this course. For now, we just need a way to \"flip a coin\" (perhaps a biased one) or \"roll a die\" in order to write code that can make effectively-random decisions.","title":"Background Knowledge: Pseudorandomness"},{"location":"recipes/core/iteration/pick/#recipe-flipping-a-biased-coin","text":"Goal: Simulate the probabilistic outcome of flipping a coin that comes up \"heads\" with probability \\(p\\) and \"tails\" with probability \\(1-p\\) . (If \\(p = 0.5\\) , we say that the coin is \"fair\". If \\(p \\neq 0.5\\) , we say that the coin is \"biased\".) For the convenience of computer code, we'll represent \"heads\" as True and \"tails\" as False . Python's random module has several useful functions. One of them is random.random() , which returns a (pseudo)random floating-point number in the range \\([0, 1)\\) . (That notation means \"from 0 to 1, including zero but not including 1\".) We can use this to simulate a coin flip by returning True if the random number is less than \\(p\\) and False otherwise. import random def flip_coin(p=0.5): return random.random() < p Easy, no? It's barely even worth wrapping up in a function.","title":"Recipe: Flipping a (Biased) Coin"},{"location":"recipes/core/iteration/pick/#example-sequential-flips","text":"How many times in a row must I flip a fair coin to get 3 heads in a row? heads_in_a_row = 0 flips = 0 while heads_in_a_row < 3: if flip_coin(): heads_in_a_row += 1 else: heads_in_a_row = 0 flips += 1 print(flips)","title":"example: sequential flips"},{"location":"recipes/core/iteration/pick/#recipe-rolling-a-die","text":"Goal: Simulate the probabilistic outcome of rolling a fair \\(N\\) -sided die. The random module also has a function random.randint(a, b) that returns a (pseudo)random integer in the range \\([a, b]\\) . We can use this to simulate a die roll by returning a random integer in the range \\([1, N]\\) . import random def roll_die(N=6): return random.randint(1, N)","title":"Recipe: Rolling a Die"},{"location":"recipes/core/iteration/pick/#example-rolling-two-dice","text":"How many times in a row must I roll two fair dice to get a sum of 7? sum_is_seven = False rolls = 0 while not sum_is_seven: if roll_die() + roll_die() == 7: sum_is_seven = True rolls += 1 print(rolls)","title":"example: rolling two dice"},{"location":"recipes/core/iteration/stats/","text":"Determine Statistics of a Sequence Problem to Solve I want to determine some simple statistical measures (like frequency, mean, and standard deviation) of a set of measurements, events, or data, and I don't want to store all of the individual values in memory. Background Knowledge statistical measures A common kind of task in physics (and much of science and engineering, even social science) is to characterize the properties of a set of values that have (or at least appear to have) random variability in them. Sometimes, this comes from the inherent uncertainty in measurement. Sometimes, we use deliberate randomness in a simulation to represent variables in a complex system that we can't model deterministically. Statistics is a vast and complicated subject all in itself, and we'll barely scratch the surface of it. A few ideas and techniques, however, will get you a long way. Let's say we've got a collection of values \u2014 measurements, say \u2014 that seem to have random variability. Three questions we might reasonably want to ask are: What is the frequency (i.e, probability) that a particular outcome occurs? (That might mean the frequency of a specific value occurring, or the frequency that the value is above some threshold, or etc.) This is commonly calculated as the number of cases that meet the criterion \\(n\\) divided by the total number of cases \\(N\\) , and reported as either a decimal value between 0 and 1 or a percentage: \\[ f = \\frac{n}{N} \\] About what midpoint do the values tend to cluster? (Statisticians call this the central tendency .) We have more than one way to characterize this, but buy far the common is the mean or average : \\[ \\bar{x} = \\frac{1}{N} \\sum_{i=1}^N x_i \\] How broadly or narrowly spread are the values about this midpoint? That is, how much variability do they have? Again, multiple ways of characterizing this exist, but many are based on or related to the standard deviation of the values: \\[ \\text{SD}(x) = \\sqrt{\\frac{1}{N-1} \\sum_{i=1}^N (x_i - \\bar{x})^2} \\] Many other statistical measures exist, each with their own applications and virtues. calculating on the fly Most statistical measures, such as the three given above, are defined in a way that assumes you have the entire collection of values available to work with. This often true. When it is, by far the easiest way to calculate them is with library functions such as those in the statistics module. Sometimes, however, it's convenient or necessary to calculate these statistics in a \"running\" or \"on-the-fly\" way as you encounter the values one at a time, such that you don't need to store all of the individual values in memory. (If you're analyzing a billion particle collider events, not having to store and read a billion values can really speed things up.) Not all statistical measures can be calculated in this way, but the three given above can. frequency This one is easy: As you iterate through your cases, keep a running count of the total number \\(N\\) (unless that's already known), and another running count of the number of cases \\(n\\) that fits the criterion you want a frequency for. At the end, calculate the frequency as the ratio of the two counts: \\(f = n / N\\) . mean (average) This is slightly less obvious. The idea is that as we iterate through the values, we keep track of the average of all cases to date; and as we encounter a new value, we calculate the new average as an appropriately weighted combination of the old average and the new value. Before beginning the iteration, initialize a variable for the \"running mean\" \\(\\bar{x}\\) to zero, and another variable for the case number \\(i\\) to zero. In each step in the iteration, with each new value \\(x_i\\) , Increment the case counter \\(i \\leftarrow i + 1\\) . Calculate the difference between this value and the old running mean, \\(\\delta = x_i - \\bar{x}\\) . Update the running mean as \\(\\bar{x} \\leftarrow \\bar{x} + \\delta / i\\) . After handling the last case (value), the overall average is the last value of the running mean \\(\\bar{x}\\) , and the total number of values is the last value of the case counter \\(i\\) . standard deviation This one is even less obvious. The basic idea is to keep a running sum of the squared differences between each value and the running mean at the time that value was encountered, in a way similar to the running sum of the mean, and then to calculate the standard deviation from that running sum after finishing the last iteration. Before beginning the iteration, initialize a variable for the \"running mean\" \\(\\bar{x}\\) to zero, a variable for the \"running sum of squared differences\" \\(S\\) to zero, and another variable for the case number \\(i\\) to zero. In each step in the iteration, with each new value \\(x_i\\) , Increment the case counter \\(i \\leftarrow i + 1\\) . Calculate the difference between this value and the old running mean, \\(\\delta = x_i - \\bar{x}\\) . Update the running mean as \\(\\bar{x} \\leftarrow \\bar{x} + \\delta / i\\) . Update the running sum of squared differences as \\(S \\leftarrow S + (x_i - \\bar{x}) \\delta\\) . After handling the last case (value): the overall average is the last value of the running mean \\(\\bar{x}\\) , the total number of values is the last value of the case counter \\(i\\) , and the standard deviation is \\(\\text{SD}(x) = \\sqrt{S / (i - 1)}\\) . Note that you can't calculate the standard deviation without calculating the mean. Critical detail: You might wonder (like I initially did) why in step 2.4 we update \\(S\\) with \\((x_i - \\bar{x}) \\delta\\) instead of just using \\(\\delta^2\\) , since we calculated \\(\\delta = x_i - \\bar{x}\\) in step 2.2. THe reason is that between these two steps, in 2.4, we updated the value of the running mean \\(\\bar{x}\\) , so in step 2.3 \\(\\delta\\) uses the old \\(\\bar{x}\\) while \\((x_i - \\bar{x})\\) uses the new \\(\\bar{x}\\) . Recipe: Frequency Here's the pattern for calculating the probability that a particular outcome occurs: n_positive = 0 for _ in range(N): value = # Get or generate the next value in the data set if <<condition>>: n_positive += 1 frequency = n_positive / N Replace <<condition>> with a boolean expression that returns True if value meets the criterion you want a frequency for. That might be as simple as value == target_value , or value > threshold , or something more complex. Variant: Iterating Through a Collection The syntax here might not match how your code actually gets its data values. As you'll see in Collections , it's possible to iterate directly over a collection of values. In such a case, the recipe looks like this: n_positive, N = 0, 0 for value in <<data_collection>>: N += 1 if <<condition>>: n_positive += 1 frequency = n_positive / N Recipe: Mean and Standard Deviation Here's the pattern for calculating the mean and standard deviation: from math import sqrt mean, S = 0, 0 for i in range(1, N + 1): value = # Get or generate the next value in the data set delta = value - mean mean += delta / i S += (value - mean) * delta standard_deviation = sqrt(S / (i - 1)) Variant: Mean and Standard Deviation with Collection This is a forward reference, put here for completeness. It uses ideas we won't encounter until a later section, and you can safely ignore it for now. If want the mean and standard deviation of the values in a collection , the recipe looks like this: from math import sqrt i, mean, S = 0, 0, 0 for value in <<data_collection>>: i += 1 delta = value - mean mean += delta / i S += (value - mean) * delta standard_deviation = math.sqrt(S / (i - 1)) There's actually a slightly more \"pythonic\" way to handle this: from math import sqrt mean, S = 0, 0 for i, value in enumerate(<<data_collection>>, 1): delta = value - mean mean += delta / i S += (value - mean) * delta standard_deviation = sqrt(S / (i - 1)) Again, if this enumerate(...) stuff is gibberish to you, ignore it for now.","title":"Determine Statistics of a Sequence"},{"location":"recipes/core/iteration/stats/#determine-statistics-of-a-sequence","text":"","title":"Determine Statistics of a Sequence"},{"location":"recipes/core/iteration/stats/#problem-to-solve","text":"I want to determine some simple statistical measures (like frequency, mean, and standard deviation) of a set of measurements, events, or data, and I don't want to store all of the individual values in memory.","title":"Problem to Solve"},{"location":"recipes/core/iteration/stats/#background-knowledge","text":"","title":"Background Knowledge"},{"location":"recipes/core/iteration/stats/#statistical-measures","text":"A common kind of task in physics (and much of science and engineering, even social science) is to characterize the properties of a set of values that have (or at least appear to have) random variability in them. Sometimes, this comes from the inherent uncertainty in measurement. Sometimes, we use deliberate randomness in a simulation to represent variables in a complex system that we can't model deterministically. Statistics is a vast and complicated subject all in itself, and we'll barely scratch the surface of it. A few ideas and techniques, however, will get you a long way. Let's say we've got a collection of values \u2014 measurements, say \u2014 that seem to have random variability. Three questions we might reasonably want to ask are: What is the frequency (i.e, probability) that a particular outcome occurs? (That might mean the frequency of a specific value occurring, or the frequency that the value is above some threshold, or etc.) This is commonly calculated as the number of cases that meet the criterion \\(n\\) divided by the total number of cases \\(N\\) , and reported as either a decimal value between 0 and 1 or a percentage: \\[ f = \\frac{n}{N} \\] About what midpoint do the values tend to cluster? (Statisticians call this the central tendency .) We have more than one way to characterize this, but buy far the common is the mean or average : \\[ \\bar{x} = \\frac{1}{N} \\sum_{i=1}^N x_i \\] How broadly or narrowly spread are the values about this midpoint? That is, how much variability do they have? Again, multiple ways of characterizing this exist, but many are based on or related to the standard deviation of the values: \\[ \\text{SD}(x) = \\sqrt{\\frac{1}{N-1} \\sum_{i=1}^N (x_i - \\bar{x})^2} \\] Many other statistical measures exist, each with their own applications and virtues.","title":"statistical measures"},{"location":"recipes/core/iteration/stats/#calculating-on-the-fly","text":"Most statistical measures, such as the three given above, are defined in a way that assumes you have the entire collection of values available to work with. This often true. When it is, by far the easiest way to calculate them is with library functions such as those in the statistics module. Sometimes, however, it's convenient or necessary to calculate these statistics in a \"running\" or \"on-the-fly\" way as you encounter the values one at a time, such that you don't need to store all of the individual values in memory. (If you're analyzing a billion particle collider events, not having to store and read a billion values can really speed things up.) Not all statistical measures can be calculated in this way, but the three given above can.","title":"calculating on the fly"},{"location":"recipes/core/iteration/stats/#frequency","text":"This one is easy: As you iterate through your cases, keep a running count of the total number \\(N\\) (unless that's already known), and another running count of the number of cases \\(n\\) that fits the criterion you want a frequency for. At the end, calculate the frequency as the ratio of the two counts: \\(f = n / N\\) .","title":"frequency"},{"location":"recipes/core/iteration/stats/#mean-average","text":"This is slightly less obvious. The idea is that as we iterate through the values, we keep track of the average of all cases to date; and as we encounter a new value, we calculate the new average as an appropriately weighted combination of the old average and the new value. Before beginning the iteration, initialize a variable for the \"running mean\" \\(\\bar{x}\\) to zero, and another variable for the case number \\(i\\) to zero. In each step in the iteration, with each new value \\(x_i\\) , Increment the case counter \\(i \\leftarrow i + 1\\) . Calculate the difference between this value and the old running mean, \\(\\delta = x_i - \\bar{x}\\) . Update the running mean as \\(\\bar{x} \\leftarrow \\bar{x} + \\delta / i\\) . After handling the last case (value), the overall average is the last value of the running mean \\(\\bar{x}\\) , and the total number of values is the last value of the case counter \\(i\\) .","title":"mean (average)"},{"location":"recipes/core/iteration/stats/#standard-deviation","text":"This one is even less obvious. The basic idea is to keep a running sum of the squared differences between each value and the running mean at the time that value was encountered, in a way similar to the running sum of the mean, and then to calculate the standard deviation from that running sum after finishing the last iteration. Before beginning the iteration, initialize a variable for the \"running mean\" \\(\\bar{x}\\) to zero, a variable for the \"running sum of squared differences\" \\(S\\) to zero, and another variable for the case number \\(i\\) to zero. In each step in the iteration, with each new value \\(x_i\\) , Increment the case counter \\(i \\leftarrow i + 1\\) . Calculate the difference between this value and the old running mean, \\(\\delta = x_i - \\bar{x}\\) . Update the running mean as \\(\\bar{x} \\leftarrow \\bar{x} + \\delta / i\\) . Update the running sum of squared differences as \\(S \\leftarrow S + (x_i - \\bar{x}) \\delta\\) . After handling the last case (value): the overall average is the last value of the running mean \\(\\bar{x}\\) , the total number of values is the last value of the case counter \\(i\\) , and the standard deviation is \\(\\text{SD}(x) = \\sqrt{S / (i - 1)}\\) . Note that you can't calculate the standard deviation without calculating the mean. Critical detail: You might wonder (like I initially did) why in step 2.4 we update \\(S\\) with \\((x_i - \\bar{x}) \\delta\\) instead of just using \\(\\delta^2\\) , since we calculated \\(\\delta = x_i - \\bar{x}\\) in step 2.2. THe reason is that between these two steps, in 2.4, we updated the value of the running mean \\(\\bar{x}\\) , so in step 2.3 \\(\\delta\\) uses the old \\(\\bar{x}\\) while \\((x_i - \\bar{x})\\) uses the new \\(\\bar{x}\\) .","title":"standard deviation"},{"location":"recipes/core/iteration/stats/#recipe-frequency","text":"Here's the pattern for calculating the probability that a particular outcome occurs: n_positive = 0 for _ in range(N): value = # Get or generate the next value in the data set if <<condition>>: n_positive += 1 frequency = n_positive / N Replace <<condition>> with a boolean expression that returns True if value meets the criterion you want a frequency for. That might be as simple as value == target_value , or value > threshold , or something more complex.","title":"Recipe: Frequency"},{"location":"recipes/core/iteration/stats/#variant-iterating-through-a-collection","text":"The syntax here might not match how your code actually gets its data values. As you'll see in Collections , it's possible to iterate directly over a collection of values. In such a case, the recipe looks like this: n_positive, N = 0, 0 for value in <<data_collection>>: N += 1 if <<condition>>: n_positive += 1 frequency = n_positive / N","title":"Variant: Iterating Through a Collection"},{"location":"recipes/core/iteration/stats/#recipe-mean-and-standard-deviation","text":"Here's the pattern for calculating the mean and standard deviation: from math import sqrt mean, S = 0, 0 for i in range(1, N + 1): value = # Get or generate the next value in the data set delta = value - mean mean += delta / i S += (value - mean) * delta standard_deviation = sqrt(S / (i - 1))","title":"Recipe: Mean and Standard Deviation"},{"location":"recipes/core/iteration/stats/#variant-mean-and-standard-deviation-with-collection","text":"This is a forward reference, put here for completeness. It uses ideas we won't encounter until a later section, and you can safely ignore it for now. If want the mean and standard deviation of the values in a collection , the recipe looks like this: from math import sqrt i, mean, S = 0, 0, 0 for value in <<data_collection>>: i += 1 delta = value - mean mean += delta / i S += (value - mean) * delta standard_deviation = math.sqrt(S / (i - 1)) There's actually a slightly more \"pythonic\" way to handle this: from math import sqrt mean, S = 0, 0 for i, value in enumerate(<<data_collection>>, 1): delta = value - mean mean += delta / i S += (value - mean) * delta standard_deviation = sqrt(S / (i - 1)) Again, if this enumerate(...) stuff is gibberish to you, ignore it for now.","title":"Variant: Mean and Standard Deviation with Collection"},{"location":"recipes/core/iteration/while/","text":"Repeat While or Until Something Is True Problem to Solve I want to repeatedly execute a chunk of code while or until some condition is true, however many times that may be. Background Knowledge As the recipe Repeat Code a Specific Number of Times said, Python has two basic ways of iterating over (i.e., repeatedly executing) a chunk of code: Applying the code to every element of an ordered collection (\"iterable\") of things, or Executing the code over and over as long as some logical condition is true. This recipe focuses on the second. It's useful for situations like: I want to repeat a calculation until the result reaches some threshold value. I want to read lines from a datafile until reaching the end of the file. I want to simulate a system until it stops changing. Base Recipe while <<boolean expression>>: # Code to repeat over and over until the expression is False. Notes: Replace <<boolean expression>> with an actual expression that evaluates to True or False . This expression can be: the literal True (in which case the loop will run forever) or False (in which case it won't run at all), a variable with a boolean value, a boolean expression like x < 10 or r != 0 , a compound expression like (x < 10) and (y < x) , or a function call that returns a boolean value. Something that the code block does should affect the boolean expression in some way, such that it eventually evaluates to False rather than True , or the loop will run forever. (Unless, of course, your goal is to write a program that will run until something external terminates it.) Variant A: Pre-Initialization The while loop checks <<boolean expression>> at the beginning of each iteration, which means it checks before the first iteration occurs. Sometimes, that's a problem, for example if you want to repeat a chunk of code until its result meets some criterion. Before the first iteration, there isn't any result to check! Some languages have a repeat\u2026 until construct to handle this particular situation. Python doesn't, but that's not a bit deal. A good solution is to pre-initialize a variable that the loop will check. Sometimes, you can just precede the while statement with a line that sets a variable calculated in the loop to some arbitrary value that will ensure that the first <<boolean expression>> evaluates to True . Other times, it's easier or less convoluted to define a flag variable like this: keep_looping = True while keep_looping: # Some calculation or another\u2026 keep_looping = <<boolean expression>> If it's more semantically meaningful, you can use a flag variable that becomes True when the termination condition occurs: end_loop = False while not end_loop: # Some calculation or another\u2026 end_loop = <<boolean expression>> Either way, the <<boolean expression>> can now safely refer to variables and values that the code in the loop produces. Tip: Instead of condition_met or continue_loop , use a variable name that captures the specific condition: end_of_data_reached , calculation_converged , object_moved , etc. Another approach is to initialize a variable used in the calculation with a value that you know will make the loop execute for the first time, but will not mess up the calculation. For example, let's say you've got a calculation that produces various values of x , and you want to repeat it until x exceeds some threshold that you're sure will be positive. This would work: x = -1 while x <= <<threshold value>>: x = <<some calculation>> This will not work if the calculation uses the previous value of x , or if you cannot specify an initial value that you're sure will always be less than the threshold. example: smallest value greater than\u2026 Consider the series defined by \\(s_n \\equiv 2\\,s_{n-1} + 1\\) with \\(s_0 = 1\\) : \\({1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, \\ldots}\\) . Let's write a function that will find the smallest value in the series that exceeds some given integer \\(N\\) . def smallest_s_exceeding(N): s = 1 while s <= N: s = 2*s + 1 return s Simple, no? We'll hair that up a bit in the next example. Variant B: Tracking Two Successive Updates Commonly, the body of a while loop updates the value of some particular variable according to a calculation. Sometimes, that calculation needs to use the variable's previous value to find the new value, like this: x = <<some initial value>> while <<boolean expression>>: x = <<some calculation involving x>> In the calculation line, the x on the right of the assignment operator = will be the old value, and the result of the calculation will be assigned to x thereafter (i.e., into the next iteration). If the calculation requires the values of the previous two iterations, you'll have to do a bit more work. Here's one possibility: x_old = <<some initial value>> x_new = <<some other initial value>> while <<boolean expression>>: x_old, x_new = x_new, <<some calculation involving x_old and x_new>> What's going on here? The use of the comma is a clever way to make two assignments happen simultaneously : The previous value of x_new is given to x_old , while, simultaneously, The previous values of x_old and x_new are used to calculate the new value of x_new . You could solve this without use of the comma trick, but you'd need to introduce yet another variable, and you'd have to do a fair amount of careful value-passing between them. example: Fibonacci sequence The Fibonacci sequence is defined as the series of numbers that begins with \\(\\{0, 1\\}\\) , and continuing according to the rule that each number is the sum of the two preceding numbers: \\(F_n = F_{n-1} + F_{n-2}\\) . The first few numbers in the sequence are \\(\\{0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, \\ldots\\}\\) . For some obscure reason, let's say we want a function that will find the smallest Fibonacci number that exceeds some given integer \\(N\\) . def smallest_fibonacci_exceeding(N): F_old, F_new = 0, 1 while F_new <= N: F_old, F_new = F_new, F_old + F_new return F_new Since each Fibonacci number depends on the two previous numbers in the sequence, we used Variant B of the recipe.","title":"Repeat While or Until Something Is True"},{"location":"recipes/core/iteration/while/#repeat-while-or-until-something-is-true","text":"","title":"Repeat While or Until Something Is True"},{"location":"recipes/core/iteration/while/#problem-to-solve","text":"I want to repeatedly execute a chunk of code while or until some condition is true, however many times that may be.","title":"Problem to Solve"},{"location":"recipes/core/iteration/while/#background-knowledge","text":"As the recipe Repeat Code a Specific Number of Times said, Python has two basic ways of iterating over (i.e., repeatedly executing) a chunk of code: Applying the code to every element of an ordered collection (\"iterable\") of things, or Executing the code over and over as long as some logical condition is true. This recipe focuses on the second. It's useful for situations like: I want to repeat a calculation until the result reaches some threshold value. I want to read lines from a datafile until reaching the end of the file. I want to simulate a system until it stops changing.","title":"Background Knowledge"},{"location":"recipes/core/iteration/while/#base-recipe","text":"while <<boolean expression>>: # Code to repeat over and over until the expression is False. Notes: Replace <<boolean expression>> with an actual expression that evaluates to True or False . This expression can be: the literal True (in which case the loop will run forever) or False (in which case it won't run at all), a variable with a boolean value, a boolean expression like x < 10 or r != 0 , a compound expression like (x < 10) and (y < x) , or a function call that returns a boolean value. Something that the code block does should affect the boolean expression in some way, such that it eventually evaluates to False rather than True , or the loop will run forever. (Unless, of course, your goal is to write a program that will run until something external terminates it.)","title":"Base Recipe"},{"location":"recipes/core/iteration/while/#variant-a-pre-initialization","text":"The while loop checks <<boolean expression>> at the beginning of each iteration, which means it checks before the first iteration occurs. Sometimes, that's a problem, for example if you want to repeat a chunk of code until its result meets some criterion. Before the first iteration, there isn't any result to check! Some languages have a repeat\u2026 until construct to handle this particular situation. Python doesn't, but that's not a bit deal. A good solution is to pre-initialize a variable that the loop will check. Sometimes, you can just precede the while statement with a line that sets a variable calculated in the loop to some arbitrary value that will ensure that the first <<boolean expression>> evaluates to True . Other times, it's easier or less convoluted to define a flag variable like this: keep_looping = True while keep_looping: # Some calculation or another\u2026 keep_looping = <<boolean expression>> If it's more semantically meaningful, you can use a flag variable that becomes True when the termination condition occurs: end_loop = False while not end_loop: # Some calculation or another\u2026 end_loop = <<boolean expression>> Either way, the <<boolean expression>> can now safely refer to variables and values that the code in the loop produces. Tip: Instead of condition_met or continue_loop , use a variable name that captures the specific condition: end_of_data_reached , calculation_converged , object_moved , etc. Another approach is to initialize a variable used in the calculation with a value that you know will make the loop execute for the first time, but will not mess up the calculation. For example, let's say you've got a calculation that produces various values of x , and you want to repeat it until x exceeds some threshold that you're sure will be positive. This would work: x = -1 while x <= <<threshold value>>: x = <<some calculation>> This will not work if the calculation uses the previous value of x , or if you cannot specify an initial value that you're sure will always be less than the threshold.","title":"Variant A: Pre-Initialization"},{"location":"recipes/core/iteration/while/#example-smallest-value-greater-than","text":"Consider the series defined by \\(s_n \\equiv 2\\,s_{n-1} + 1\\) with \\(s_0 = 1\\) : \\({1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, \\ldots}\\) . Let's write a function that will find the smallest value in the series that exceeds some given integer \\(N\\) . def smallest_s_exceeding(N): s = 1 while s <= N: s = 2*s + 1 return s Simple, no? We'll hair that up a bit in the next example.","title":"example: smallest value greater than\u2026"},{"location":"recipes/core/iteration/while/#variant-b-tracking-two-successive-updates","text":"Commonly, the body of a while loop updates the value of some particular variable according to a calculation. Sometimes, that calculation needs to use the variable's previous value to find the new value, like this: x = <<some initial value>> while <<boolean expression>>: x = <<some calculation involving x>> In the calculation line, the x on the right of the assignment operator = will be the old value, and the result of the calculation will be assigned to x thereafter (i.e., into the next iteration). If the calculation requires the values of the previous two iterations, you'll have to do a bit more work. Here's one possibility: x_old = <<some initial value>> x_new = <<some other initial value>> while <<boolean expression>>: x_old, x_new = x_new, <<some calculation involving x_old and x_new>> What's going on here? The use of the comma is a clever way to make two assignments happen simultaneously : The previous value of x_new is given to x_old , while, simultaneously, The previous values of x_old and x_new are used to calculate the new value of x_new . You could solve this without use of the comma trick, but you'd need to introduce yet another variable, and you'd have to do a fair amount of careful value-passing between them.","title":"Variant B: Tracking Two Successive Updates"},{"location":"recipes/core/iteration/while/#example-fibonacci-sequence","text":"The Fibonacci sequence is defined as the series of numbers that begins with \\(\\{0, 1\\}\\) , and continuing according to the rule that each number is the sum of the two preceding numbers: \\(F_n = F_{n-1} + F_{n-2}\\) . The first few numbers in the sequence are \\(\\{0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, \\ldots\\}\\) . For some obscure reason, let's say we want a function that will find the smallest Fibonacci number that exceeds some given integer \\(N\\) . def smallest_fibonacci_exceeding(N): F_old, F_new = 0, 1 while F_new <= N: F_old, F_new = F_new, F_old + F_new return F_new Since each Fibonacci number depends on the two previous numbers in the sequence, we used Variant B of the recipe.","title":"example: Fibonacci sequence"},{"location":"recipes/core/workflow/","text":"Workflow Recipes The \"recipes\" in this group are all \"procedural\", meaning that they consist of a set of steps to follow rather than a particular bit of code to use. Some must be followed precisely as stated, and others just illustrate tools and skills you can mix-and-match as needed. Some of these recipes include one-time-only steps that you should only need to do once, or perhaps once every so often, mixed in with steps you'll do every time you follow the recipe. I'll try to be clear about which steps are once-only. Overall, these recipes \u2014 or rather, the process of applying and getting comfortable with them \u2014 will familiarize you with key elements of the course \"tech stack\": the GitHub website and our course \"org\" within it; Beskar , the Linux server you'll use for all your coding work; JupyterHub , the browser-based coding environment that will be your \"front door\" and primary workbench on Beskar; and a bit of the behind-the-scenes plumbing on Beskar. The Recipes Here are some recipes for basic processes required to use the course \"tech stack\" to get, do, and submit assignments. (It is very much not an accident that these same processes are widely useful in computational physics, and well beyond it into all kinds of software development work. \ud83d\ude0f) Find and Fork a Repo on GitHub : I want to make my own copy of a course level repo (the \"package\" that assignments come bundled in) so that I can start working on it. Manage Files on Beskar : I want to view and/or reorganize the files and folders in my personal file space on Beskar. Authorizing with GitHub from Beskar : I want GitHub to allow me to access my repos from Beskar without having to type in a password every time. Clone a Repo to Beskar : I want to copy my fork of a course level repo from GitHub to Beskar so that I can start working on it in JupyterHub. Commit and Push Changes to GitHub : I want to make a snapshot of my work so far in case I need to roll back changes, and copy the current repo state back to GitHub for safekeeping. Execute Interactive Python : I want to execute python commands interactively (perhaps to do a one-off calculation or just try things out). Submit a Level via Commit-Push-Pullreq : I want to submit a repo (level) of completed work for course credit.","title":"(Recipe List)"},{"location":"recipes/core/workflow/#workflow-recipes","text":"The \"recipes\" in this group are all \"procedural\", meaning that they consist of a set of steps to follow rather than a particular bit of code to use. Some must be followed precisely as stated, and others just illustrate tools and skills you can mix-and-match as needed. Some of these recipes include one-time-only steps that you should only need to do once, or perhaps once every so often, mixed in with steps you'll do every time you follow the recipe. I'll try to be clear about which steps are once-only. Overall, these recipes \u2014 or rather, the process of applying and getting comfortable with them \u2014 will familiarize you with key elements of the course \"tech stack\": the GitHub website and our course \"org\" within it; Beskar , the Linux server you'll use for all your coding work; JupyterHub , the browser-based coding environment that will be your \"front door\" and primary workbench on Beskar; and a bit of the behind-the-scenes plumbing on Beskar.","title":"Workflow Recipes"},{"location":"recipes/core/workflow/#the-recipes","text":"Here are some recipes for basic processes required to use the course \"tech stack\" to get, do, and submit assignments. (It is very much not an accident that these same processes are widely useful in computational physics, and well beyond it into all kinds of software development work. \ud83d\ude0f) Find and Fork a Repo on GitHub : I want to make my own copy of a course level repo (the \"package\" that assignments come bundled in) so that I can start working on it. Manage Files on Beskar : I want to view and/or reorganize the files and folders in my personal file space on Beskar. Authorizing with GitHub from Beskar : I want GitHub to allow me to access my repos from Beskar without having to type in a password every time. Clone a Repo to Beskar : I want to copy my fork of a course level repo from GitHub to Beskar so that I can start working on it in JupyterHub. Commit and Push Changes to GitHub : I want to make a snapshot of my work so far in case I need to roll back changes, and copy the current repo state back to GitHub for safekeeping. Execute Interactive Python : I want to execute python commands interactively (perhaps to do a one-off calculation or just try things out). Submit a Level via Commit-Push-Pullreq : I want to submit a repo (level) of completed work for course credit.","title":"The Recipes"},{"location":"recipes/core/workflow/beskar-and-jlab/","text":"Log Into Beskar and JupyterLab Problem to Solve I want to work on course assignments (or maybe apply what I'm learning to another course or project, or just noodle around with python). Recipe (This one is really quick and easy. It doesn't really deserve to be called a \"recipe\", but it's an important little step and I needed somewhere to put this information.) Part A: Log Into Beskar Point your web browser to https://beskar.uncg.edu/ . That should take you to a \"sign in\" page. Enter your UNCG user ID for \"Username\". Enter your Beskar password\u2026 The very first time you do this, whatever you enter will become your Beskar password. So, choose it carefully, and type it very carefully . You might consider using your UNCG password for this, too. That is at least guaranteed to be (1) hiqh-quality, and (2) something you'll remember. Click the \"Sign In\" button. That should take you to the main interface of JupyterLab, our coding environment. Part B: Welcome to JupyterLab","title":"Log Into Beskar and JupyterLab"},{"location":"recipes/core/workflow/beskar-and-jlab/#log-into-beskar-and-jupyterlab","text":"","title":"Log Into Beskar and JupyterLab"},{"location":"recipes/core/workflow/beskar-and-jlab/#problem-to-solve","text":"I want to work on course assignments (or maybe apply what I'm learning to another course or project, or just noodle around with python).","title":"Problem to Solve"},{"location":"recipes/core/workflow/beskar-and-jlab/#recipe","text":"(This one is really quick and easy. It doesn't really deserve to be called a \"recipe\", but it's an important little step and I needed somewhere to put this information.)","title":"Recipe"},{"location":"recipes/core/workflow/beskar-and-jlab/#part-a-log-into-beskar","text":"Point your web browser to https://beskar.uncg.edu/ . That should take you to a \"sign in\" page. Enter your UNCG user ID for \"Username\". Enter your Beskar password\u2026 The very first time you do this, whatever you enter will become your Beskar password. So, choose it carefully, and type it very carefully . You might consider using your UNCG password for this, too. That is at least guaranteed to be (1) hiqh-quality, and (2) something you'll remember. Click the \"Sign In\" button. That should take you to the main interface of JupyterLab, our coding environment.","title":"Part A: Log Into Beskar"},{"location":"recipes/core/workflow/beskar-and-jlab/#part-b-welcome-to-jupyterlab","text":"","title":"Part B: Welcome to JupyterLab"},{"location":"recipes/core/workflow/clone-to-beskar/","text":"Clone a Repo to Beskar Problem to Solve I want to copy my fork of a course level repo from GitHub to Beskar so that I can start working on it in JupyterHub. Recipe On GitHub, go to the main page of the repo that you want to clone. For an assignment repo, make sure you're looking at your fork, not at the instructor's original. If you are reading this on the GitHub site: to keep these instructions visible as you go, right-click on the repo name (e.g., A-01-username ) at the very top of the window, and choose \"Open in new tab\". Or, if you've got loads of screen real estate, \"Open in new window\" so you can put them side-by-side. Do make sure you're looking at your fork, not at the original! Click the big green \"Code\" button near the top of the repo main page. That should reveal a popup dialog. Select the \"Local\" tab in that dialog if it's not already selected. Select the \"GitHub CLI\" sub-tab . Click the two-rectangles \"copy\" icon to the right of the text box that contains something analogous to gh repo clone UNCG-PHY-351-S25/A-01-username . A little tooltip that says \"Copied!\" should appear, briefly. Open a Terminal (or switch to an already-open one) in your Beskar browser tab. Verify that you are, in fact, in your home directory or life will get very awkward. Paste the copied text in as a terminal command and hit return to execute it. List the directory's contents and you should see a new subdirectory with the name of your repo.","title":"Clone a Repo to Beskar"},{"location":"recipes/core/workflow/clone-to-beskar/#clone-a-repo-to-beskar","text":"","title":"Clone a Repo to Beskar"},{"location":"recipes/core/workflow/clone-to-beskar/#problem-to-solve","text":"I want to copy my fork of a course level repo from GitHub to Beskar so that I can start working on it in JupyterHub.","title":"Problem to Solve"},{"location":"recipes/core/workflow/clone-to-beskar/#recipe","text":"On GitHub, go to the main page of the repo that you want to clone. For an assignment repo, make sure you're looking at your fork, not at the instructor's original. If you are reading this on the GitHub site: to keep these instructions visible as you go, right-click on the repo name (e.g., A-01-username ) at the very top of the window, and choose \"Open in new tab\". Or, if you've got loads of screen real estate, \"Open in new window\" so you can put them side-by-side. Do make sure you're looking at your fork, not at the original! Click the big green \"Code\" button near the top of the repo main page. That should reveal a popup dialog. Select the \"Local\" tab in that dialog if it's not already selected. Select the \"GitHub CLI\" sub-tab . Click the two-rectangles \"copy\" icon to the right of the text box that contains something analogous to gh repo clone UNCG-PHY-351-S25/A-01-username . A little tooltip that says \"Copied!\" should appear, briefly. Open a Terminal (or switch to an already-open one) in your Beskar browser tab. Verify that you are, in fact, in your home directory or life will get very awkward. Paste the copied text in as a terminal command and hit return to execute it. List the directory's contents and you should see a new subdirectory with the name of your repo.","title":"Recipe"},{"location":"recipes/core/workflow/commit-push/","text":"Commit and Push Changes to GitHub Problem to Solve I want to make a snapshot of my work so far in case I need to roll back changes, and copy the current repo state back to GitHub for safekeeping. Background Knowledge Committing In git and GitHub parlance, committing means \"saving a snapshot of the current state of the repo\". These snapshots are good for a few different things, including: At some future time, comparing the repo's state then to the snapshot in order to see precisely what has changed (even which specific lines within a file!); and Resetting the repo to how it was at the time of a particular snapshot, if you've gotten all tangled up in changes you were trying to make that aren't working and just want to undo everything since the snapshot. Committing a repo is something that you do locally (i.e., on whatever machine you've been using to work on the repo \u2014 for us, that's usually Beskar). When you do, git saves information about the current snapshot into a hidden folder that is stored in the repo, right alongside the repo's normal files. I strongly recommend \"doing a commit\" every time you complete an exercise , when you take a break after having done significant work on an assignment, or when you're about to make major changes to some code that you might possibly want to undo. Pushing Before you started working on a repo in Beskar, you had to (a) fork it on GitHub to make your own copy, and (b) clone it to Beskar. Pushing means taking whatever changes you've made to the local (Beskar) clone of the repo and \"pushing\" them through the internet to GitHub so that it can update your on-GitHub copy accordingly. Doing this frequently is very important! As of the start of the Spring 2025 semester, Beskar is not being backed up at all. (That's on my to-do list. It's not so easy.) Pulling Pulling means the converse: from Beskar, \"pulling\" down from GitHub any changes that may have occurred to your copy of the repo there and updating your local, on-Beskar clone accordingly. This isn't something you're likely to need very often, unless (a) you've used GitHub's web-based editor to change something, or (b) I've made changes to the master repo that you originally forked and that I've told you to pull down. (In that case, you'll first have to pull the changes from the master to your fork. When the need arises, I'll explain how to do that.) Syncing Syncing just means doing both a push and a pull simultaneously, and reconciling any conflicts (e.g., if a file was edited both on Beskar and on GitHub). If only one version has changed, this is the same as doing the appropriate push or pull. I recommend avoiding making edits on both GitHub and Beskar between pushes/pulls, because the conflict reconciliation process can be confusing and frustrating. If you never make changes directly on GitHub, you won't have to worry about this unless I have to distribute updates or bugfixes. Recipe Recipe 1: Committing You can do all this through the Terminal, via text commands, but I recommend using JupyterLab's built-in GitHub support. In the top menubar, find the \"Git\" menu, click on it, and make sure the item \"Simple staging\" is checked. If not, select it to turn it on. This setting should be remembered hereafter. Click on the Git icon in the left-hand border. That's the one that looks like a diamond containing a couple of dots connected by branching lines (subway map??). When you do, the File Browser panel should be replaced by one that says, at the top, \"Current Repository\" and the name of your repo. That panel has two sub-panels, with side-by-side tabs labeled \"Changes\" and \"History\". If \"Changes\" isn't selected already, click that. You should see a list of all files in the project that have been added, modified, or removed since your last commit. Make sure the checkboxes are checked for all the files you want to commit. If you've created any new files, those won't be checked by default. Check them unless they're \"throwaway\" files you don't care about keeping in the repo. This adds them to the list of files to be tracked by git. In the \"Summary\" box near the bottom of the panel, type a brief note like \"Finished Exercise 04\" (or whatever is appropriate). This will help you figure out which snapshot you might want to compare or roll back to, should the need arise. Adding a \"Description\" is optional. Write one if you want to add a comment providing more detail about what's changed for this commit. Then, click the big blue Commit button at the bottom (not the three-dots button on its right). This performs the actual commit, storing the snapshot info in the repo. If you are shown a \"Who is committing?\" dialog, fill in your name and UNCG email address and click \"OK\". JupyterHub should remember your identity thereafter, and not demand this every time you commit. Save point created! Recipe 2: Pushing However, this new commit (snapshot) is only local, as is all the hard work you've done on the repo. Time to push it to GitHub. Look at the very top of the Git panel, up above the words \"Current Repository\". You should see a row of three little icons: a cloud with a down-arrow, a cloud with an up-arrow, and a circular-arrow. These mean \"pull\", \"push\" and \"sync\" respectively. If you hover your mouse pointer over any of them, a tooltip should appear to tell you what it does. The \"push\" icon (the middle one) should have an orange dot next to it. That means the local repo has committed changes that haven't yet been pushed. Click the \"push\" icon. The dot should disappear, and a \"Successfully pushed\" message should briefly appear in the bottom-right corner of the JupyterLab window. Relax, content in the knowledge that your work is now safely protected on GitHub's massive server farms.","title":"Commit and Push Changes to GitHub"},{"location":"recipes/core/workflow/commit-push/#commit-and-push-changes-to-github","text":"","title":"Commit and Push Changes to GitHub"},{"location":"recipes/core/workflow/commit-push/#problem-to-solve","text":"I want to make a snapshot of my work so far in case I need to roll back changes, and copy the current repo state back to GitHub for safekeeping.","title":"Problem to Solve"},{"location":"recipes/core/workflow/commit-push/#background-knowledge","text":"","title":"Background Knowledge"},{"location":"recipes/core/workflow/commit-push/#committing","text":"In git and GitHub parlance, committing means \"saving a snapshot of the current state of the repo\". These snapshots are good for a few different things, including: At some future time, comparing the repo's state then to the snapshot in order to see precisely what has changed (even which specific lines within a file!); and Resetting the repo to how it was at the time of a particular snapshot, if you've gotten all tangled up in changes you were trying to make that aren't working and just want to undo everything since the snapshot. Committing a repo is something that you do locally (i.e., on whatever machine you've been using to work on the repo \u2014 for us, that's usually Beskar). When you do, git saves information about the current snapshot into a hidden folder that is stored in the repo, right alongside the repo's normal files. I strongly recommend \"doing a commit\" every time you complete an exercise , when you take a break after having done significant work on an assignment, or when you're about to make major changes to some code that you might possibly want to undo.","title":"Committing"},{"location":"recipes/core/workflow/commit-push/#pushing","text":"Before you started working on a repo in Beskar, you had to (a) fork it on GitHub to make your own copy, and (b) clone it to Beskar. Pushing means taking whatever changes you've made to the local (Beskar) clone of the repo and \"pushing\" them through the internet to GitHub so that it can update your on-GitHub copy accordingly. Doing this frequently is very important! As of the start of the Spring 2025 semester, Beskar is not being backed up at all. (That's on my to-do list. It's not so easy.)","title":"Pushing"},{"location":"recipes/core/workflow/commit-push/#pulling","text":"Pulling means the converse: from Beskar, \"pulling\" down from GitHub any changes that may have occurred to your copy of the repo there and updating your local, on-Beskar clone accordingly. This isn't something you're likely to need very often, unless (a) you've used GitHub's web-based editor to change something, or (b) I've made changes to the master repo that you originally forked and that I've told you to pull down. (In that case, you'll first have to pull the changes from the master to your fork. When the need arises, I'll explain how to do that.)","title":"Pulling"},{"location":"recipes/core/workflow/commit-push/#syncing","text":"Syncing just means doing both a push and a pull simultaneously, and reconciling any conflicts (e.g., if a file was edited both on Beskar and on GitHub). If only one version has changed, this is the same as doing the appropriate push or pull. I recommend avoiding making edits on both GitHub and Beskar between pushes/pulls, because the conflict reconciliation process can be confusing and frustrating. If you never make changes directly on GitHub, you won't have to worry about this unless I have to distribute updates or bugfixes.","title":"Syncing"},{"location":"recipes/core/workflow/commit-push/#recipe","text":"","title":"Recipe"},{"location":"recipes/core/workflow/commit-push/#recipe-1-committing","text":"You can do all this through the Terminal, via text commands, but I recommend using JupyterLab's built-in GitHub support. In the top menubar, find the \"Git\" menu, click on it, and make sure the item \"Simple staging\" is checked. If not, select it to turn it on. This setting should be remembered hereafter. Click on the Git icon in the left-hand border. That's the one that looks like a diamond containing a couple of dots connected by branching lines (subway map??). When you do, the File Browser panel should be replaced by one that says, at the top, \"Current Repository\" and the name of your repo. That panel has two sub-panels, with side-by-side tabs labeled \"Changes\" and \"History\". If \"Changes\" isn't selected already, click that. You should see a list of all files in the project that have been added, modified, or removed since your last commit. Make sure the checkboxes are checked for all the files you want to commit. If you've created any new files, those won't be checked by default. Check them unless they're \"throwaway\" files you don't care about keeping in the repo. This adds them to the list of files to be tracked by git. In the \"Summary\" box near the bottom of the panel, type a brief note like \"Finished Exercise 04\" (or whatever is appropriate). This will help you figure out which snapshot you might want to compare or roll back to, should the need arise. Adding a \"Description\" is optional. Write one if you want to add a comment providing more detail about what's changed for this commit. Then, click the big blue Commit button at the bottom (not the three-dots button on its right). This performs the actual commit, storing the snapshot info in the repo. If you are shown a \"Who is committing?\" dialog, fill in your name and UNCG email address and click \"OK\". JupyterHub should remember your identity thereafter, and not demand this every time you commit. Save point created!","title":"Recipe 1: Committing"},{"location":"recipes/core/workflow/commit-push/#recipe-2-pushing","text":"However, this new commit (snapshot) is only local, as is all the hard work you've done on the repo. Time to push it to GitHub. Look at the very top of the Git panel, up above the words \"Current Repository\". You should see a row of three little icons: a cloud with a down-arrow, a cloud with an up-arrow, and a circular-arrow. These mean \"pull\", \"push\" and \"sync\" respectively. If you hover your mouse pointer over any of them, a tooltip should appear to tell you what it does. The \"push\" icon (the middle one) should have an orange dot next to it. That means the local repo has committed changes that haven't yet been pushed. Click the \"push\" icon. The dot should disappear, and a \"Successfully pushed\" message should briefly appear in the bottom-right corner of the JupyterLab window. Relax, content in the knowledge that your work is now safely protected on GitHub's massive server farms.","title":"Recipe 2: Pushing"},{"location":"recipes/core/workflow/find-and-fork/","text":"Find and Fork a Repo on GitHub Problem to Solve I want to make my own copy of a course level repo (the \"package\" that assignments come bundled in) so that I can start working on it. Background Knowledge Git and GitHub Git is a software tool and system that helps programmers manage and collaborate on complex coding projects. One can install and run Git on just about any computer. GitHub is an online service that provides web-based Git support. It helps developer teams collaborate, keep track of (and occasionally roll back) changes to a software project, and track issues to address. We'll use it as a way for me to distribute assignment files to you, for you to submit your work back to me, and for me to provide you with specific feedback about your code. GitHub runs on some huge server farm somewhere, and talks to Git running on your computer. On GitHub , an organization (\"org\") is a space for a group of people to share and collaborate on coding projects. Prof. Beatty has created an organization for PHY 351. Repos and Course Assignments On GitHub, the fundamental container or package for a coding project is called a repository , or \" repo \" for short. A repo is a collection of files and directories that can be shared with others and perhaps jointly edited. GitHub is built upon the git version control system, which takes care of (a) keeping a historical record of all changes to a repo's files over time, with snapshots of how it looked at various points in time; and (b) checking for and helping to reconcile conflicts that might arise between different contributor's edits and contributions. I've divided the PHY 351 course content into six \"worlds\" (if we get that far). Each world is divided into multiple \"levels\". For example, World A is about Core Python skills. Within it, Level 01 is called Workflow and focuses on how to use the course's \"tech stack\" \u2014 the combination of technology platforms and tools you'll use to do the course. A level consists of several individual \"Exercises\", each of which focuses on one of the course's computational physics \"Recipes\". Most levels end with a \"Miniboss\", a slightly more complex challenge that asks you to apply a combination of the recipes from the level. I've chosen to package each \"level\" as one GitHub repo (repository). To \"do\" a level, the essence of what you need to accomplish is: Find the level repo in our course \"org\" (organization) on GitHub. Fork that repo to make your own copy to do your work in. Clone your copy of the level repo to your account on Beskar, the server where you'll do your coding work. Read the instructions in the repo and complete the specified tasks for each of the exercises and the miniboss. Periodically commit your work to version control (to create snapshots that you could roll back to if necessary), and push all changes your copy of the repo on GitHub. When all work for the exercises and miniboss is done, do a final commit-push, and then submit your work to me for credit by opening a pull request (\"pullreq\") from your copy of the repo to the course org's original version of repo. (This sounds weird. I'll explain more when we get there.) For this recipe, we're just focusing on Steps 1 and 2 of this process, which includes getting familiar with GitHub and how I've set up our course \"org\" within it. Recipe Prerequisites: A GitHub account linked to your UNCG email address. If you don't have this yet, see Creating your GitHub Account for instructions. If you have a personal GitHub account not affiliated with UNCG, you should probably just create a new one for this course. (I don't know if it's possible to associate your existing one with your UNCG email address. Feel free to investigate that possibility, if you'd prefer.) Membership in the course GitHub\"org\". If you don't have this yet, message Prof. Beatty and ask him to add you to the group, Include your GitHub user ID. Part A: Find the Course Org When I tell you I've done that (or you're impatient and want to check by yourself): Point your web browser to https://github.com/UNCG-PHY-351-F22 . (You might want to bookmark this.) If you see \"This organization has no public repositories\", I haven't added you yet (or I did it wrong). If you see \"You made it! Welcome to the private GitHub space for UNCG's PHY 351 in Spring 2025\", all is good and you're ready to proceed to the next task. Feel free to explore a little, if you wish. Don't go too far down any rabbit-holes, however: We've got work to do! Part B: Find the Level Repo Remember that course assignments are packaged up into repositories (\"repos\"), one level per repo. All the org repos available to you are listed on the org's repo page. Along the top of the GitHub page for our org are several tab-style links: \"Overview\", \"Repositories\", \"Projects\", etc. Click on \"Repositories\" . This should take you to a page listing repositories, with names like uncg-phy-351-s25.github.io and A-01 . If the list of repos gets inconveniently long as the semester progresses and Beatty releases more levels, note that the page has tools to let you search by repo name (or just a part of a name), sort the list in various ways, etc. Click on the name of the repo you want to start work on. This should take you to the repo's home page. Under a bit of fairly cryptic header info you'll see a list of files and folders in the repo. In the right sidebar is a brief \"About\" section. Part C: Fork the repo (once per repo/level) In GitHub parlance, forking a repo means making your own copy of it, so that you can make modifications without affecting anyone else. A forked repo keeps track of the original \"upstream\" repo that it was forked from. One benefit is if the upstream repo changes, you can choose to sync your forked repo with the changes in the upstream repo. (For a course level repo, that will probably occur when I inevitably discover bugs or confusing bits in an assignment that students have already started working on.) As the owner of a forked repo, you can also request that the upstream repo incorporate changes you've made in your fork. This is called issuing a pull request (\"pullreq\" \u2014 my own nickname for it). Before you can start working on the assignments in a course level, you have to fork the level repo. (Otherwise, every student would be making changes to the same set of files, and pandemonium would erupt.) If you're not already looking at the home page of the level repo (on the GitHub website), get there as described above in Part D. Way up at the top right of that page, find the button that says \"Fork\". Click it. (Don't click on the little down-arrow to its right; click the main part that has the word \"Fork\".) This should take you to a \"Create a new fork\" page. In the form, change \"Owner\" to \"UNCG-PHY-351-S25\". That will cause a scary red warning that \"The repository [XXX] already exists on this account.\" Don't worry about it! Instead: To the end of the repo name (such as \"A-01\"), append a hyphen and your GitHub ID (to make the name something like \"A-01-idbeatty\"). Leave \"Description\" as it is (though changing it won't break anything). Leave \"Copy the main branch only\" checked. Click the big green \"Create fork\" button. When you do, you should be taken to the home page of your new repo. The repo name, which includes both the level name and your GitHub ID, will help you distinguish your copy of the repo from the original distributed by Prof. Beatty.","title":"Find and Fork a Repo on GitHub"},{"location":"recipes/core/workflow/find-and-fork/#find-and-fork-a-repo-on-github","text":"","title":"Find and Fork a Repo on GitHub"},{"location":"recipes/core/workflow/find-and-fork/#problem-to-solve","text":"I want to make my own copy of a course level repo (the \"package\" that assignments come bundled in) so that I can start working on it.","title":"Problem to Solve"},{"location":"recipes/core/workflow/find-and-fork/#background-knowledge","text":"","title":"Background Knowledge"},{"location":"recipes/core/workflow/find-and-fork/#git-and-github","text":"Git is a software tool and system that helps programmers manage and collaborate on complex coding projects. One can install and run Git on just about any computer. GitHub is an online service that provides web-based Git support. It helps developer teams collaborate, keep track of (and occasionally roll back) changes to a software project, and track issues to address. We'll use it as a way for me to distribute assignment files to you, for you to submit your work back to me, and for me to provide you with specific feedback about your code. GitHub runs on some huge server farm somewhere, and talks to Git running on your computer. On GitHub , an organization (\"org\") is a space for a group of people to share and collaborate on coding projects. Prof. Beatty has created an organization for PHY 351.","title":"Git and GitHub"},{"location":"recipes/core/workflow/find-and-fork/#repos-and-course-assignments","text":"On GitHub, the fundamental container or package for a coding project is called a repository , or \" repo \" for short. A repo is a collection of files and directories that can be shared with others and perhaps jointly edited. GitHub is built upon the git version control system, which takes care of (a) keeping a historical record of all changes to a repo's files over time, with snapshots of how it looked at various points in time; and (b) checking for and helping to reconcile conflicts that might arise between different contributor's edits and contributions. I've divided the PHY 351 course content into six \"worlds\" (if we get that far). Each world is divided into multiple \"levels\". For example, World A is about Core Python skills. Within it, Level 01 is called Workflow and focuses on how to use the course's \"tech stack\" \u2014 the combination of technology platforms and tools you'll use to do the course. A level consists of several individual \"Exercises\", each of which focuses on one of the course's computational physics \"Recipes\". Most levels end with a \"Miniboss\", a slightly more complex challenge that asks you to apply a combination of the recipes from the level. I've chosen to package each \"level\" as one GitHub repo (repository). To \"do\" a level, the essence of what you need to accomplish is: Find the level repo in our course \"org\" (organization) on GitHub. Fork that repo to make your own copy to do your work in. Clone your copy of the level repo to your account on Beskar, the server where you'll do your coding work. Read the instructions in the repo and complete the specified tasks for each of the exercises and the miniboss. Periodically commit your work to version control (to create snapshots that you could roll back to if necessary), and push all changes your copy of the repo on GitHub. When all work for the exercises and miniboss is done, do a final commit-push, and then submit your work to me for credit by opening a pull request (\"pullreq\") from your copy of the repo to the course org's original version of repo. (This sounds weird. I'll explain more when we get there.) For this recipe, we're just focusing on Steps 1 and 2 of this process, which includes getting familiar with GitHub and how I've set up our course \"org\" within it.","title":"Repos and Course Assignments"},{"location":"recipes/core/workflow/find-and-fork/#recipe","text":"","title":"Recipe"},{"location":"recipes/core/workflow/find-and-fork/#prerequisites","text":"A GitHub account linked to your UNCG email address. If you don't have this yet, see Creating your GitHub Account for instructions. If you have a personal GitHub account not affiliated with UNCG, you should probably just create a new one for this course. (I don't know if it's possible to associate your existing one with your UNCG email address. Feel free to investigate that possibility, if you'd prefer.) Membership in the course GitHub\"org\". If you don't have this yet, message Prof. Beatty and ask him to add you to the group, Include your GitHub user ID.","title":"Prerequisites:"},{"location":"recipes/core/workflow/find-and-fork/#part-a-find-the-course-org","text":"When I tell you I've done that (or you're impatient and want to check by yourself): Point your web browser to https://github.com/UNCG-PHY-351-F22 . (You might want to bookmark this.) If you see \"This organization has no public repositories\", I haven't added you yet (or I did it wrong). If you see \"You made it! Welcome to the private GitHub space for UNCG's PHY 351 in Spring 2025\", all is good and you're ready to proceed to the next task. Feel free to explore a little, if you wish. Don't go too far down any rabbit-holes, however: We've got work to do!","title":"Part A: Find the Course Org"},{"location":"recipes/core/workflow/find-and-fork/#part-b-find-the-level-repo","text":"Remember that course assignments are packaged up into repositories (\"repos\"), one level per repo. All the org repos available to you are listed on the org's repo page. Along the top of the GitHub page for our org are several tab-style links: \"Overview\", \"Repositories\", \"Projects\", etc. Click on \"Repositories\" . This should take you to a page listing repositories, with names like uncg-phy-351-s25.github.io and A-01 . If the list of repos gets inconveniently long as the semester progresses and Beatty releases more levels, note that the page has tools to let you search by repo name (or just a part of a name), sort the list in various ways, etc. Click on the name of the repo you want to start work on. This should take you to the repo's home page. Under a bit of fairly cryptic header info you'll see a list of files and folders in the repo. In the right sidebar is a brief \"About\" section.","title":"Part B: Find the Level Repo"},{"location":"recipes/core/workflow/find-and-fork/#part-c-fork-the-repo-once-per-repolevel","text":"In GitHub parlance, forking a repo means making your own copy of it, so that you can make modifications without affecting anyone else. A forked repo keeps track of the original \"upstream\" repo that it was forked from. One benefit is if the upstream repo changes, you can choose to sync your forked repo with the changes in the upstream repo. (For a course level repo, that will probably occur when I inevitably discover bugs or confusing bits in an assignment that students have already started working on.) As the owner of a forked repo, you can also request that the upstream repo incorporate changes you've made in your fork. This is called issuing a pull request (\"pullreq\" \u2014 my own nickname for it). Before you can start working on the assignments in a course level, you have to fork the level repo. (Otherwise, every student would be making changes to the same set of files, and pandemonium would erupt.) If you're not already looking at the home page of the level repo (on the GitHub website), get there as described above in Part D. Way up at the top right of that page, find the button that says \"Fork\". Click it. (Don't click on the little down-arrow to its right; click the main part that has the word \"Fork\".) This should take you to a \"Create a new fork\" page. In the form, change \"Owner\" to \"UNCG-PHY-351-S25\". That will cause a scary red warning that \"The repository [XXX] already exists on this account.\" Don't worry about it! Instead: To the end of the repo name (such as \"A-01\"), append a hyphen and your GitHub ID (to make the name something like \"A-01-idbeatty\"). Leave \"Description\" as it is (though changing it won't break anything). Leave \"Copy the main branch only\" checked. Click the big green \"Create fork\" button. When you do, you should be taken to the home page of your new repo. The repo name, which includes both the level name and your GitHub ID, will help you distinguish your copy of the repo from the original distributed by Prof. Beatty.","title":"Part C: Fork the repo (once per repo/level)"},{"location":"recipes/core/workflow/github-auth/","text":"Authorizing with GitHub from Beskar Rather than typing in a password every time you need your working computer to talk to GitHub, GitHub uses a credential system that lets you authorize your computer once and then remembers the authorization. Let's get that set up. This process is rather bizarre and finicky, so please ask for help if you're at all confused \u2014 and follow the instructions very, very carefully. Fortunately, you should only have to do it once, or at least once every so often. Log into Beskar (if necessary). Open a Terminal . Navigate to your home directory (if necessary). Execute gh auth login . (\"gh\" means \"github\"). That will start a several-step interaction that will guide you through the process, albeit not very clearly. The steps are\u2026 Choose GitHub.com to log into. (This should be what comes up as the default choice, so you can just hit return to accept it.) Choose HTTPS for the protocol. (Ditto.) Enter Y when asked \"Authenticate Git with your GitHub credentials?\" (Ditto.) Choose Login with a web browser . (Ditto.) Write down the \"one-time code\" shown, or just make sure not to close this terminal or browser tab yet so you can get back to it. Press Enter . It will try and fail to open a web browser, because this is running on my server and can't control your web browser. So, when you get the failure message: Select and copy the URL it shows. Open a NEW browser tab/window and paste in that URL . Go there. Sign into GitHub again, if necessary. You may need to enter an authentication code that GitHub emails or texts to you. Enter your one-time code when asked. You'll probably want to go back to the tab with the Terminal session, copy the code, return here, and paste it in. Agree to authorize GitHub CLI when asked whether to do so. Return to the Terminal session and you should now see some output ending in \"\u2713 Logged in as\" and your GitHub username. Success! If what you experience differs from this, let Prof. Beatty know ASAP. Note: At any time in the future, you can check whether you're still logged into GitHub by executing gh auth status at any Terminal prompt.","title":"Authorizing with GitHub from Beskar"},{"location":"recipes/core/workflow/github-auth/#authorizing-with-github-from-beskar","text":"Rather than typing in a password every time you need your working computer to talk to GitHub, GitHub uses a credential system that lets you authorize your computer once and then remembers the authorization. Let's get that set up. This process is rather bizarre and finicky, so please ask for help if you're at all confused \u2014 and follow the instructions very, very carefully. Fortunately, you should only have to do it once, or at least once every so often. Log into Beskar (if necessary). Open a Terminal . Navigate to your home directory (if necessary). Execute gh auth login . (\"gh\" means \"github\"). That will start a several-step interaction that will guide you through the process, albeit not very clearly. The steps are\u2026 Choose GitHub.com to log into. (This should be what comes up as the default choice, so you can just hit return to accept it.) Choose HTTPS for the protocol. (Ditto.) Enter Y when asked \"Authenticate Git with your GitHub credentials?\" (Ditto.) Choose Login with a web browser . (Ditto.) Write down the \"one-time code\" shown, or just make sure not to close this terminal or browser tab yet so you can get back to it. Press Enter . It will try and fail to open a web browser, because this is running on my server and can't control your web browser. So, when you get the failure message: Select and copy the URL it shows. Open a NEW browser tab/window and paste in that URL . Go there. Sign into GitHub again, if necessary. You may need to enter an authentication code that GitHub emails or texts to you. Enter your one-time code when asked. You'll probably want to go back to the tab with the Terminal session, copy the code, return here, and paste it in. Agree to authorize GitHub CLI when asked whether to do so. Return to the Terminal session and you should now see some output ending in \"\u2713 Logged in as\" and your GitHub username. Success! If what you experience differs from this, let Prof. Beatty know ASAP. Note: At any time in the future, you can check whether you're still logged into GitHub by executing gh auth status at any Terminal prompt.","title":"Authorizing with GitHub from Beskar"},{"location":"recipes/core/workflow/interactive-python/","text":"Execute Interactive Python Problem to Solve I want to execute python commands interactively (perhaps to do a one-off calculation or just try things out). Recipe This is another \"procedural\" recipe. Don't worry, we'll get to actual code soon enough. Part A: Starting IPython Version 1: From JupyterLab Assuming you are logged into Beskar and looking at the JupyterLab interface: If no \"Launcher\" tab is open in the main JupyterLab window, open the Launcher by clicking on the + button to the right of whatever tab(s) is/are open. A tab labeled \"Launcher\" should appear in the main window. Alternatively, you can click on the blue + button at the top of the File Browser in the left sidebar. If the sidebar is collapsed or is showing something else, view the File Browser by clicking on the folder icon in the very left window border. Launch an IPython console by clicking on the button labeled \"Python 3 (ipykernel)\" in the Console section , not the identical button in the Notebook section above it . The Launcher tab should disappear, replaced by a tab labeled \"Console N\" (where N is some number). You now have an active IPython session. Version 2: From the terminal If you are working on your own computer or are logged into a different server, you can use IPython without JupyterLab. The visual appearance is different, but the functionality is equivalent. Open a terminal window in whatever way is appropriate for your operating system. In JupyterLab, you can do this by opening the Launcher (see Version 1 above) and clicking on the \"Terminal\" button in the \"Other\" section at the bottom. On a Mac or Linux machine, launch the Terminal app or an equivalent application. (I prefer the \"Warp\" app.) On Windows, you can use the Command Prompt or PowerShell. At the terminal's command line, type ipython and hit Enter. If you get a message like \"command not found: ipython\", either your computer doesn't have IPython installed, or it's in a \"virtual environment\" that you don't have activated. Resolving that is beyond the scope of this recipe. For PHY 351, just use JupyterLab on Beskar and you should be fine. Part B: Do the calculation Type a python expression or statement into the input box at the bottom of the pane, and hit Shift-Enter to send them to the python interpreter for execution. If you prefer, can change the \"execute\" keystroke to just Enter (rather than shift-Enter). Click the Settings menu in the JupyterLab browser window, pick \"Console Run Keystroke\" from the menu that appears, and select the option you prefer. If you make \"Enter\" your execution keystroke, you can use Shift-Enter to insert a line break for multiline input. Continue executing python expressions and statements , one after another. When you define a variable in one statement, it will be available to subsequent statements. The window above the input box/prompt will show you your IPython session's prior history of commands and their results. Press the up-arrow key to step back through your prior commands . You can re-execute one with (shift-)Enter, or modify it before executing. This often saves considerable typing. Part C: Save, if desired If you want, you can save your IPython session's history to a file so that you have a record of what you entered. (The output, however, will not be saved. You'l have to re-execute the commands to see that.) Execute %save filename.py , replacing filename with something meaningful to your situation. This will save all your inputs and python's responses, for the entire IPython session. You can save just a subset of the history by specifying the line numbers along with the %save command. For example, if you want to save lines 12 through 30, you would type %save filename.py 12-30 . Locate your history file and, if desired, move it somewhere more convenient. By default, it gets saved in the \"current working directory\". If you're using the JupyterLab interface, the \"current working directory\" will be whatever directory is currently displayed in the JupyterLab File Browser. If you're using a terminal, it will be the directory your terminal was \"in\" when you launched IPython. If you're thinking ahead, navigate the JupyterLab File Browser or terminal to the folder/directory you'll want your history file to be stored in before launching IPython. You can see what IPython thinks the current working directory is by executing the \"magic command\" %pwd (for \"print working directory\") at the IPython prompt. Technically, it is possible to reload a stored session by re-running all commands in a history file. However, this is tricky and unreliable, because any errors in the file \u2014 perhaps from incorrect expressions that you later redid \u2014 will cause the re-running process to halt. In general, I recommend re-doing rather than restoring prior work if you need to resume an IPython session. (For anything complex enough to make this annoying, see the Script a Calculation recipe.) Part D: Quitting IPython Version 1: From JupyterLab Kill the python \"kernel\" by choosing \"Shut Down\" from the Kernel menu. The Console's tab must be the active one; if not, click on it or on the console pane. Close the console pane by clicking the \"X\" at the right side of its tab. If you forgot to kill the kernel before closing the console pane : Click on the \"Running Terminals and Kernels\" icon in the left sidebar (looks like a square inside a circle). Expand the \"Kernels\" section. Click on the \"X\" that appears next to the \"Console N\" entry in the list of running kernels. Or, click the \"Shut Down All\" text and confirm in the dialog that appears. Version 2: From the terminal Enter and execute quit or exit at the console prompt. This will return you to the terminal's command line. Unfortunately, if you do this within the JupyterLab IPython console, it'll quit the kernel and then automatically restart it \u2014 quite annoying. Comments Again, this may look long and complicated, but it's the work of a few seconds once you're comfortable firing up JupyterLab or a terminal session. The result is an easy-access calculator that is superior in most ways to whatever handheld calculator or phone calculator app you might generally use.","title":"Execute Interactive Python"},{"location":"recipes/core/workflow/interactive-python/#execute-interactive-python","text":"","title":"Execute Interactive Python"},{"location":"recipes/core/workflow/interactive-python/#problem-to-solve","text":"I want to execute python commands interactively (perhaps to do a one-off calculation or just try things out).","title":"Problem to Solve"},{"location":"recipes/core/workflow/interactive-python/#recipe","text":"This is another \"procedural\" recipe. Don't worry, we'll get to actual code soon enough.","title":"Recipe"},{"location":"recipes/core/workflow/interactive-python/#part-a-starting-ipython","text":"","title":"Part A: Starting IPython"},{"location":"recipes/core/workflow/interactive-python/#version-1-from-jupyterlab","text":"Assuming you are logged into Beskar and looking at the JupyterLab interface: If no \"Launcher\" tab is open in the main JupyterLab window, open the Launcher by clicking on the + button to the right of whatever tab(s) is/are open. A tab labeled \"Launcher\" should appear in the main window. Alternatively, you can click on the blue + button at the top of the File Browser in the left sidebar. If the sidebar is collapsed or is showing something else, view the File Browser by clicking on the folder icon in the very left window border. Launch an IPython console by clicking on the button labeled \"Python 3 (ipykernel)\" in the Console section , not the identical button in the Notebook section above it . The Launcher tab should disappear, replaced by a tab labeled \"Console N\" (where N is some number). You now have an active IPython session.","title":"Version 1: From JupyterLab"},{"location":"recipes/core/workflow/interactive-python/#version-2-from-the-terminal","text":"If you are working on your own computer or are logged into a different server, you can use IPython without JupyterLab. The visual appearance is different, but the functionality is equivalent. Open a terminal window in whatever way is appropriate for your operating system. In JupyterLab, you can do this by opening the Launcher (see Version 1 above) and clicking on the \"Terminal\" button in the \"Other\" section at the bottom. On a Mac or Linux machine, launch the Terminal app or an equivalent application. (I prefer the \"Warp\" app.) On Windows, you can use the Command Prompt or PowerShell. At the terminal's command line, type ipython and hit Enter. If you get a message like \"command not found: ipython\", either your computer doesn't have IPython installed, or it's in a \"virtual environment\" that you don't have activated. Resolving that is beyond the scope of this recipe. For PHY 351, just use JupyterLab on Beskar and you should be fine.","title":"Version 2: From the terminal"},{"location":"recipes/core/workflow/interactive-python/#part-b-do-the-calculation","text":"Type a python expression or statement into the input box at the bottom of the pane, and hit Shift-Enter to send them to the python interpreter for execution. If you prefer, can change the \"execute\" keystroke to just Enter (rather than shift-Enter). Click the Settings menu in the JupyterLab browser window, pick \"Console Run Keystroke\" from the menu that appears, and select the option you prefer. If you make \"Enter\" your execution keystroke, you can use Shift-Enter to insert a line break for multiline input. Continue executing python expressions and statements , one after another. When you define a variable in one statement, it will be available to subsequent statements. The window above the input box/prompt will show you your IPython session's prior history of commands and their results. Press the up-arrow key to step back through your prior commands . You can re-execute one with (shift-)Enter, or modify it before executing. This often saves considerable typing.","title":"Part B: Do the calculation"},{"location":"recipes/core/workflow/interactive-python/#part-c-save-if-desired","text":"If you want, you can save your IPython session's history to a file so that you have a record of what you entered. (The output, however, will not be saved. You'l have to re-execute the commands to see that.) Execute %save filename.py , replacing filename with something meaningful to your situation. This will save all your inputs and python's responses, for the entire IPython session. You can save just a subset of the history by specifying the line numbers along with the %save command. For example, if you want to save lines 12 through 30, you would type %save filename.py 12-30 . Locate your history file and, if desired, move it somewhere more convenient. By default, it gets saved in the \"current working directory\". If you're using the JupyterLab interface, the \"current working directory\" will be whatever directory is currently displayed in the JupyterLab File Browser. If you're using a terminal, it will be the directory your terminal was \"in\" when you launched IPython. If you're thinking ahead, navigate the JupyterLab File Browser or terminal to the folder/directory you'll want your history file to be stored in before launching IPython. You can see what IPython thinks the current working directory is by executing the \"magic command\" %pwd (for \"print working directory\") at the IPython prompt. Technically, it is possible to reload a stored session by re-running all commands in a history file. However, this is tricky and unreliable, because any errors in the file \u2014 perhaps from incorrect expressions that you later redid \u2014 will cause the re-running process to halt. In general, I recommend re-doing rather than restoring prior work if you need to resume an IPython session. (For anything complex enough to make this annoying, see the Script a Calculation recipe.)","title":"Part C: Save, if desired"},{"location":"recipes/core/workflow/interactive-python/#part-d-quitting-ipython","text":"","title":"Part D: Quitting IPython"},{"location":"recipes/core/workflow/interactive-python/#version-1-from-jupyterlab_1","text":"Kill the python \"kernel\" by choosing \"Shut Down\" from the Kernel menu. The Console's tab must be the active one; if not, click on it or on the console pane. Close the console pane by clicking the \"X\" at the right side of its tab. If you forgot to kill the kernel before closing the console pane : Click on the \"Running Terminals and Kernels\" icon in the left sidebar (looks like a square inside a circle). Expand the \"Kernels\" section. Click on the \"X\" that appears next to the \"Console N\" entry in the list of running kernels. Or, click the \"Shut Down All\" text and confirm in the dialog that appears.","title":"Version 1: From JupyterLab"},{"location":"recipes/core/workflow/interactive-python/#version-2-from-the-terminal_1","text":"Enter and execute quit or exit at the console prompt. This will return you to the terminal's command line. Unfortunately, if you do this within the JupyterLab IPython console, it'll quit the kernel and then automatically restart it \u2014 quite annoying.","title":"Version 2: From the terminal"},{"location":"recipes/core/workflow/interactive-python/#comments","text":"Again, this may look long and complicated, but it's the work of a few seconds once you're comfortable firing up JupyterLab or a terminal session. The result is an easy-access calculator that is superior in most ways to whatever handheld calculator or phone calculator app you might generally use.","title":"Comments"},{"location":"recipes/core/workflow/manage-files/","text":"Manage Files on Beskar Problem to Solve I want to view and/or reorganize the files and folders in my personal file space on Beskar. This \"recipe\" is actually a collection of tiny little snippet-recipes. In truth, it's really more of a cheat-sheet of commands to get you comfortable with both the JupyterLab File Browser and the system terminal's command-line interface (CLI). If you're already familiar with JupyterLab, or just quick to figure out GUI interfaces, Part A is probably unnecessary for you. If you're comfortable using the unix/linux command line, Part B is probably unnecessary. Refer to this or not as you see fit. Recipe Set A: Using the JupyterLab File Browser A note on terminology: When a recipe says \"right-click\", that means to click with your right mouse-button, or (on a Mac) option-click with a one-button mouse, or tap with two fingers on a trackpad, or do whatever it is you usually do to get a contextual (pop-up) menu to appear. Recipe 1: Hide and Display the File Browser When you log into JupyterHub and are presented with the JupyterLab window, you should see some menu-type stuff across the top, a mostly-empty panel on the left, and a big area with a tab at the top that says \"Launcher\" and contains a collection of icon-like buttons in subsections named \"Notebook\", \"Console\", and \"Other\". The panel on the left is the File Browser, and it's JupyterLab's version of the Mac Finder or the Windows File Explorer. Collapse it by clicking on the file-folder icon in the very left-hand border of the window. Re-expand it by clicking on that icon again. Switch to a different sidebar by clicking on one of the other icons in that left-hand border. (For now, no need to worry about what they do.) Switch back to the File Browser by \u2014 yeah, you guessed it. Recipe 2: Create a New File Right-click on the empty space in the File Browser panel. Choose \"New File\" from the contextual menu that appears. A new file will be listed in the File Browser, with the name ready to be edited. Type the filename you want, replacing the default \"untitled\". If you want to create a plain-text file, leave the file name extension as .txt . If you want to create a different kind of file, change the extension too: .md for a markdown file .py for a Python script .csv for a comma-separated values file (tabular data, e.g. for a spreadsheet to ingest) Other file types can be created by other extension, but these are the ones you'll need most often. Recipe 3: View and/or Edit a File For most file types, JupyterLab has only the plain-text view, so you view and edit the file in that. For a few, it has a plain-text view for editing and a formatted view for \"nice\" viewing. In particular, \"markdown\" and \"CSV\" files have two different views. (Some file types, like PDFs images, can't be edited or perhaps even viewed through JupyterLab.) To view or edit a file, double-click on it in the File Browser. The file should open in a new tab in the right-hand panel. Other, previously-open tabs (other than the Launcher) will remain, and you can switch back and forth by clicking on their tabs. For a file type that has two views, double-clicking will open whatever JupyterLab considers to be the \"default\" view. To get the other, Right-click on the file in the file browser, choose \"Open With\" from the contextual menu, and choose the view you want. If a file has opened to an editable view, you can make changes right in the displayed text. All the normal text-editing tools are available: cut, paste, undo, redo, etc. (See the Edit menu for more.) To save your changes, choose \"Save\" from the File menu, or use the \u2318S (Mac) or ctrl-S (Windows) keyboard shortcut. To close the file, click on the \"X\" in the file's tab. If you have unsaved changes, JupyterLab will prompt you to save them before closing. Recipe 4: Duplicate a File Right-click on the file in the File Browser and select Duplicate. A new copy, with something like Copy1 appended to the name, will appear in the File Browser. Recipe 5: Rename a File and/or Change its Type Right-click on the file in the File Browser and select Rename. The file name will become editable. Change it to what you wish. You can change the file's type by changing the extension. Hit return to save the new name. Recipe 6: Delete a File or Folder Note: Unlike most of what you do on a computer, deleting a file or folder via the File Browser cannot be undone. Be careful! Pause a moment to ensure you know what you're doing and that you really want to do it. Right-click on the file or folder in the File Browser and select Delete. A confirmation dialog will appear. Click \"Delete\" to confirm. JupyterLab will not let you delete a folder unless it's empty. You can either delete its contents one at a time (possibly tedious), or use the Terminal method described below in Recipe B.10. Recipe 7: Create a New Folder Right-click on the empty space in the File Browser panel. Alternatively, you can click on the new-folder icon (a small folder with a + in it) at the top of the File Browser. A new folder will appear, with its name ready to be edited. Change the folder name to what you wish. Recipe 8: Move a File Click and drag the file to the folder you want to move it into. Alternatively, you can right-click on the file, select Cut, navigate into the folder you want to move it to (even a deeply nested one, a parent folder, or a different child of the current folder's parent), right-click on the empty space in the File Browser, and select Paste. Recipe 9: View a Different Folder To navigate into a folder currently displayed in the File Browser, double-click on it. To navigate back up to a parent folder, click on the folder's name in the \"breadcrumb\" bar at the top of the File Browser. If you seen / \u2026 / in the breadcrumb bar, the sequence of parent-child-grandchild folders has been abbreviated. Click on the / \u2026 / to navigate to one of the elided folders. Recipe Set B: Using the System Terminal Command Line JupyterLab's \"Terminal\" gives you a no-graphics, no-mouse, command-line-only interface to the file system (and operating system) underlying JupyterHub. The Linux command line is a powerful thing, and we're only going to scratch the surface in this course. If you really want to nerd out on it, Google is your friend. You may want to start with The Linux Command Line by William Shotts. Here is some basic functionality to get you going. (Terminology warning: \"directory\" means the same as \"folder\", but is the more conventional term in this context.) Recipe 1: Open the Terminal If the main display area is NOT showing the Launcher, display it by revealing the File Browser (if necessary) and clicking the big blue \"+\" button at its top. In the Launcher, click on the button labeled \"Terminal\" in the Other section. A new tab should open, with a prompt like jupyter-test_student@Beskar:~$ at the top. Start typing commands after the prompt. Recipe 2: Show the Current Directory The terminal is always \"in\" a specific directory (folder), and life gets very confusing if you get confused about which one. You'll probably start in your \"home\" directory (which is the top of your personal file space and contains everything on Beskar that's \"yours\"), but will eventually navigate into others. To check which one you're currently in: Look at the part of the prompt just before the $ . It will show your current directory. The symbol ~ is a short-hand for your home directory. Alternatively, or to see a more complete path, type pwd (for \"print working directory\") and hit return. The system will print out the full file path starting from the system's ultimate \"root directory\". It will look something like this for your home directory: /home/jupyter-test_student . (In Linux, the currently-active directory is often called the \"working\" directory.) Recipe 3: List the Files in a Directory To see a list of the files in the current directory, type ls (for \"list\") and hit return. To get additional information, you can append one or more \"options\" to the command, like this: ls -l , ls -lF , etc. Personally, my go-to is ls -lFh . For exhaustive documentation on the options available, execute ls --help . To see a list of files within one of the directories (folders) in your current folder, execute ls <foldername> , replacing <foldername> with the name of the folder you want to see. For example, ls data will show you the files in a folder named data . Folder names that contain spaces are inconvenient, and best avoided. If you have one, you can surround thename with quotes ( ls 'test folder' or ls \"test folder\" ), or \"escape\" the space by preceding it with a backslash ( ls test\\ folder ). You can lists the contents of sub-sub-directories like this: ls <foldername>/<subfoldername> . For example, ls data/2023-10-02 will show you the files in a folder named 2023-10-02 inside a folder named data . You can even list the contents of the current directory's parent with the special .. name that means parent of , like this: ls .. . Or, list the contents of a sibling of the current folder with ../<siblingname> . No matter what directory you're currently in, you can list the contents of the home directory via ls ~ , the contents of one of its subfolders with ls ~/subfoldername , and so on. Yes, Linux command-line stuff is arcane, but powerful and flexible. Recipe 4: View a Calendar This one isn't very important, but it's a useful illustration of some of the very deep functionality available from the command line. To see a compact little calendar of the current month, enter cal . To see the calendar for a different month and year, enter cal <month> <year> , for example: cal 10 2026 or cal oct 2026 for October 2026. To see a calendar for an entire year, execute cal <year> , for example: cal 2025 . For exhaustive documentation, execute man cal . ( man means \"manual\".) Recipe 5: Reuse Prior Commands To save typing, you can re-execute commands you've (reasonably) previously executed in the Terminal. You can even modify them before re-executing them. At the system prompt, press the up-arrow key. Your most recently-executed command will appear. You can continue to step back through previous commands by pressing the up-arrow key again and again. When you find the command you want to re-execute, press the return key. If you want to modify it first, you can left-arrow and/or backspace and/or type to make changes. Then hit return. If you decide that you don't want to use a prior command, you can clear the command line by typing control-C (hold down the control key and press the C key). That is generic Linux for \"cancel that!\" Recipe 6: Change the Current Directory Navigate into a subdirectory of the current directory by executing cd <foldername> , replacing <foldername> with the name of the subdirectory you want to enter. For example, cd data will navigate into a folder named data . You can navigate directly into a sub-subdirectory, a parent directory, a sibling directory, and so on with the same \"file path\" methods as were shown above in Recipe 3: List the Files in a Directory (for the ls command). The cd ~ shortcut is a super-convenient way to jump back to your home directory quickly. Recipe 7: Create a New Directory Create a new, empty directory within the current directory by executing mkdir <foldername> , replacing <foldername> with the name of the new directory you want to create. For example, mkdir data will create a new folder named data within the current directory. Recipe 8: Rename a File or Directory Rename a file or directory by executing mv <oldname> <newname> , replacing <oldname> with the current name and <newname> with the new name you want. For example, mv oldfile.txt newfile.txt will rename a file named oldfile.txt to newfile.txt . mv stands for \"move\". This is really just a special case of moving a file to a different directory (see below). Recipe 9: Move a File or Directory Move a file from the current directory into one of its subdirectories with mv <filename> <foldername> , replacing <filename> with the name of the file you want to move and <foldername> with the name of the subdirectory you want to move it into. For example, mv oldfile.txt data will move a file named oldfile.txt into a subdirectory named data . The mv command knows that you want to move, rather than rename, because the destination is the name of an already-existing directory. Move a file from somewhere other than the current directory by specifying its \"file path\", as described above in Recipe 3: List the Files in a Directory. For example, mv ~/other_project/file1.py data will move a file named file1.py from a directory named other_project that lives in your home directory, and put it in a directory named data within the current directory (whatever that might be). Move a file to somewhere else the same way, by prepending a path onto the destination name. For example, undo the previous example with mv data/file1.py ~/other_project . The character . is a very convenient short-hand for \"the current directory\". For example, move a file from elsewhere to the current directory with mv ~/other_project/file1.py . . Recipe 10: Copy a File or Directory Make a copy of a file by executing cp <filename> <newfilename> , replacing <filename> with the name of the file you want to copy and <newfilename> with the name you want to give the copy. For example, cp oldfile.txt newfile.txt will create a copy of a file named oldfile.txt and call it newfile.txt . You can put the copy into a subdirectory (or, really, anywhere else) by prepending the new file's nanme with a path. Example: cp oldfile.txt data/newfile.txt will create a copy of oldfile.txt and put it in the data subdirectory, calling it newfile.txt . To make a copy of a directory and all its contents, include the -r option, like this: cp -r <foldername> <newfoldername> . For example, cp -r data data_backup will create a copy of the data directory and call it data_backup . Recipe 11: View the Contents of a File To display the contents of a text file, execute cat <filename> , replacing <filename> with the name of the file you want to view. For example, cat oldfile.txt will display the contents of a file named oldfile.txt . Why cat ? Because the command's full purpose is to concatenate multiple files together. We're just using it as an easy way to dump out the contents of one. Recipe 12: Save the Output of a Command to a File To save the output of a command to a file, execute the command as normal, but append > <filename> to the end of it before hitting retutrn. (Replace <filename> with the name of the file you want to save the output to, of course.) For example, ls -lFh > filelist.txt will save a detailed listing of the files in the current directory to a file named filelist.txt . If the file already exists, it will be overwritten. If it doesn't exist, it will be created. If you instead want to append the output to an existing file, use >> instead of > . Recipe 13: Delete a File or Directory Note: Unlike most of what you do on a computer, deleting a file or folder via the command line cannot be undone. Be careful! Pause a moment to ensure you know what you're doing and that you really want to do it. Delete a file by executing rm <filename> , replacing <filename> with the name of the file you want to delete. For example, rm oldfile.txt will delete a file named oldfile.txt . Delete a directory and all its contents by executing rm -r <foldername> , replacing <foldername> with the name of the directory you want to delete. For example, rm -r data will delete a directory named data and all its contents. The -r option means \"recursive\", which means \"and everything inside it\". Recipe 14: Clear the Terminal Empty the terminal display of all prior commands and output by executing clear . This does not undo the history of what's happened; it just removes the clutter from your view. You can still up-arrow through the command history. Recipe 15: Quit the Terminal Session To quit the terminal session, execute exit . This will close the current tab AND shut down the terminal process. Warning: If you just close the Terminal display by clicking on the \"X\" in the tab bar, the process will still be running on the server, just out of sight. In that case: In the far left window border, click the square-inside-a-circle icon to replace the File Browser with the \"Running Terminals and Processes\" panel. Down at the bottom, find the Terminals section, and click \"Shut Down All\", then agree to the confirmation dialog. Alternatively, you can expand that section, find the terminal session listed under it, mouse over it, and click the \"X\" that appears to its right. This is useful if you have multiple terminals going, and only want to kill one of them.","title":"Manage Files on Beskar"},{"location":"recipes/core/workflow/manage-files/#manage-files-on-beskar","text":"","title":"Manage Files on Beskar"},{"location":"recipes/core/workflow/manage-files/#problem-to-solve","text":"I want to view and/or reorganize the files and folders in my personal file space on Beskar. This \"recipe\" is actually a collection of tiny little snippet-recipes. In truth, it's really more of a cheat-sheet of commands to get you comfortable with both the JupyterLab File Browser and the system terminal's command-line interface (CLI). If you're already familiar with JupyterLab, or just quick to figure out GUI interfaces, Part A is probably unnecessary for you. If you're comfortable using the unix/linux command line, Part B is probably unnecessary. Refer to this or not as you see fit.","title":"Problem to Solve"},{"location":"recipes/core/workflow/manage-files/#recipe-set-a-using-the-jupyterlab-file-browser","text":"A note on terminology: When a recipe says \"right-click\", that means to click with your right mouse-button, or (on a Mac) option-click with a one-button mouse, or tap with two fingers on a trackpad, or do whatever it is you usually do to get a contextual (pop-up) menu to appear.","title":"Recipe Set A: Using the JupyterLab File Browser"},{"location":"recipes/core/workflow/manage-files/#recipe-1-hide-and-display-the-file-browser","text":"When you log into JupyterHub and are presented with the JupyterLab window, you should see some menu-type stuff across the top, a mostly-empty panel on the left, and a big area with a tab at the top that says \"Launcher\" and contains a collection of icon-like buttons in subsections named \"Notebook\", \"Console\", and \"Other\". The panel on the left is the File Browser, and it's JupyterLab's version of the Mac Finder or the Windows File Explorer. Collapse it by clicking on the file-folder icon in the very left-hand border of the window. Re-expand it by clicking on that icon again. Switch to a different sidebar by clicking on one of the other icons in that left-hand border. (For now, no need to worry about what they do.) Switch back to the File Browser by \u2014 yeah, you guessed it.","title":"Recipe 1: Hide and Display the File Browser"},{"location":"recipes/core/workflow/manage-files/#recipe-2-create-a-new-file","text":"Right-click on the empty space in the File Browser panel. Choose \"New File\" from the contextual menu that appears. A new file will be listed in the File Browser, with the name ready to be edited. Type the filename you want, replacing the default \"untitled\". If you want to create a plain-text file, leave the file name extension as .txt . If you want to create a different kind of file, change the extension too: .md for a markdown file .py for a Python script .csv for a comma-separated values file (tabular data, e.g. for a spreadsheet to ingest) Other file types can be created by other extension, but these are the ones you'll need most often.","title":"Recipe 2: Create a New File"},{"location":"recipes/core/workflow/manage-files/#recipe-3-view-andor-edit-a-file","text":"For most file types, JupyterLab has only the plain-text view, so you view and edit the file in that. For a few, it has a plain-text view for editing and a formatted view for \"nice\" viewing. In particular, \"markdown\" and \"CSV\" files have two different views. (Some file types, like PDFs images, can't be edited or perhaps even viewed through JupyterLab.) To view or edit a file, double-click on it in the File Browser. The file should open in a new tab in the right-hand panel. Other, previously-open tabs (other than the Launcher) will remain, and you can switch back and forth by clicking on their tabs. For a file type that has two views, double-clicking will open whatever JupyterLab considers to be the \"default\" view. To get the other, Right-click on the file in the file browser, choose \"Open With\" from the contextual menu, and choose the view you want. If a file has opened to an editable view, you can make changes right in the displayed text. All the normal text-editing tools are available: cut, paste, undo, redo, etc. (See the Edit menu for more.) To save your changes, choose \"Save\" from the File menu, or use the \u2318S (Mac) or ctrl-S (Windows) keyboard shortcut. To close the file, click on the \"X\" in the file's tab. If you have unsaved changes, JupyterLab will prompt you to save them before closing.","title":"Recipe 3: View and/or Edit a File"},{"location":"recipes/core/workflow/manage-files/#recipe-4-duplicate-a-file","text":"Right-click on the file in the File Browser and select Duplicate. A new copy, with something like Copy1 appended to the name, will appear in the File Browser.","title":"Recipe 4: Duplicate a File"},{"location":"recipes/core/workflow/manage-files/#recipe-5-rename-a-file-andor-change-its-type","text":"Right-click on the file in the File Browser and select Rename. The file name will become editable. Change it to what you wish. You can change the file's type by changing the extension. Hit return to save the new name.","title":"Recipe 5: Rename a File and/or Change its Type"},{"location":"recipes/core/workflow/manage-files/#recipe-6-delete-a-file-or-folder","text":"Note: Unlike most of what you do on a computer, deleting a file or folder via the File Browser cannot be undone. Be careful! Pause a moment to ensure you know what you're doing and that you really want to do it. Right-click on the file or folder in the File Browser and select Delete. A confirmation dialog will appear. Click \"Delete\" to confirm. JupyterLab will not let you delete a folder unless it's empty. You can either delete its contents one at a time (possibly tedious), or use the Terminal method described below in Recipe B.10.","title":"Recipe 6: Delete a File or Folder"},{"location":"recipes/core/workflow/manage-files/#recipe-7-create-a-new-folder","text":"Right-click on the empty space in the File Browser panel. Alternatively, you can click on the new-folder icon (a small folder with a + in it) at the top of the File Browser. A new folder will appear, with its name ready to be edited. Change the folder name to what you wish.","title":"Recipe 7: Create a New Folder"},{"location":"recipes/core/workflow/manage-files/#recipe-8-move-a-file","text":"Click and drag the file to the folder you want to move it into. Alternatively, you can right-click on the file, select Cut, navigate into the folder you want to move it to (even a deeply nested one, a parent folder, or a different child of the current folder's parent), right-click on the empty space in the File Browser, and select Paste.","title":"Recipe 8: Move a File"},{"location":"recipes/core/workflow/manage-files/#recipe-9-view-a-different-folder","text":"To navigate into a folder currently displayed in the File Browser, double-click on it. To navigate back up to a parent folder, click on the folder's name in the \"breadcrumb\" bar at the top of the File Browser. If you seen / \u2026 / in the breadcrumb bar, the sequence of parent-child-grandchild folders has been abbreviated. Click on the / \u2026 / to navigate to one of the elided folders.","title":"Recipe 9: View a Different Folder"},{"location":"recipes/core/workflow/manage-files/#recipe-set-b-using-the-system-terminal-command-line","text":"JupyterLab's \"Terminal\" gives you a no-graphics, no-mouse, command-line-only interface to the file system (and operating system) underlying JupyterHub. The Linux command line is a powerful thing, and we're only going to scratch the surface in this course. If you really want to nerd out on it, Google is your friend. You may want to start with The Linux Command Line by William Shotts. Here is some basic functionality to get you going. (Terminology warning: \"directory\" means the same as \"folder\", but is the more conventional term in this context.)","title":"Recipe Set B: Using the System Terminal Command Line"},{"location":"recipes/core/workflow/manage-files/#recipe-1-open-the-terminal","text":"If the main display area is NOT showing the Launcher, display it by revealing the File Browser (if necessary) and clicking the big blue \"+\" button at its top. In the Launcher, click on the button labeled \"Terminal\" in the Other section. A new tab should open, with a prompt like jupyter-test_student@Beskar:~$ at the top. Start typing commands after the prompt.","title":"Recipe 1: Open the Terminal"},{"location":"recipes/core/workflow/manage-files/#recipe-2-show-the-current-directory","text":"The terminal is always \"in\" a specific directory (folder), and life gets very confusing if you get confused about which one. You'll probably start in your \"home\" directory (which is the top of your personal file space and contains everything on Beskar that's \"yours\"), but will eventually navigate into others. To check which one you're currently in: Look at the part of the prompt just before the $ . It will show your current directory. The symbol ~ is a short-hand for your home directory. Alternatively, or to see a more complete path, type pwd (for \"print working directory\") and hit return. The system will print out the full file path starting from the system's ultimate \"root directory\". It will look something like this for your home directory: /home/jupyter-test_student . (In Linux, the currently-active directory is often called the \"working\" directory.)","title":"Recipe 2: Show the Current Directory"},{"location":"recipes/core/workflow/manage-files/#recipe-3-list-the-files-in-a-directory","text":"To see a list of the files in the current directory, type ls (for \"list\") and hit return. To get additional information, you can append one or more \"options\" to the command, like this: ls -l , ls -lF , etc. Personally, my go-to is ls -lFh . For exhaustive documentation on the options available, execute ls --help . To see a list of files within one of the directories (folders) in your current folder, execute ls <foldername> , replacing <foldername> with the name of the folder you want to see. For example, ls data will show you the files in a folder named data . Folder names that contain spaces are inconvenient, and best avoided. If you have one, you can surround thename with quotes ( ls 'test folder' or ls \"test folder\" ), or \"escape\" the space by preceding it with a backslash ( ls test\\ folder ). You can lists the contents of sub-sub-directories like this: ls <foldername>/<subfoldername> . For example, ls data/2023-10-02 will show you the files in a folder named 2023-10-02 inside a folder named data . You can even list the contents of the current directory's parent with the special .. name that means parent of , like this: ls .. . Or, list the contents of a sibling of the current folder with ../<siblingname> . No matter what directory you're currently in, you can list the contents of the home directory via ls ~ , the contents of one of its subfolders with ls ~/subfoldername , and so on. Yes, Linux command-line stuff is arcane, but powerful and flexible.","title":"Recipe 3: List the Files in a Directory"},{"location":"recipes/core/workflow/manage-files/#recipe-4-view-a-calendar","text":"This one isn't very important, but it's a useful illustration of some of the very deep functionality available from the command line. To see a compact little calendar of the current month, enter cal . To see the calendar for a different month and year, enter cal <month> <year> , for example: cal 10 2026 or cal oct 2026 for October 2026. To see a calendar for an entire year, execute cal <year> , for example: cal 2025 . For exhaustive documentation, execute man cal . ( man means \"manual\".)","title":"Recipe 4: View a Calendar"},{"location":"recipes/core/workflow/manage-files/#recipe-5-reuse-prior-commands","text":"To save typing, you can re-execute commands you've (reasonably) previously executed in the Terminal. You can even modify them before re-executing them. At the system prompt, press the up-arrow key. Your most recently-executed command will appear. You can continue to step back through previous commands by pressing the up-arrow key again and again. When you find the command you want to re-execute, press the return key. If you want to modify it first, you can left-arrow and/or backspace and/or type to make changes. Then hit return. If you decide that you don't want to use a prior command, you can clear the command line by typing control-C (hold down the control key and press the C key). That is generic Linux for \"cancel that!\"","title":"Recipe 5: Reuse Prior Commands"},{"location":"recipes/core/workflow/manage-files/#recipe-6-change-the-current-directory","text":"Navigate into a subdirectory of the current directory by executing cd <foldername> , replacing <foldername> with the name of the subdirectory you want to enter. For example, cd data will navigate into a folder named data . You can navigate directly into a sub-subdirectory, a parent directory, a sibling directory, and so on with the same \"file path\" methods as were shown above in Recipe 3: List the Files in a Directory (for the ls command). The cd ~ shortcut is a super-convenient way to jump back to your home directory quickly.","title":"Recipe 6: Change the Current Directory"},{"location":"recipes/core/workflow/manage-files/#recipe-7-create-a-new-directory","text":"Create a new, empty directory within the current directory by executing mkdir <foldername> , replacing <foldername> with the name of the new directory you want to create. For example, mkdir data will create a new folder named data within the current directory.","title":"Recipe 7: Create a New Directory"},{"location":"recipes/core/workflow/manage-files/#recipe-8-rename-a-file-or-directory","text":"Rename a file or directory by executing mv <oldname> <newname> , replacing <oldname> with the current name and <newname> with the new name you want. For example, mv oldfile.txt newfile.txt will rename a file named oldfile.txt to newfile.txt . mv stands for \"move\". This is really just a special case of moving a file to a different directory (see below).","title":"Recipe 8: Rename a File or Directory"},{"location":"recipes/core/workflow/manage-files/#recipe-9-move-a-file-or-directory","text":"Move a file from the current directory into one of its subdirectories with mv <filename> <foldername> , replacing <filename> with the name of the file you want to move and <foldername> with the name of the subdirectory you want to move it into. For example, mv oldfile.txt data will move a file named oldfile.txt into a subdirectory named data . The mv command knows that you want to move, rather than rename, because the destination is the name of an already-existing directory. Move a file from somewhere other than the current directory by specifying its \"file path\", as described above in Recipe 3: List the Files in a Directory. For example, mv ~/other_project/file1.py data will move a file named file1.py from a directory named other_project that lives in your home directory, and put it in a directory named data within the current directory (whatever that might be). Move a file to somewhere else the same way, by prepending a path onto the destination name. For example, undo the previous example with mv data/file1.py ~/other_project . The character . is a very convenient short-hand for \"the current directory\". For example, move a file from elsewhere to the current directory with mv ~/other_project/file1.py . .","title":"Recipe 9: Move a File or Directory"},{"location":"recipes/core/workflow/manage-files/#recipe-10-copy-a-file-or-directory","text":"Make a copy of a file by executing cp <filename> <newfilename> , replacing <filename> with the name of the file you want to copy and <newfilename> with the name you want to give the copy. For example, cp oldfile.txt newfile.txt will create a copy of a file named oldfile.txt and call it newfile.txt . You can put the copy into a subdirectory (or, really, anywhere else) by prepending the new file's nanme with a path. Example: cp oldfile.txt data/newfile.txt will create a copy of oldfile.txt and put it in the data subdirectory, calling it newfile.txt . To make a copy of a directory and all its contents, include the -r option, like this: cp -r <foldername> <newfoldername> . For example, cp -r data data_backup will create a copy of the data directory and call it data_backup .","title":"Recipe 10: Copy a File or Directory"},{"location":"recipes/core/workflow/manage-files/#recipe-11-view-the-contents-of-a-file","text":"To display the contents of a text file, execute cat <filename> , replacing <filename> with the name of the file you want to view. For example, cat oldfile.txt will display the contents of a file named oldfile.txt . Why cat ? Because the command's full purpose is to concatenate multiple files together. We're just using it as an easy way to dump out the contents of one.","title":"Recipe 11: View the Contents of a File"},{"location":"recipes/core/workflow/manage-files/#recipe-12-save-the-output-of-a-command-to-a-file","text":"To save the output of a command to a file, execute the command as normal, but append > <filename> to the end of it before hitting retutrn. (Replace <filename> with the name of the file you want to save the output to, of course.) For example, ls -lFh > filelist.txt will save a detailed listing of the files in the current directory to a file named filelist.txt . If the file already exists, it will be overwritten. If it doesn't exist, it will be created. If you instead want to append the output to an existing file, use >> instead of > .","title":"Recipe 12: Save the Output of a Command to a File"},{"location":"recipes/core/workflow/manage-files/#recipe-13-delete-a-file-or-directory","text":"Note: Unlike most of what you do on a computer, deleting a file or folder via the command line cannot be undone. Be careful! Pause a moment to ensure you know what you're doing and that you really want to do it. Delete a file by executing rm <filename> , replacing <filename> with the name of the file you want to delete. For example, rm oldfile.txt will delete a file named oldfile.txt . Delete a directory and all its contents by executing rm -r <foldername> , replacing <foldername> with the name of the directory you want to delete. For example, rm -r data will delete a directory named data and all its contents. The -r option means \"recursive\", which means \"and everything inside it\".","title":"Recipe 13: Delete a File or Directory"},{"location":"recipes/core/workflow/manage-files/#recipe-14-clear-the-terminal","text":"Empty the terminal display of all prior commands and output by executing clear . This does not undo the history of what's happened; it just removes the clutter from your view. You can still up-arrow through the command history.","title":"Recipe 14: Clear the Terminal"},{"location":"recipes/core/workflow/manage-files/#recipe-15-quit-the-terminal-session","text":"To quit the terminal session, execute exit . This will close the current tab AND shut down the terminal process. Warning: If you just close the Terminal display by clicking on the \"X\" in the tab bar, the process will still be running on the server, just out of sight. In that case: In the far left window border, click the square-inside-a-circle icon to replace the File Browser with the \"Running Terminals and Processes\" panel. Down at the bottom, find the Terminals section, and click \"Shut Down All\", then agree to the confirmation dialog. Alternatively, you can expand that section, find the terminal session listed under it, mouse over it, and click the \"X\" that appears to its right. This is useful if you have multiple terminals going, and only want to kill one of them.","title":"Recipe 15: Quit the Terminal Session"},{"location":"recipes/core/workflow/submit-level/","text":"Submit a Level Problem to Solve I want to submit a repo (level or superboss) of completed work for course credit. Recipe 1: Submitting When Complete Do one final commit-and-push of the repo, following the recipe Commit and Push Changes to GitHub . Go to GitHub (probably in a different browser tab). Navigate to the main page of your fork of the repo . You can click on the \"Repositories\" tab at the top of the page while in our GitHub org. Near the top of that page, just above the list of files, you should see a message that says something like \"This branch is X commits ahead of UNCG-PHY-351-S25:main. Click on the \"Contribute\" button to the right of that message. A dialog box should appear. Click the big green button \"Open pull request\" button . That's your \"submit\" button! That takes you to a form that gives you a chance to change the title of your pull request (submission) and add a message. Change the title to \"Done and submitting\" (or whatever is appropriate). Add a comment in the \"Leave a comment\" box if there's anything else you think I should know when I look at your submission. If there's something in particular you'd like feedback on, this is a good place to say so. Click the green \"Create pull request\" button at the bottom. Look for the green check by \"This branch has no conflicts with the base branch\" . If you don't see it, let Prof. Beatty know ASAP. We'll figure it out. That's it, you've submitted! If you realize you've submitted in error , you can \"un-submit\" by scrolling to the bottom of that page \u2014 down below \"This branch has no conflicts with the base branch\" \u2014 and clicking the \"Close pull request\" button. - Before doing so, please put a note in the \"Add a comment\" section right above it saying what's going on, just to avoid confusion. Thanks. Recipe 2: Resubmitting If I kick your initial submission back for revision and you've then fixed whatever the problem was, you can resubmit by following the same steps as above. However, Please use a title like \"Resubmitting fixed version\". Add a comment in the \"Leave a comment\" box explaining what you fixed, or anything else that might help me not be confused. Thanks.","title":"Submit a Level"},{"location":"recipes/core/workflow/submit-level/#submit-a-level","text":"","title":"Submit a Level"},{"location":"recipes/core/workflow/submit-level/#problem-to-solve","text":"I want to submit a repo (level or superboss) of completed work for course credit.","title":"Problem to Solve"},{"location":"recipes/core/workflow/submit-level/#recipe-1-submitting-when-complete","text":"Do one final commit-and-push of the repo, following the recipe Commit and Push Changes to GitHub . Go to GitHub (probably in a different browser tab). Navigate to the main page of your fork of the repo . You can click on the \"Repositories\" tab at the top of the page while in our GitHub org. Near the top of that page, just above the list of files, you should see a message that says something like \"This branch is X commits ahead of UNCG-PHY-351-S25:main. Click on the \"Contribute\" button to the right of that message. A dialog box should appear. Click the big green button \"Open pull request\" button . That's your \"submit\" button! That takes you to a form that gives you a chance to change the title of your pull request (submission) and add a message. Change the title to \"Done and submitting\" (or whatever is appropriate). Add a comment in the \"Leave a comment\" box if there's anything else you think I should know when I look at your submission. If there's something in particular you'd like feedback on, this is a good place to say so. Click the green \"Create pull request\" button at the bottom. Look for the green check by \"This branch has no conflicts with the base branch\" . If you don't see it, let Prof. Beatty know ASAP. We'll figure it out. That's it, you've submitted! If you realize you've submitted in error , you can \"un-submit\" by scrolling to the bottom of that page \u2014 down below \"This branch has no conflicts with the base branch\" \u2014 and clicking the \"Close pull request\" button. - Before doing so, please put a note in the \"Add a comment\" section right above it saying what's going on, just to avoid confusion. Thanks.","title":"Recipe 1: Submitting When Complete"},{"location":"recipes/core/workflow/submit-level/#recipe-2-resubmitting","text":"If I kick your initial submission back for revision and you've then fixed whatever the problem was, you can resubmit by following the same steps as above. However, Please use a title like \"Resubmitting fixed version\". Add a comment in the \"Leave a comment\" box explaining what you fixed, or anything else that might help me not be confused. Thanks.","title":"Recipe 2: Resubmitting"},{"location":"recipes/num1/","text":"Numerical Methods 1: Finding Roots & Extrema \"Numerical methods\" are algorithms \u2014 recipes, if you will \u2014 for solving mathematical problems via numerical calculations on a computer. There is a vast vast VAST literature on such things, and this course will barely scratch the surface. That, however, should be enough to give you a sense of how the game is played, and to empower you to track down the methods you need when you do. Our first set of numerical methods focus on two things you might want to do to an equation: solve it (i.e., \"find its root(s)\"), and find its extrema (maxima and/or minima). For some equations, this is easily done with analytic methods (paper and pencil rearranging of symbols). For others, analytic methods fail, and numerical methods are the only way to go. In between, we get cases that could in principle be solved analytically, given enough time and a big enough whiteboard, but why bother when a computer can do it quickly and easily? Solving nonlinear equations: Three different algorithms for \"finding the roots of an equation\", each with its own advantages and disadvantages. Finding extrema: A recipe for finding maxima or minima of a one-dimensional function, and another for finding extrema of 2D, 3D, and higher-dimensional functions.","title":"Numerical Methods 1: Finding Roots &amp; Extrema"},{"location":"recipes/num1/#numerical-methods-1-finding-roots-extrema","text":"\"Numerical methods\" are algorithms \u2014 recipes, if you will \u2014 for solving mathematical problems via numerical calculations on a computer. There is a vast vast VAST literature on such things, and this course will barely scratch the surface. That, however, should be enough to give you a sense of how the game is played, and to empower you to track down the methods you need when you do. Our first set of numerical methods focus on two things you might want to do to an equation: solve it (i.e., \"find its root(s)\"), and find its extrema (maxima and/or minima). For some equations, this is easily done with analytic methods (paper and pencil rearranging of symbols). For others, analytic methods fail, and numerical methods are the only way to go. In between, we get cases that could in principle be solved analytically, given enough time and a big enough whiteboard, but why bother when a computer can do it quickly and easily? Solving nonlinear equations: Three different algorithms for \"finding the roots of an equation\", each with its own advantages and disadvantages. Finding extrema: A recipe for finding maxima or minima of a one-dimensional function, and another for finding extrema of 2D, 3D, and higher-dimensional functions.","title":"Numerical Methods 1: Finding Roots &amp; Extrema"},{"location":"recipes/num2/","text":"Numerical Methods 2: Numerical Calculus Doing math involves more than solving equations; it often requires taking derivatives and integrating. Computers can do that too! The key involves forgetting most of what you learned in calculus courses, and going back to the initial definitions of \"derivative\" and \"integral\"\u2026 and then applying a whole lot of numerical cleverness.","title":"Numerical Methods 2: Numerical Calculus"},{"location":"recipes/num2/#numerical-methods-2-numerical-calculus","text":"Doing math involves more than solving equations; it often requires taking derivatives and integrating. Computers can do that too! The key involves forgetting most of what you learned in calculus courses, and going back to the initial definitions of \"derivative\" and \"integral\"\u2026 and then applying a whole lot of numerical cleverness.","title":"Numerical Methods 2: Numerical Calculus"},{"location":"recipes/scipy/","text":"Skillset B: Scientific Python Here we introduce recipes focused on aspects of python central to numerically-intensive work. These include a deep understanding of how computers handle numbers, working with arrays and matrices of values, creating plots and other data visualizations, and reading to or writing from data files. Along the way, we'll introduce numpy and matplotlib , add-ons to the python language that support numerically-focused work. Machine arithmetic: Recipes for working with numerical values safely, accurately, and efficiently. Arrays: Recipes for using numpy arrays (1D, 2D, and even higher) to accomplish stuff. Plotting: Recipes for using matplotlib to construct 2D, y vs. x plots all tweaked out and ready to publish. Histograms: Because a y vs. x plot is not always the right data visualization tool for the job. Files: Recipes for reading in datafiles, including high-maintenance ones, and for writing out your own results to files for safekeeping or sharing.","title":"Skillset B: Scientific Python"},{"location":"recipes/scipy/#skillset-b-scientific-python","text":"Here we introduce recipes focused on aspects of python central to numerically-intensive work. These include a deep understanding of how computers handle numbers, working with arrays and matrices of values, creating plots and other data visualizations, and reading to or writing from data files. Along the way, we'll introduce numpy and matplotlib , add-ons to the python language that support numerically-focused work. Machine arithmetic: Recipes for working with numerical values safely, accurately, and efficiently. Arrays: Recipes for using numpy arrays (1D, 2D, and even higher) to accomplish stuff. Plotting: Recipes for using matplotlib to construct 2D, y vs. x plots all tweaked out and ready to publish. Histograms: Because a y vs. x plot is not always the right data visualization tool for the job. Files: Recipes for reading in datafiles, including high-maintenance ones, and for writing out your own results to files for safekeeping or sharing.","title":"Skillset B: Scientific Python"},{"location":"recipes/visual/","text":"Skillset C: Visual Python Yeah, \"solving\" a physics problem and getting a bunch of numbers out \u2013 or even a pretty plot \u2014 is nice, but there's no substitute for seeing the behavior of your modeled system evolve in realtime. VPython (\"visual python\") is an add-on toolkit for doing exactly that, and it makes constructing and animating 3D simulations embarrassingly easy.","title":"Skillset C: Visual Python"},{"location":"recipes/visual/#skillset-c-visual-python","text":"Yeah, \"solving\" a physics problem and getting a bunch of numbers out \u2013 or even a pretty plot \u2014 is nice, but there's no substitute for seeing the behavior of your modeled system evolve in realtime. VPython (\"visual python\") is an add-on toolkit for doing exactly that, and it makes constructing and animating 3D simulations embarrassingly easy.","title":"Skillset C: Visual Python"},{"location":"topics/","text":"Python Topics Reference This section of the website contains miscellaneous bits and pieces about various aspects of python. (I needed someplace to throw tidbits that aren't directly associated with a particular recipe.) This area is likely to grow and reorganize organically, so use the navigation menu above to see what's here.","title":"Overview"},{"location":"topics/#python-topics-reference","text":"This section of the website contains miscellaneous bits and pieces about various aspects of python. (I needed someplace to throw tidbits that aren't directly associated with a particular recipe.) This area is likely to grow and reorganize organically, so use the navigation menu above to see what's here.","title":"Python Topics Reference"},{"location":"topics/external/","text":"External Tutorials of Possible Utility This is a list of topically-focused python-related tutorial and reference articles that I've stumbled across while putting this course together, thought might be useful to y'all, and not been excessively annoyed by. Do NOT assume that you're supposed to learn or know everything in them! Workflow Topics The Python Standard REPL: Try Out Code and Ideas Quickly by Real Python Core Python Topics Real Python has several good Python Basics tutorials , including: Numbers in Python Basic Data Types in Python: A Quick Exploration Variables in Python: Usage and Best Practices Operators and Expressions in Python Python Modules and Packages \u2013 An Introduction Python's Built-in Functions: A Complete Exploration Simplify Complex Numbers With Python Your Guide to the Python print() Function Formatting Floats Inside Python F-Strings How to Read User Input From the Keyboard in Python How to Read Python Input as Integers Lists vs Tuples in Python Python range(): Represent Numerical Ranges Using the zip() Function for Parallel Iteration Python enumerate(): Simplify Loops That Need Counters Defining Your Own Python Function Using Python Optional Arguments When Defining Functions Namespaces and Scope in Python","title":"External Tutorials"},{"location":"topics/external/#external-tutorials-of-possible-utility","text":"This is a list of topically-focused python-related tutorial and reference articles that I've stumbled across while putting this course together, thought might be useful to y'all, and not been excessively annoyed by. Do NOT assume that you're supposed to learn or know everything in them!","title":"External Tutorials of Possible Utility"},{"location":"topics/external/#workflow-topics","text":"The Python Standard REPL: Try Out Code and Ideas Quickly by Real Python","title":"Workflow Topics"},{"location":"topics/external/#core-python-topics","text":"Real Python has several good Python Basics tutorials , including: Numbers in Python Basic Data Types in Python: A Quick Exploration Variables in Python: Usage and Best Practices Operators and Expressions in Python Python Modules and Packages \u2013 An Introduction Python's Built-in Functions: A Complete Exploration Simplify Complex Numbers With Python Your Guide to the Python print() Function Formatting Floats Inside Python F-Strings How to Read User Input From the Keyboard in Python How to Read Python Input as Integers Lists vs Tuples in Python Python range(): Represent Numerical Ranges Using the zip() Function for Parallel Iteration Python enumerate(): Simplify Loops That Need Counters Defining Your Own Python Function Using Python Optional Arguments When Defining Functions Namespaces and Scope in Python","title":"Core Python Topics"},{"location":"topics/core/operators/","text":"Arithmetic Operators the binary operators Knowing your python arithmetic operators is essential. Here are python's relevant binary operators . (\"Binary\" means that they act on two quantities by being placed between them.) Addition: + Just like standard mathematical notation. Implement \" \\(3+4\\) \" as 3 + 4 . Subtraction: - Also just like standard mathematical notation. Implement \" \\(3-4\\) \" as 3 - 4 . Multiplication: * NOT like standard mathematical notation. Python uses the asterisk character instead of the \"times\" sign, and does not recognize implicit multiplication when two quantities are side-by-side. Implement \" \\(3 \\times 4\\) \" as 3 * 4 , and \" \\(2x\\) \" as 2 * x . In python, 2a is an illegal variable name (because it begins with a digit), and 2 a is just invalid syntax in most contexts. Division: / Like some standard mathematical notation. Implement \" \\(3 \\div 4\\) \" as 3 / 4 . The numerator and denominator go on the left and right. Python has no way to arrange them vertically, as in \" \\(\\frac{3}{4}\\) \". That means you can't put a compound expression like \" \\(1 + x\\) \" in the numerator or denominator without using parentheses to group it. (We'll discuss this more thoroughly in Operator Precedence .) Exponentiation: ** NOT like standard mathematical notation OR most other programming languages OR scientific calculators OR just about anything else! Implement \" \\(3^4\\) \" like this: 3**4 . By the way, do NOT use the exponentiation operator for scientific notation. A numeric literal like \\(2.99 \\times 10^8\\) should be entered as 2.99e8 , not as 2.99 * 10**8 . Why? Because python can interpret the first form directly as a floating-point number, with no arithmetic calculations needed. If you use the second form, python has to do two two floating-point calculations \u2014 exponentiation and multiplication. Both take processor time, and both introduce a tiny bit of round-off error. While the impact is tiny, it can really add up within a big loop or matrix. (Also, the first form is way more compact and generally easier to read.) Beware the up-carat! A very very VERY common error among physics students (and instructors too \ud83d\ude2c) is to use an up-carat ^ , as in 3^4 , instead of the double-asterisk \u2014 simply because it's such a habit from non-python work. Unfortunately, if you make this mistake in python, you won't get an error message or any other clear sign that you did something wrong, because the up-carat IS a legitimate arithmetic operator in python! It just doesn't do what you think it should. It does \"bitwise exclusive or\", an obscure binary-logic operation you'll probably never need. So if you accidentally use ^ instead of ** , your calculation or program will probably run without errors. You'll either pull your hair out trying to figure out why its results are wacky, or \u2014 worse \u2014 be blithely ignorant that they're totally wrong. You have been warned. \ud83d\udc40 Modulo % (Also called the modulus operator.) x % y yields the remainder when \\(x\\) is divided by \\(y\\) . For example, 7 % 3 yields 1 , and 7.5 % 3 yields 1.5 . Floor Division // This is complementary to modulo. x % y yields the integer number of times that \\(y\\) divides into \\(x\\) \u2014 in other words, the integer part of \\(x \\div y\\) , discarding the remainder. You can be confident that you understand these operators when it's obvious to you why (x // y) * y + x % y always evaluates to the same value as x / y . Modulo and floor division don't show up much in physics, but they can be surprisingly useful in simplifying the logic of a program. For example, if you're iterating over \\(N\\) things in groups of \\(m\\) at a time, N // m is the number of full-sized groups you'll process and N % m is the number \"left over\" for a final, undersized group. the unary operator Unary operators act on a single quantity. Python only has two you're likely to need (unless you get into bitwise binary logic), and only one is meant for numeric calculations. (We'll meet the other one in an upcoming encounter with Boolean Logic .) Negation: - Sticking a minus sign in front of a numerical quantity flips its sign, from positive to negative or negative to positive, exactly as you would expect. -3 + 4 will evaluate to 1 , and -(2 - 5) to 3 . How does python know whether to interpret - as a binary subtraction operator or a unary negation operator? I can't think of an expression in which both interpretations of a particular - are syntactically legal. the assignment operators It's fairly common in coding to want to set a variable's value to \"its current value plus \\(k\\) \" or \"its current value minus \\(k\\) or \" \\(n\\) times its current value\" or \"one- \\(n^\\text{th}\\) of its current value\", or something like that. The point is that you want to change the value of a variable to be the result of a simple algebraic expression involving its current value. This is easy enough to do with the algebraic operators above: x = x + k , x = x - k , x = x * n , x = x / n , etc. However, because this is so common, python offers you some shortcuts that are slightly more compact, and definitely quicker for a human reader to digest: the assignment operators . shortcut is equivalent to shortcut is equivalent to a += b a = a + b a **= b a = a**b a -= b a = a - b a %= b a = a % b a *= b a = a * b a //= b a = a // b a /= b a = a / b the importance of whitespace The python interpreter doesn't care whether you put space characters around your operators or not. As far as it is concerned, m=32/-2 , m = 32 / - 2 , m = 32/- 2 , m = 32/ - 2 , m=32 / -2 , and m = 32 / -2 are all entirely equivalent. However\u2026 which is easiest for a human to interpret at a glance? That is NOT a small consideration! Important: Strive to make your code, and especially your numerical calculations, as clear and easy-to-read as possible. Adopting this habit will drastically reduce the likelihood that your calculations will contain unintended errors, and will make it easier for you to find errors when you're debugging. It will also reduce the cognitive burden on someone reading the code to figure out what it does. (That someone might very well be you, in the future, trying to remember WTH you were thinking when you wrote it.) As a general rule: Unless you have a very specific reason to do otherwise, Put one space character on either side of a binary operator. That makes it easier to distinguish the operators from their operands. Exception: Don't put spaces around ( ** ) for exponentiation. That helps a reader quickly distinguish it from multiplication. And, as you'll see soon in operator precedence , it better communicates the order in which the operations will occur. Don't put a space between a unary minus and the value it's negating. That makes clear it's a sign flip, not a subtraction. Put a space on either side of an assignment operator, whether that be normal assignment with = or one of the shortcut operators like += . That makes it easier to visually distinguish the expression to evaluate from the variable it's assigned to. (The \"walrus operator\" is a bit of a special case, because it usually needs parentheses to have the intended effect. More on this later.) Remember, space characters don't cost you anything and don't run out. You don't get bonus points for making your code as dense as possible. Quite the contrary \u2014 readability does count!","title":"Arithmetic Operators"},{"location":"topics/core/operators/#arithmetic-operators","text":"","title":"Arithmetic Operators"},{"location":"topics/core/operators/#the-binary-operators","text":"Knowing your python arithmetic operators is essential. Here are python's relevant binary operators . (\"Binary\" means that they act on two quantities by being placed between them.) Addition: + Just like standard mathematical notation. Implement \" \\(3+4\\) \" as 3 + 4 . Subtraction: - Also just like standard mathematical notation. Implement \" \\(3-4\\) \" as 3 - 4 . Multiplication: * NOT like standard mathematical notation. Python uses the asterisk character instead of the \"times\" sign, and does not recognize implicit multiplication when two quantities are side-by-side. Implement \" \\(3 \\times 4\\) \" as 3 * 4 , and \" \\(2x\\) \" as 2 * x . In python, 2a is an illegal variable name (because it begins with a digit), and 2 a is just invalid syntax in most contexts. Division: / Like some standard mathematical notation. Implement \" \\(3 \\div 4\\) \" as 3 / 4 . The numerator and denominator go on the left and right. Python has no way to arrange them vertically, as in \" \\(\\frac{3}{4}\\) \". That means you can't put a compound expression like \" \\(1 + x\\) \" in the numerator or denominator without using parentheses to group it. (We'll discuss this more thoroughly in Operator Precedence .) Exponentiation: ** NOT like standard mathematical notation OR most other programming languages OR scientific calculators OR just about anything else! Implement \" \\(3^4\\) \" like this: 3**4 . By the way, do NOT use the exponentiation operator for scientific notation. A numeric literal like \\(2.99 \\times 10^8\\) should be entered as 2.99e8 , not as 2.99 * 10**8 . Why? Because python can interpret the first form directly as a floating-point number, with no arithmetic calculations needed. If you use the second form, python has to do two two floating-point calculations \u2014 exponentiation and multiplication. Both take processor time, and both introduce a tiny bit of round-off error. While the impact is tiny, it can really add up within a big loop or matrix. (Also, the first form is way more compact and generally easier to read.) Beware the up-carat! A very very VERY common error among physics students (and instructors too \ud83d\ude2c) is to use an up-carat ^ , as in 3^4 , instead of the double-asterisk \u2014 simply because it's such a habit from non-python work. Unfortunately, if you make this mistake in python, you won't get an error message or any other clear sign that you did something wrong, because the up-carat IS a legitimate arithmetic operator in python! It just doesn't do what you think it should. It does \"bitwise exclusive or\", an obscure binary-logic operation you'll probably never need. So if you accidentally use ^ instead of ** , your calculation or program will probably run without errors. You'll either pull your hair out trying to figure out why its results are wacky, or \u2014 worse \u2014 be blithely ignorant that they're totally wrong. You have been warned. \ud83d\udc40 Modulo % (Also called the modulus operator.) x % y yields the remainder when \\(x\\) is divided by \\(y\\) . For example, 7 % 3 yields 1 , and 7.5 % 3 yields 1.5 . Floor Division // This is complementary to modulo. x % y yields the integer number of times that \\(y\\) divides into \\(x\\) \u2014 in other words, the integer part of \\(x \\div y\\) , discarding the remainder. You can be confident that you understand these operators when it's obvious to you why (x // y) * y + x % y always evaluates to the same value as x / y . Modulo and floor division don't show up much in physics, but they can be surprisingly useful in simplifying the logic of a program. For example, if you're iterating over \\(N\\) things in groups of \\(m\\) at a time, N // m is the number of full-sized groups you'll process and N % m is the number \"left over\" for a final, undersized group.","title":"the binary operators"},{"location":"topics/core/operators/#the-unary-operator","text":"Unary operators act on a single quantity. Python only has two you're likely to need (unless you get into bitwise binary logic), and only one is meant for numeric calculations. (We'll meet the other one in an upcoming encounter with Boolean Logic .) Negation: - Sticking a minus sign in front of a numerical quantity flips its sign, from positive to negative or negative to positive, exactly as you would expect. -3 + 4 will evaluate to 1 , and -(2 - 5) to 3 . How does python know whether to interpret - as a binary subtraction operator or a unary negation operator? I can't think of an expression in which both interpretations of a particular - are syntactically legal.","title":"the unary operator"},{"location":"topics/core/operators/#the-assignment-operators","text":"It's fairly common in coding to want to set a variable's value to \"its current value plus \\(k\\) \" or \"its current value minus \\(k\\) or \" \\(n\\) times its current value\" or \"one- \\(n^\\text{th}\\) of its current value\", or something like that. The point is that you want to change the value of a variable to be the result of a simple algebraic expression involving its current value. This is easy enough to do with the algebraic operators above: x = x + k , x = x - k , x = x * n , x = x / n , etc. However, because this is so common, python offers you some shortcuts that are slightly more compact, and definitely quicker for a human reader to digest: the assignment operators . shortcut is equivalent to shortcut is equivalent to a += b a = a + b a **= b a = a**b a -= b a = a - b a %= b a = a % b a *= b a = a * b a //= b a = a // b a /= b a = a / b","title":"the assignment operators"},{"location":"topics/core/operators/#the-importance-of-whitespace","text":"The python interpreter doesn't care whether you put space characters around your operators or not. As far as it is concerned, m=32/-2 , m = 32 / - 2 , m = 32/- 2 , m = 32/ - 2 , m=32 / -2 , and m = 32 / -2 are all entirely equivalent. However\u2026 which is easiest for a human to interpret at a glance? That is NOT a small consideration! Important: Strive to make your code, and especially your numerical calculations, as clear and easy-to-read as possible. Adopting this habit will drastically reduce the likelihood that your calculations will contain unintended errors, and will make it easier for you to find errors when you're debugging. It will also reduce the cognitive burden on someone reading the code to figure out what it does. (That someone might very well be you, in the future, trying to remember WTH you were thinking when you wrote it.) As a general rule: Unless you have a very specific reason to do otherwise, Put one space character on either side of a binary operator. That makes it easier to distinguish the operators from their operands. Exception: Don't put spaces around ( ** ) for exponentiation. That helps a reader quickly distinguish it from multiplication. And, as you'll see soon in operator precedence , it better communicates the order in which the operations will occur. Don't put a space between a unary minus and the value it's negating. That makes clear it's a sign flip, not a subtraction. Put a space on either side of an assignment operator, whether that be normal assignment with = or one of the shortcut operators like += . That makes it easier to visually distinguish the expression to evaluate from the variable it's assigned to. (The \"walrus operator\" is a bit of a special case, because it usually needs parentheses to have the intended effect. More on this later.) Remember, space characters don't cost you anything and don't run out. You don't get bonus points for making your code as dense as possible. Quite the contrary \u2014 readability does count!","title":"the importance of whitespace"},{"location":"topics/core/precedence/","text":"Operator Precedence TBW\u2026","title":"Operator Precedence"},{"location":"topics/core/precedence/#operator-precedence","text":"TBW\u2026","title":"Operator Precedence"},{"location":"topics/scipy/numpy/","text":"Introduction to Numpy TBW\u2026","title":"Introduction to Numpy"},{"location":"topics/scipy/numpy/#introduction-to-numpy","text":"TBW\u2026","title":"Introduction to Numpy"},{"location":"topics/setup/","text":"Setup Guide This section contains step-by-step guides to various start-of-course setting-up tasks. Most likely, you'll only need to do each of these once. Creating Your GitHub Account Creating Your Beskar Account","title":"Overview"},{"location":"topics/setup/#setup-guide","text":"This section contains step-by-step guides to various start-of-course setting-up tasks. Most likely, you'll only need to do each of these once. Creating Your GitHub Account Creating Your Beskar Account","title":"Setup Guide"},{"location":"topics/setup/beskar-account/","text":"Creating your Beskar Account For this course, you'll do your coding-type work on a computational physics workstation named Beskar . It lives on Prof. Beatty's desk. A piece of server software named JupyterHub runs on Beskar, and it lets you connect through a web browser and do all your work that way. Easy peasy! Prof. Beatty should already have added you to the list of authorized users. All you need to do is to log in to it. The first time you do, you'll select your password. Part A: Log Into Beskar Point your web browser to https://beskar.uncg.edu/ . That should take you to a \"sign in\" page. Enter your UNCG user ID for \"Username\". That's the part of your UNCG email address that precedes the @ symbol. Enter the password you wish to use with this acccount. Whatever you enter the very first time will become your password, so type it very carefully . Pick your password thoughtfully. Please please please PLEASE pick a secure one that's at least 8 characters (longer is better) and contains a mix of lowercase letters, uppercase letters, digits, and symbols. Personally, I recommend just using your UNCG password. That will be easy for you to remember. (And it's encrypted on Beskar such that I have no way to view it. Promise.) Click the \"Sign In\" button. That should take you to the main interface of JupyterLab, our coding environment. If you run into any weird errors, such as \"failure to spawn server\" type things, contact Prof. Beatty ASAP. This step has been a little flaky during testing. \ud83d\ude2c I think I've got it fixed, but\u2026 \ud83e\udd1e Part B: Welcome to JupyterLab Feel free to explore the JupyterLab interface a bit, if you want. Or, forge ahead with the assignments.","title":"Creating your Beskar Account"},{"location":"topics/setup/beskar-account/#creating-your-beskar-account","text":"For this course, you'll do your coding-type work on a computational physics workstation named Beskar . It lives on Prof. Beatty's desk. A piece of server software named JupyterHub runs on Beskar, and it lets you connect through a web browser and do all your work that way. Easy peasy! Prof. Beatty should already have added you to the list of authorized users. All you need to do is to log in to it. The first time you do, you'll select your password.","title":"Creating your Beskar Account"},{"location":"topics/setup/beskar-account/#part-a-log-into-beskar","text":"Point your web browser to https://beskar.uncg.edu/ . That should take you to a \"sign in\" page. Enter your UNCG user ID for \"Username\". That's the part of your UNCG email address that precedes the @ symbol. Enter the password you wish to use with this acccount. Whatever you enter the very first time will become your password, so type it very carefully . Pick your password thoughtfully. Please please please PLEASE pick a secure one that's at least 8 characters (longer is better) and contains a mix of lowercase letters, uppercase letters, digits, and symbols. Personally, I recommend just using your UNCG password. That will be easy for you to remember. (And it's encrypted on Beskar such that I have no way to view it. Promise.) Click the \"Sign In\" button. That should take you to the main interface of JupyterLab, our coding environment. If you run into any weird errors, such as \"failure to spawn server\" type things, contact Prof. Beatty ASAP. This step has been a little flaky during testing. \ud83d\ude2c I think I've got it fixed, but\u2026 \ud83e\udd1e","title":"Part A: Log Into Beskar"},{"location":"topics/setup/beskar-account/#part-b-welcome-to-jupyterlab","text":"Feel free to explore the JupyterLab interface a bit, if you want. Or, forge ahead with the assignments.","title":"Part B: Welcome to JupyterLab"},{"location":"topics/setup/github-account/","text":"Creating your GitHub Account For this course, you'll need a GitHub account tied to your UNCG email address. If you happen to have one already \u2014 from a CS course, perhaps \u2014 great. (You'll still need to do the final step below, though.) If not, here's how to create one. Part A: Create the GitHub Account In a web browser, open https://github.com/ in a new browser tab or window. The page you land on should have a prominent \"Sign up for GitHub\" button next to a blank for your email address. Enter your UNCG email address and click. Follow the account creation steps (email authentication, etc.). IMPORTANT: When prompted for \"Username\", choose your UNCG user ID: The portion of your UNCG email address before the \"@\" symbol. Pick your password carefully, as you'll need to use it frequently. (May I suggest getting and learning to use a good password management program? I use 1Password .) At the appropriate step, identify yourself as a \"student\". Choose the free student plan. When you get to the page with \"The home for all developers \u2014 including you\" at the top, you've succeeded! Part B: Get Added to the Course \"Org\" Now that you've created your GitHub account, tell Prof. Beatty. He'll add you to the course GitHub org. Wait\u2026 \u23f3\u231b\ufe0f\u2026 (hopefully not long!)\u2026 until\u2026 Prof. Beatty lets you know that you've been added. You can check or verify by going to GitHub, clicking on your user icon in the far upper right, and selecting \"Your organizations\". You should see \"UNCG-PHY-351-S25\" listed there. Thereafter\u2026 Once you've been added to the org, you can go directly to the org's GitHub page via https://github.com/UNCG-PHY-351-S25 You might want to bookmark that!","title":"Creating your GitHub Account"},{"location":"topics/setup/github-account/#creating-your-github-account","text":"For this course, you'll need a GitHub account tied to your UNCG email address. If you happen to have one already \u2014 from a CS course, perhaps \u2014 great. (You'll still need to do the final step below, though.) If not, here's how to create one.","title":"Creating your GitHub Account"},{"location":"topics/setup/github-account/#part-a-create-the-github-account","text":"In a web browser, open https://github.com/ in a new browser tab or window. The page you land on should have a prominent \"Sign up for GitHub\" button next to a blank for your email address. Enter your UNCG email address and click. Follow the account creation steps (email authentication, etc.). IMPORTANT: When prompted for \"Username\", choose your UNCG user ID: The portion of your UNCG email address before the \"@\" symbol. Pick your password carefully, as you'll need to use it frequently. (May I suggest getting and learning to use a good password management program? I use 1Password .) At the appropriate step, identify yourself as a \"student\". Choose the free student plan. When you get to the page with \"The home for all developers \u2014 including you\" at the top, you've succeeded!","title":"Part A: Create the GitHub Account"},{"location":"topics/setup/github-account/#part-b-get-added-to-the-course-org","text":"Now that you've created your GitHub account, tell Prof. Beatty. He'll add you to the course GitHub org. Wait\u2026 \u23f3\u231b\ufe0f\u2026 (hopefully not long!)\u2026 until\u2026 Prof. Beatty lets you know that you've been added. You can check or verify by going to GitHub, clicking on your user icon in the far upper right, and selecting \"Your organizations\". You should see \"UNCG-PHY-351-S25\" listed there.","title":"Part B: Get Added to the Course \"Org\""},{"location":"topics/setup/github-account/#thereafter","text":"Once you've been added to the org, you can go directly to the org's GitHub page via https://github.com/UNCG-PHY-351-S25 You might want to bookmark that!","title":"Thereafter\u2026"},{"location":"topics/tools/github/","text":"Useful Links About Git and GitHub An Intro to Git and GitHub for Beginners (Tutorial)","title":"Useful Links About Git and GitHub"},{"location":"topics/tools/github/#useful-links-about-git-and-github","text":"An Intro to Git and GitHub for Beginners (Tutorial)","title":"Useful Links About Git and GitHub"}]}